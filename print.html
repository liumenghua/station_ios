<!DOCTYPE HTML>
<html lang="zh-CN" class="sidebar-visible no-js rust">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>iOS 小站</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "rust";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="questions/chapter_0_forward.html">前言</a></li><li class="chapter-item expanded "><a href="questions/chapter_1_foundation.html"><strong aria-hidden="true">1.</strong> Foundation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="answer/01_foundation/01_ans_foundation_01.html"><strong aria-hidden="true">1.1.</strong> Foundation</a></li><li class="chapter-item expanded "><a href="answer/01_foundation/01_ans_foundation_02.html"><strong aria-hidden="true">1.2.</strong> 集合</a></li><li class="chapter-item expanded "><a href="answer/01_foundation/01_ans_foundation_03.html"><strong aria-hidden="true">1.3.</strong> C/C++</a></li></ol></li><li class="chapter-item expanded "><a href="questions/chapter_2_uikit.html"><strong aria-hidden="true">2.</strong> UIKit</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="answer/02_uikit/02_ans_uikit_01.html"><strong aria-hidden="true">2.1.</strong> UIKit</a></li><li class="chapter-item expanded "><a href="answer/02_uikit/02_ans_uikit_02.html"><strong aria-hidden="true">2.2.</strong> 动画和渲染</a></li><li class="chapter-item expanded "><a href="answer/02_uikit/02_ans_uikit_03.html"><strong aria-hidden="true">2.3.</strong> 响应者链</a></li><li class="chapter-item expanded "><a href="answer/02_uikit/02_ans_uikit_04.html"><strong aria-hidden="true">2.4.</strong> APP</a></li><li class="chapter-item expanded "><a href="answer/02_uikit/02_ans_uikit_05.html"><strong aria-hidden="true">2.5.</strong> UIKit相关算法</a></li></ol></li><li class="chapter-item expanded "><a href="questions/chapter_3_memory.html"><strong aria-hidden="true">3.</strong> 内存管理</a></li><li class="chapter-item expanded "><a href="questions/chapter_4_runtime.html"><strong aria-hidden="true">4.</strong> Runtime</a></li><li class="chapter-item expanded "><a href="questions/chapter_5_runloop.html"><strong aria-hidden="true">5.</strong> Runloop</a></li><li class="chapter-item expanded "><a href="questions/chapter_6_thread.html"><strong aria-hidden="true">6.</strong> 多线程</a></li><li class="chapter-item expanded "><a href="questions/chapter_7_block.html"><strong aria-hidden="true">7.</strong> Block</a></li><li class="chapter-item expanded "><a href="questions/chapter_8_notification_delegate_kvo.html"><strong aria-hidden="true">8.</strong> 通知代理KVO</a></li><li class="chapter-item expanded "><a href="questions/chapter_9_data.html"><strong aria-hidden="true">9.</strong> 持久化</a></li><li class="chapter-item expanded "><a href="questions/chapter_10_design.html"><strong aria-hidden="true">10.</strong> 设计模式</a></li><li class="chapter-item expanded "><a href="questions/chapter_11_performance.html"><strong aria-hidden="true">11.</strong> 性能优化</a></li><li class="chapter-item expanded "><a href="questions/chapter_12_network.html"><strong aria-hidden="true">12.</strong> 计算机网络</a></li><li class="chapter-item expanded affix "><a href="chapter_books.html">推荐书目和博客</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">iOS 小站</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/liumenghua/station_ios" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="前言"><a class="header" href="#前言">前言</a></h1>
<p>本文档用于巩固 iOS 基础知识，通过问题-答案的形式总结 iOS 开发中常见的知识点，同时也是大厂面试中常考的题目。文档列出了前两个章节的答案，后面所有章节的答案均在小专栏中，整理和总结不易，欢迎到专栏中购买：</p>
<ul>
<li><a href="https://xiaozhuanlan.com/interviewios">专栏链接</a></li>
</ul>
<h1 id="构建工具"><a class="header" href="#构建工具">构建工具</a></h1>
<ul>
<li><a href="https://code.visualstudio.com/">Visual Studio Code</a> 书写</li>
<li><a href="https://github.com/rust-lang/mdBook">mdBook</a> 构建</li>
<li><a href="https://pages.github.com/">GitHub Pages</a> 发布</li>
<li><a href="https://github.com/features/actions">Github Actions</a> 自动部署</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="foundation"><a class="header" href="#foundation">Foundation</a></h1>
<ol>
<li>
<p><code>nil</code>、<code>NIL</code>、<code>NSNULL</code> 有什么区别？</p>
</li>
<li>
<p><code>struct</code>和<code>class</code>的区别? </p>
</li>
<li>
<p>实现 <code>isEqual</code> 和 <code>hash</code> 方法时要注意什么？</p>
</li>
<li>
<p>自定义对象用作字典的 key 的时需要注意什么？</p>
</li>
<li>
<p><code>id</code> 和 <code>instancetype</code> 有什么区别？</p>
</li>
<li>
<p><code>typeof()</code> 和 <code>__typeof()</code>，<code>__typeof__()</code> 的区别? </p>
</li>
<li>
<p><code>import</code> 和 <code>include</code> <code>@class</code> 的区别？</p>
</li>
<li>
<p><code>define</code> 和 <code>extern</code> 的区别？[</p>
</li>
<li>
<p><code>NSInteger</code> 的范围？32位系统和64位系统的差别？</p>
</li>
<li>
<p><code>imageNamed:</code> 和 <code>imageWithContentsOfFile:</code> 哪一个性能更好？为什么？</p>
</li>
<li>
<p><code>NSProxy</code> 和 <code>NSObject</code> 的区别？</p>
</li>
<li>
<p><code>NSMutableArray</code> 是线程安全的吗？如何实现一个线程安全的 <code>NSMutableArray</code>? </p>
</li>
<li>
<p><code>NSCache</code> 和 <code>NSMutableDictionary</code> 的区别和对比？</p>
</li>
<li>
<p><code>NSMutableSet</code> 和 <code>NSMutableArray</code> 的区别？</p>
</li>
<li>
<p><code>NSMapTable</code> 、 <code>NSHashTable</code> 、 <code>NSPointerArray</code> 在什么情况下使用？</p>
</li>
</ol>
<h1 id="cc-基础"><a class="header" href="#cc-基础">C/C++ 基础</a></h1>
<ol>
<li>
<p>下列代码中 p 的结果是多少？</p>
<pre><code class="language-c">int* p = 200;
p++;
printf(&quot;p:%d\n&quot;, p); 
</code></pre>
</li>
<li>
<p><code>char* p = &quot;123&quot;;</code> 和 <code>char p[] = &quot;123&quot;;</code> 的区别？[</p>
</li>
<li>
<p><code>sizeof</code> 的作用？ 32 位 和 64 位 系统下 <code>sizeof(NSInteger)</code> 为多少？</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="foundation-1"><a class="header" href="#foundation-1">Foundation</a></h1>
<h2 id="nilnilnsnull-有什么区别"><a class="header" href="#nilnilnsnull-有什么区别"><code>nil</code>、<code>NIL</code>、<code>NSNULL</code> 有什么区别？</a></h2>
<ul>
<li>
<p><code>nil</code>、<code>NIL</code>、<code>null</code> 可以说是等价的，都代表内存中一块空地址。</p>
</li>
<li>
<p><code>NSNULL</code> 代表一个指向 <code>nil</code> 的对象。通常在集合中占位使用，避免crash。</p>
</li>
</ul>
<h2 id="struct和class的区别"><a class="header" href="#struct和class的区别">struct和class的区别</a></h2>
<ul>
<li>本质区别：
<ul>
<li><code>class</code> 是引用类型，它在堆中分配空间，栈中保存的只是引用；</li>
<li><code>struct</code> 是值类型，它在栈中分配空间。</li>
</ul>
</li>
<li>使用场景：
<ul>
<li><code>struct</code> 有性能优势</li>
<li><code>class</code> 有面向对象的扩展优势.</li>
</ul>
</li>
</ul>
<h2 id="实现-isequal-和-hash-方法时要注意什么"><a class="header" href="#实现-isequal-和-hash-方法时要注意什么">实现 isEqual 和 hash 方法时要注意什么?</a></h2>
<p>在 iOS 中，判断两个对象内容是否相等，一般调用 <code>isEqual</code> 方法。用 <code>==</code> 来判断两个对象是否相等，其实是判断两个对象的地址是否相等。<code>isEqual</code> 系统默认实现是比较两个对象的指针。所以在项目中如果需要指定一套自己判断两个对象是否相同的标准的时候就需要重写<code>isEqual</code>。</p>
<p><code>hash</code> 方法的存在，是因为将对象加到 <code>NSSet</code> 等集合中时，需要利用对象的 <code>Hash</code> 值来标示对象在集合中的位置，将集合查找元素的时间复杂度优化成 O(1)。对于 <code>Hash</code> 值，系统默认是返回该对象的内存地址。</p>
<p>下面是一般<code>isEqual</code>和<code>hash</code>的写法模版。</p>
<pre><code class="language-objc">- (BOOL)isEqual:(id)object {
    // 1. == 判断地址
    if (self == object) return YES;
    
    // 2. isKindOfClass 判断对象类型
    if (![object isKindOfClass:[self class]]) return NO;

    // 3. 进行业务逻辑判断
    return [self isEqualToAnother:(Person *)object];
}

- (BOOL)isEqualToAnother:(Person *)anotherObj {
    // 业务逻辑
    if ([self.name isEqualToString:anotherObj.name]) {
        return YES;
    } else {
        return NO;
    }
}

- (NSUInteger)hash {
    return [self.name hash] ^ [self.job hash];
}

</code></pre>
<h2 id="自定义对象用作字典的-key-的时需要注意什么"><a class="header" href="#自定义对象用作字典的-key-的时需要注意什么">自定义对象用作字典的 key 的时需要注意什么？</a></h2>
<p>1.遵守<code>NSCopying</code>协议，并实现<code>copyWithZone:</code> 方法：字典的key需要遵守NSCopying协议，所以自定义对象作为key时，也需要遵守NSCopying协议，并实现copyWithZone方法</p>
<p>2.同时还需要实现 <code>isEqual</code> 和 <code>hash</code> 方法</p>
<p>实现：</p>
<pre><code class="language-objc">@interface CustomDictKey : NSObject&lt;NSCopying&gt;

@property (nonatomic, copy) NSString *name;

@end

@implementation CustomDictKey

- (id)copyWithZone:(nullable NSZone *)zone {
    CustomDictKey *aCopy = [[CustomDictKey allocWithZone:zone] init];
    if (aCopy) {
        aCopy.name = [self.name copyWithZone:zone];
    }
    return aCopy;
}

- (BOOL)isEqual:(id)other {
    if (other == self) return YES;
        
    if (![other isKindOfClass:[self class]]) return NO;
    
    return [self isEqualToAnother:(CustomDictKey *)other];
}

- (BOOL)isEqualToAnother:(CustomDictKey *)anotherObj {
    if ([self.name isEqualToString:anotherObj.name]) {
        return YES;
    } else {
        return NO;
    }
}

- (NSUInteger)hash {
    return [self.name hash] ^ [self.name hash];
}

@end
</code></pre>
<p>使用：</p>
<pre><code class="language-objc">    CustomDictKey *keyA = [[CustomDictKey alloc] init];
    keyA.name = @&quot;keyA&quot;;
    CustomDictKey *keyB = [[CustomDictKey alloc] init];
    keyB.name = @&quot;keyB&quot;;
    
    NSMutableDictionary *dict =[NSMutableDictionary dictionary];
    [dict setObject:@&quot;testObjectA&quot; forKey:keyA];
    [dict setObject:@&quot;testObjectB&quot; forKey:keyB];
    
    NSLog(@&quot;dict: %@&quot;, dict);
    // &quot;&lt;CustomDictKey: 0x600002e8c4c0&gt;&quot; = testObjectA;
    // &quot;&lt;CustomDictKey: 0x600002e8c4f0&gt;&quot; = testObjectB;
    
    NSLog(@&quot;objA: %@&quot;, [dict objectForKey:keyA]); // objA: testObjectA
    NSLog(@&quot;objB: %@&quot;, [dict objectForKey:keyB]); // objB: testObjectB
</code></pre>
<h2 id="id-和-instancetype-有什么区别"><a class="header" href="#id-和-instancetype-有什么区别">id 和 instancetype 有什么区别？</a></h2>
<p>id 和 instancetype 的区别主要为关联返回类型和非关联返回类型的区别。</p>
<h3 id="关联返回类型"><a class="header" href="#关联返回类型">关联返回类型</a></h3>
<p>即方法的返回结果为所在类的类型的对象。在ObjC中，根据Cocoa的命名规则，满足下述规则的方法都为关联返回类型：</p>
<ol>
<li>类方法中，以<code>alloc</code>或<code>new</code>开头</li>
<li>实例方法中，以<code>autorelease</code>，<code>init</code>，<code>retain</code>或<code>self</code>开头</li>
</ol>
<p>比如:</p>
<pre><code class="language-objc">NSArray *array = [[NSArray alloc] init];
</code></pre>
<p>[NSArray alloc]与[[NSArray alloc]init]返回的都为NSArray的对象</p>
<h3 id="非关联返回类型"><a class="header" href="#非关联返回类型">非关联返回类型</a></h3>
<p>即方法的返回结果不为所在类的类型的对象。</p>
<p>比如:</p>
<pre><code class="language-objc">@interface CustomObject : NSObject

+ (id)factoryMethodB;

@end
</code></pre>
<p><code>+ factoryMethodB</code> 方法的返回值为id，可以为任意类型，所以不一定是<code>CustomObject*</code>类型。</p>
<h3 id="instancetype-的作用"><a class="header" href="#instancetype-的作用">instancetype 的作用</a></h3>
<p>使用 instancetype 作为返回值，返回的返回结果为所在类的类型的对象，即关联返回类型。</p>
<pre><code class="language-objc">@interface CustomObject : NSObject

+ (instancetype)factoryMethodB;

@end
</code></pre>
<pre><code class="language-objc">id obj =  [CustomObject factoryMethodB]; 
</code></pre>
<p>obj 为 <code>CustomObject*</code> 类型。</p>
<h3 id="instancetype-vs-id"><a class="header" href="#instancetype-vs-id">instancetype vs id</a></h3>
<p>一个例子：</p>
<pre><code class="language-objc">@interface CustomObject : NSObject

+ (instancetype)factoryMethodA;
+ (id)factoryMethodB;

@end

@implementation CustomObject

+ (instancetype)factoryMethodA {
    return [[[self class] alloc] init];
}

+ (id)factoryMethodB {
    return [[[self class] alloc] init];
}

@end
</code></pre>
<pre><code class="language-objc">// 因为 instancetype 期望的类型是 CustomObject*，由于 CustomObject 没有 -count 方法，所以编译器会报错
NSUInteger x = [[CustomObject factoryMethodA] count];
    
// 因为 id 类型可以为任意的类，由于有可能 -count 方法存在于其它类中，所以编译器不会报错
NSUInteger y = [[CustomObject factoryMethodB] count];
</code></pre>
<h3 id="总结"><a class="header" href="#总结">总结</a></h3>
<ul>
<li>相同点：都可以作为方法的返回类型。</li>
<li>不同点：
<ul>
<li><code>instancetype</code>可以返回和方法所在类相同类型的对象，<code>id</code>只能返回未知类型的对象；</li>
<li><code>instancetype</code>只能作为返回值，不能像<code>id</code>那样作为参数。</li>
</ul>
</li>
</ul>
<h2 id="typeof-和-__typeof__typeof__-的区别"><a class="header" href="#typeof-和-__typeof__typeof__-的区别"><code>typeof</code> 和 <code>__typeof</code>，<code>__typeof__</code> 的区别?</a></h2>
<p><code>__typeof__()</code>和<code>__typeof()</code>和<code>typeof()</code>都是C的扩展,且意思是相同的，标准C不包括这样的运算符标准。</p>
<p>在标准C 中写扩展是 以 <code>__</code> 开头,所以在标准C中要写成 <code>__typeof() </code>或 <code>__typeof__()</code>。在GNU C 中支持直接写 <code>typeof() </code>或者 <code>__typeof()</code> 或者 <code>__typeof__()</code>。iOS 使用Clang编译器,默认用的C语言版本是GNU99。</p>
<h2 id="import-和-include-class-的区别"><a class="header" href="#import-和-include-class-的区别"><code>import</code> 和 <code>include</code> <code>@class</code> 的区别？</a></h2>
<p>在 ObjC 中，可以使用 <code>#include</code> 、<code>#import</code>、<code>@class</code> 三种方式引用文件。</p>
<h3 id="include"><a class="header" href="#include"><code>#include</code></a></h3>
<ul>
<li>
<p>在C语言中，使用<code>#include</code>来引用头文件。使用<code>#include “xx.h”</code>来引入自定义的头文件，使用<code>#include&lt;xx.h&gt;</code>来引入库中的头文件。</p>
</li>
<li>
<p><code>#include</code> 一般<strong>不能防止重复引用头文件</strong>，如果要防止，操作比较复杂，具体为如下方式引用：</p>
<pre><code class="language-c">#ifndef  ViewController_h

#define ViewController_h

#endif
</code></pre>
</li>
</ul>
<h3 id="import"><a class="header" href="#import"><code>#import</code></a></h3>
<ul>
<li><code>#import</code>是<code>#include</code>的升级版，可以防止重复引入头文件这种现象的发生。</li>
<li><code>#import</code>在引入头的时候，是<strong>完全将头文件拷贝到现在的文件中</strong>，所以也有效率上的问题。</li>
<li>使用<code>#import</code>需要避免出现头文件递归引入的现象。（如：A引入B，B引入A，那么A、B的头文件会互相不停的拷贝）</li>
</ul>
<h3 id="class"><a class="header" href="#class"><code>@class</code></a></h3>
<ul>
<li><code>@class</code>用来告诉编译器有这样一个类，在写代码时不会报错。 @class只是使导入的类名在引用时不受影响，不能创建该类的对象，因为创建对象时也需要访问其内部方法。</li>
<li>因为<code>#import</code>引入头文件有效率问题，所以当还没有调用类中方法，仅仅是定义类变量的时候，使用<code>@class</code>来提醒编译器，而在真正需要调用类方法的时候，再进行<code>#import</code>。</li>
<li>如果A是B的父类，那么这是在B.h中就必须要使用<code>#import</code>来引入A的头，因为需要知道A类中有哪些变量和方法，以免B类中重复定义。</li>
<li>能使用 <code>@class</code> 的地方尽量使用 <code>@class</code>，延后进行 <code>#import</code>。</li>
</ul>
<h2 id="define-和-extern-的区别"><a class="header" href="#define-和-extern-的区别">define 和 extern 的区别？</a></h2>
<ul>
<li>
<p>define是宏定义，即简单的替换，不会对数据类型做校验 <code>#define MY_HOST @&quot;www.xxxx.com&quot;</code></p>
</li>
<li>
<p>extern 和常量结合使用，会分配内存空间，编译器会做类型检查 </p>
<pre><code class="language-objc">// Prefs.h
extern NSString * const PREFS_MY_CONSTANT;

// Prefs.m
NSString * const PREFS_MY_CONSTANT = @&quot;prefs_my_constant&quot;;
</code></pre>
</li>
</ul>
<h2 id="nsinteger-的范围32位系统和64位系统的差别"><a class="header" href="#nsinteger-的范围32位系统和64位系统的差别">NSInteger 的范围？32位系统和64位系统的差别？</a></h2>
<p>32位和64位NSInteger定义:</p>
<pre><code class="language-objc">#if __LP64__ || 0 || NS_BUILD_32_LIKE_64
typedef long NSInteger;
typedef unsigned long NSUInteger;
#else
typedef int NSInteger;
typedef unsigned int NSUInteger;
#endif
</code></pre>
<p>可以看到 NSInteger 在 32 位系统上是 int 的别称，在 64 位系统上是 long 的别称。</p>
<ul>
<li>int占4个字节(byte) 32位(bit), 2^32 = 4294967296:</li>
<li>long 占4个字节 32位 范围： -2147483648 ~ 2147483647</li>
<li>long long 占8个字节 64位 范围： -9223372036854775808 ~ 9223372036854775807</li>
</ul>
<h3 id="32位系统"><a class="header" href="#32位系统">32位系统</a></h3>
<p>NSInteger 是 int 的别称，NSUInteger 是 unsigned int 的别称：</p>
<ul>
<li>
<p>NSInteger 有正负，则范围为： -2^16 + 1 ~ 2^16</p>
</li>
<li>
<p>NSUInteger 不带符号，占4个字节，32位 范围： 0 ~ 2^32</p>
</li>
</ul>
<h3 id="64位系统"><a class="header" href="#64位系统">64位系统</a></h3>
<p>NSInteger 是 long 的别称，NSUInteger 是 unsigned long 的别称：</p>
<ul>
<li>
<p>NSInteger 有正负： -2^32+1 ~ 2^32</p>
</li>
<li>
<p>NSUInteger 不带符号： 0 ~2^64-1</p>
</li>
</ul>
<h2 id="imagenamed-和-imagewithcontentsoffile-哪一个性能更好为什么"><a class="header" href="#imagenamed-和-imagewithcontentsoffile-哪一个性能更好为什么"><code>imageNamed:</code> 和 <code>imageWithContentsOfFile:</code> 哪一个性能更好？为什么？</a></h2>
<ul>
<li>
<p><code>imageNamed:</code>：在生成image对象的同时，会将数据根据name缓存到系统内存中，以提高该方法获取相同图片对象的性能。即使生成的对象被<code>autoreleasePool</code>释放了，这份缓存也不会释放。在应用中需要使用大量相同的图片时非常有用，可以提供性能和内存利用率。</p>
</li>
<li>
<p><code>imageWithContentsOfFile:</code>：该方法不会进行缓存，创建的对象被<code>autoreleasePool</code>释放后，下次使用相同名称的图片需要重新创建。</p>
</li>
</ul>
<p>对比总结：大量使用<code>imageNamed:</code>方式会在不需要缓存的地方增加额外开销CPU的时间。当需要加载一张比较大的图片并且仅作一次性使用时，没必要去缓存这个图片，使用<code>imageWithContentsOfFile:</code>方法会更经济。</p>
<h2 id="nsproxy-和-nsobject-的区别"><a class="header" href="#nsproxy-和-nsobject-的区别"><code>NSProxy</code> 和 <code>NSObject</code> 的区别？</a></h2>
<p>NSProxy 是一个类似于 NSObject 的基类，是一等公民。NSProxy是一个抽象的超类，为充当其他对象或尚不存在的对象的代理对象定义API。通常，发送给代理的消息被转发到实际对象，或者导致代理加载（或转换为）真实对象。NSProxy的子类可用于实现透明的分布式消息传递（例如，NSDistantObject）或用于延迟实例化创建代价高昂的对象。</p>
<p>NSProxy 的常见用法：</p>
<ul>
<li>作为中间对象解决 NSTimer 的循环引用</li>
<li>模拟多继承</li>
</ul>
<p><code>NSProxy</code> 和 <code>NSObject</code> 的区别：</p>
<ul>
<li><code>NSProxy</code> 进行消息转发的效率更高：
<ul>
<li><code>NSObject</code> 的消息转发流程需要经历三个步骤：从自身和 superclass 的方法列表中查找方法，找不到再进行动态方法解析以及备用接收者，最后才是完整的消息转发。</li>
<li><code>NSProxy</code> 是先从自身方法中查找方法，找不到立马调用<code>-methodSignatureForSelector:</code> 和 <code>-forwardInvocation:</code> 进行消息转发。所以在 解决timer的循环引用时基本使用 <code>NSProxy</code> 作为中间件。</li>
</ul>
</li>
<li><code>NSProxy</code> 更轻量级</li>
</ul>
<h1 id="参考"><a class="header" href="#参考">参考</a></h1>
<ul>
<li><a href="https://developer.apple.com/library/archive/releasenotes/ObjectiveC/ModernizationObjC/AdoptingModernObjective-C/AdoptingModernObjective-C.html">Adopting Modern Objective-C</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="foundation-中的集合"><a class="header" href="#foundation-中的集合">Foundation 中的集合</a></h1>
<h1 id="nscache-和-nsmutabledictionary-的区别和对比"><a class="header" href="#nscache-和-nsmutabledictionary-的区别和对比"><code>NSCache</code> 和 <code>NSMutableDictionary</code> 的区别和对比？</a></h1>
<h2 id="对比"><a class="header" href="#对比">对比</a></h2>
<ul>
<li>
<p>相同：<code>NSCache</code> 是一种可变集合，用于临时存储在资源不足时容易被回收的 key-value 键值对。NSCache 具有字典的所有功能，并且提供的API和<code>NSMutableDictionary</code>都是相似的。</p>
</li>
<li>
<p>区别：<code>NSCache</code>还具有如下特性：</p>
<ul>
<li>内存不足时，<code>NSCache</code> 会自动清理缓存，并且提供了是否需要清理的开关和缓存清理时的回调；</li>
<li><code>NSCache</code> 是线程安全的；</li>
<li>区别于 <code>NSMutableDictionary</code> ，<code>NSCache</code> 不需要对 key 进行拷贝。</li>
</ul>
</li>
</ul>
<h2 id="nscache-的实现"><a class="header" href="#nscache-的实现">NSCache 的实现</a></h2>
<ul>
<li>
<p>缓存淘汰：GNUSetup 使用 LRU/LFU 机制进行淘汰，使用频率较少的元素先淘汰；Swfit Foundation 依据对象的 cost 进行淘汰，cost 较少的先淘汰。GNUSetup 中使用 maptable 存储缓存对象，使用 array 维护 LRU/LFU 排序后的对象，用于缓存淘汰；Swfit Foundation 中使用 dictionary 存储缓存对象，维护一个排序的双向链表，用于缓存淘汰。</p>
</li>
<li>
<p>线程安全：GNUSetup 中没有保证 cache 线程安全的代码；Swfit Foundation 中使用 NSLock 保证缓存读写的线程安全</p>
</li>
</ul>
<h2 id="nscache-的应用"><a class="header" href="#nscache-的应用">NSCache 的应用</a></h2>
<h3 id="1-sdwebimage-的应用中"><a class="header" href="#1-sdwebimage-的应用中">1. SDWebImage 的应用中</a></h3>
<p>在 SDWebImage 中，通过将图片放到 NSCache 中，利用 NSCache 自动释放内存的特点在内存不足时自动淘汰不常用的图片。在读取图片时，先检查内存里是否有，有则直接返回；没有再从磁盘里读取。以此减少磁盘操作，保证空间合理释放。</p>
<pre><code class="language-objc">- (nullable UIImage *)imageFromCacheForKey:(nullable NSString *)key options:(SDImageCacheOptions)options context:(nullable SDWebImageContext *)context {
    // 先检查内存里是否有，有则直接返回
    UIImage *image = [self imageFromMemoryCacheForKey:key];
    if (image) {
        return image;
    }
    
    // 再从磁盘里读取
    image = [self imageFromDiskCacheForKey:key options:options context:context];
    return image;
}

- (nullable UIImage *)imageFromMemoryCacheForKey:(nullable NSString *)key {
    return [self.memoryCache objectForKey:key];
}
</code></pre>
<p>代码中 self.memoryCache 为 SDMemoryCache， SDMemoryCache 内部就是将 NSCache 扩展为了 SDMemoryCache 协议：</p>
<pre><code class="language-objc">@protocol SDMemoryCache &lt;NSObject&gt;
@required
- (nonnull instancetype)initWithConfig:(nonnull SDImageCacheConfig *)config;
- (nullable id)objectForKey:(nonnull id)key;
- (void)setObject:(nullable id)object forKey:(nonnull id)key;
- (void)setObject:(nullable id)object forKey:(nonnull id)key cost:(NSUInteger)cost;
- (void)removeObjectForKey:(nonnull id)key;
- (void)removeAllObjects;
@end

@interface SDMemoryCache &lt;KeyType, ObjectType&gt; : NSCache &lt;KeyType, ObjectType&gt; &lt;SDMemoryCache&gt;
@property (nonatomic, strong, nonnull, readonly) SDImageCacheConfig *config;
@end
</code></pre>
<h2 id="nsmutableset-和-nsmutablearray-的区别"><a class="header" href="#nsmutableset-和-nsmutablearray-的区别"><code>NSMutableSet</code> 和 <code>NSMutableArray</code> 的区别？</a></h2>
<ul>
<li>
<p>是否有序：<code>NSMutableSet</code> 中的元素是<strong>无序的</strong>，<code>NSMutableArray</code> 则是有序的</p>
</li>
<li>
<p>元素是否重复：<code>NSMutableSet</code> 中<strong>不会存在重复元素</strong>，<code>NSMutableArray</code> 则可以存在重复元素</p>
</li>
<li>
<p>查找的复杂度：<strong>搜索一个元素时 <code>NSMutableSet</code> 比 <code>NSMutableArray</code> 效率高</strong>，主要是它用到了 hash 算法。
比如你要存储元素A，一个 hash 算法直接就能直接找到A应该存储的位置；同样，当你要访问A时，一个hash过程就能找到A存储的位置。而对于NSArray，若想知道A到底在不在数组中，则需要遍历整个数组，显然效率较低了；</p>
<pre><code class="language-objc">[set containsObject:@&quot;C++&quot;];

[array containsObject:@&quot;C++&quot;];
</code></pre>
</li>
<li>
<p>使用场景：</p>
<ul>
<li><code>NSSet</code> / <code>NSMutableSet</code>：不需要保证顺序的集合、去重、经常查询元素</li>
<li><code>NSArray</code> / <code>NSMutableArray</code>: 需要保证顺序、有重复元素</li>
</ul>
</li>
<li>
<p>实现原理：</p>
<ul>
<li><code>NSSet</code> / <code>NSMutableSet</code>：</li>
</ul>
</li>
</ul>
<h2 id="nsmaptable--nshashtable--nspointerarray"><a class="header" href="#nsmaptable--nshashtable--nspointerarray"><code>NSMapTable</code> 、 <code>NSHashTable</code> 、 <code>NSPointerArray</code></a></h2>
<p>iOS 中，常见的强持有元素的集合为：<code>NSArray</code> 、<code>NSDictionary</code> 、<code>NSSet</code>，同时也提供了弱引用元素的集合：<code>NSMapTable</code>、<code>NSHashTable</code> 、 <code>NSPointerArray</code>等，当不需要集合强持有里面的元素是，可以使用。</p>
<p>使用场景举例：</p>
<ol>
<li>比如有一个数组，数组里面存放了 100 个 view，每隔 10 分钟就会遍历这个数组，然后将这些 view 的 backgroundColor 改变。但是这个数组是输出给其它业务方使用的，也无妨拿到其中的某个 view，在进行一些操作后，就会 <code>removeFromSuperView</code></li>
</ol>
<p>问题：</p>
<ol>
<li>view <code>removeFromSuperView</code> 后，数组中的 view 会释放吗？</li>
</ol>
<p>答案：不会，因为数组对里面的对象是强引用的，数组还持有这个 view，所以不会释放。</p>
<ol start="2">
<li>因为 view 不会释放，所以每次遍历的时候虽然有些 view 已经需要了，但是还存在，影响着性能，怎么解决？</li>
</ol>
<p>答案：目的就是做到当 view <code>removeFromSuperView</code> 后就释放，不释放的根本原因就是因为数组强引用着 view，那么可以从这里入手，让数组不强持有这个view。这里可以使用 NSPointerArray`。</p>
<h1 id="参考-1"><a class="header" href="#参考-1">参考</a></h1>
<ul>
<li><a href="https://juejin.cn/post/6942823617080066085#heading-9">NSCache 源码阅读</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cc"><a class="header" href="#cc">C/C++</a></h1>
<h2 id="指针运算"><a class="header" href="#指针运算">指针运算</a></h2>
<h3 id="下列代码中-p-的结果是多少"><a class="header" href="#下列代码中-p-的结果是多少">下列代码中 p 的结果是多少？</a></h3>
<pre><code class="language-c">int* p = 200;
p++;
printf(&quot;p:%d\n&quot;, p); 
</code></pre>
<p>答案：204</p>
<p>原因：<strong>当一个加法运算，加号左边的操作数是一个指针，而右边的操作数是一个整数时，这个整数值先乘以指针类型的大小（sizeof(int)），然后再加到左边的数上</strong>。如果是 double，则为 8，char 为 1。</p>
<p>扩展：当同一个数组的两个成员的指针相减时，其差值为：地址值的差，再除以一个数组成员的size。这个结果代表了两个指针对应元素的下标之差。</p>
<h3 id="char-p--123-和-char-p--123-的区别"><a class="header" href="#char-p--123-和-char-p--123-的区别"><code>char* p = &quot;123&quot;;</code> 和 <code>char p[] = &quot;123&quot;;</code> 的区别？</a></h3>
<p>答案：</p>
<ul>
<li><code>char* p</code>是一个 <code>&quot;123&quot;</code>的指针，存储的是<code>1</code> <code>2</code> <code>3</code>字符数组，<code>printf(&quot;p:%s\n&quot;, p);</code> 可输出其内容；</li>
<li><code>char p[]</code> 是一个 char 数组，存放了<code>1</code> <code>2</code> <code>3</code>字符，<code>printf(&quot;p:%s\n&quot;, p);</code>可输出其内容。</li>
</ul>
<h3 id="sizeof-的作用-32-位-和-64-位-系统下-sizeofnsinteger-为多少"><a class="header" href="#sizeof-的作用-32-位-和-64-位-系统下-sizeofnsinteger-为多少"><code>sizeof</code> 的作用？ 32 位 和 64 位 系统下 <code>sizeof(NSInteger)</code> 为多少？</a></h3>
<p><code>sizeof</code> 不是一个函数，而是一个运算符。根据数据的类型计算其占用的字节数，<code>sizeof</code> 传入的其实是一个变量，在编译的时候就确定了：</p>
<pre><code class="language-objc">int age = 10000;
sizeof(age);

// 等价于
sizeof(int);
</code></pre>
<p>NSInteger 在 32 和 64 位系统上表现不同：</p>
<ul>
<li>32位系统，NSInteger 是 int 的别称</li>
<li>64位系统，NSInteger 是 long 的别称</li>
</ul>
<pre><code class="language-objc">#if __LP64__ || 0 || NS_BUILD_32_LIKE_64
typedef long NSInteger;
typedef unsigned long NSUInteger;
#else
typedef int NSInteger;
typedef unsigned int NSUInteger;
#endif
</code></pre>
<ul>
<li>32 位系统中，NSInteger 占 4 个字节，所以 <code>sizeof(NSInteger)</code> = 4</li>
<li>64 位系统中，NSInteger 占 8 个字节，所以 <code>sizeof(NSInteger)</code> = 8</li>
</ul>
<p>同样 CGFloat 的实现类似：</p>
<ul>
<li>32位系统，CGFloat 是 float 的别称， 占用 4 字节</li>
<li>64位系统，CGFloat 是 double 的别称， 占用 8 字节</li>
</ul>
<pre><code class="language-objc">typedef CGFLOAT_TYPE CGFloat;
#if defined(__LP64__) &amp;&amp; __LP64__
# define CGFLOAT_TYPE double
#else
# define CGFLOAT_TYPE float
#endif
</code></pre>
<p>各种类型的数据占用的字节数量：</p>
<ul>
<li>BOOL：1</li>
<li>int：4 </li>
<li>long: 8</li>
<li>float: 4
<pre><code class="language-objc">NSLog(@&quot;%ld&quot;, sizeof(float)); // 8
</code></pre>
</li>
<li>double: 8
<pre><code class="language-objc">NSLog(@&quot;%ld&quot;, sizeof(double)); // 8
</code></pre>
</li>
<li>指针: 8 
<pre><code class="language-objc">char *p = 200;
NSLog(@&quot;%ld&quot;, sizeof(p)); // 8
</code></pre>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="uikit"><a class="header" href="#uikit">UIKit</a></h1>
<ol>
<li>
<p><code>UIView</code> 和 <code>CALayer</code> 是什么关系？有何区别？</p>
</li>
<li>
<p><code>frame</code> 和 <code>bounds</code> 的区别? </p>
</li>
<li>
<p><code>loadView</code> 方法的作用？</p>
</li>
<li>
<p><code>UIButton</code> 的父类是什么？<code>UILabel</code> 的父类又是什么？</p>
</li>
<li>
<p><code>UITableView</code> 的继承关系？一直到 <code>NSObject</code> </p>
</li>
<li>
<p><code>UIViewController</code> 的生命周期？</p>
</li>
<li>
<p><code>UIView</code> 的生命周期？</p>
</li>
<li>
<p><code>UIViewController</code>一旦收到内存警告会如何处理？</p>
</li>
<li>
<p><code>setNeedsDisplay</code> 和 <code>layoutIfNeeded</code> 两者是什么关系？</p>
</li>
</ol>
<h1 id="动画和渲染"><a class="header" href="#动画和渲染">动画和渲染</a></h1>
<ol>
<li>
<p>有哪些绘制圆角的方案？不同方式的GPU、CPU占用分别怎么样的？</p>
</li>
<li>
<p>讲讲 CAlayer 的渲染树？</p>
</li>
<li>
<p>iOS中有哪些动画方式？</p>
</li>
<li>
<p>UIView 的 Animation 和 Core Animation 有什么区别？</p>
</li>
<li>
<p>隐式动画是什么？如何关闭？</p>
</li>
<li>
<p>UIView 的 animate.. block方式执行动画，是隐式动画吗？</p>
</li>
<li>
<p>UIView 在执行动画的过程中如何响应事件？</p>
</li>
</ol>
<h1 id="responder-chain"><a class="header" href="#responder-chain">Responder Chain</a></h1>
<ol>
<li>
<p>说一说事件传递和响应者链。 </p>
</li>
<li>
<p>UIView 哪些情况下不能接收触摸事件？</p>
</li>
<li>
<p>扩大按钮响应区域的方法有哪些？</p>
</li>
<li>
<p>手势冲突如何处理？ </p>
</li>
</ol>
<h1 id="app"><a class="header" href="#app">APP</a></h1>
<ol>
<li>APP 的生命周期？</li>
</ol>
<h1 id="算法"><a class="header" href="#算法">算法</a></h1>
<ol>
<li>
<p>找出两个 <code>UIView</code> 的最近的公共父 <code>View</code>，如果不存在，则输出 nil。</p>
</li>
<li>
<p>实现 <code>convertRect: toView:</code> 方法？</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="uikit-1"><a class="header" href="#uikit-1">UIKit</a></h1>
<h2 id="uiview-和-calayer-是什么关系有何区别"><a class="header" href="#uiview-和-calayer-是什么关系有何区别">UIView 和 CALayer 是什么关系？有何区别？</a></h2>
<ul>
<li>
<p><code>UIView</code> 是对 <code>CALayer</code> 的封装。<code>UIView</code> 和 <code>CALayer</code> 的相似行为都依赖于 <code>CALayer</code> 的实现。</p>
</li>
<li>
<p><code>CALayer</code> 继承自 <code>NSObject</code> ，<strong>不能够响应事件</strong>。</p>
</li>
<li>
<p><code>UIView</code> 继承自 <code>UIReponder</code>，负责响应事件。</p>
</li>
<li>
<p><code>UIView</code> 依赖于 <code>CALayer</code> 得以显示。无论是修改了 layer 的可视内容或是几何信息，view 都会跟着变化，反之也是如此，比如下列代码: </p>
<pre><code class="language-objc">UIView *view = [[UIView alloc] initWithFrame:CGRectMake(100, 100, 100, 100)];
view.backgroundColor = [UIColor redColor];

// 1. 修改 layer 的颜色
view.layer.backgroundColor = [[UIColor blueColor] CGColor]; // view 将显示呈蓝色
NSLog(@&quot;view color: %@&quot;, view.backgroundColor); // view color:  0 0 1 1
NSLog(@&quot;layer color: %@&quot;, view.layer.backgroundColor); // layer color: 0 0 1 1

// 2. 修改 layer 的位置
view.layer.frame = CGRectMake(100, 200, 100, 100);
NSLog(@&quot;view y: %f&quot;, view.frame.origin.y); // view y: 200.000000
NSLog(@&quot;layer y: %f&quot;, view.layer.frame.origin.y); // layer y: 200.000000

[self.view addSubview:view];
</code></pre>
</li>
</ul>
<h2 id="为什么需求分离uiview和calayer"><a class="header" href="#为什么需求分离uiview和calayer">为什么需求分离UIView和CALayer</a></h2>
<p>主要是基于两点考虑：</p>
<ul>
<li>职责不同：<code>UIVIew</code> 的主要职责是负责接收并响应事件；而 <code>CALayer</code> 的主要职责是负责显示 UI。</li>
<li>需要复用：在 macOS 和 App 系统上，<code>NSView</code> 和 <code>UIView</code> 虽然行为相似，在实现上却有着显著的区别，却又都依赖于 <code>CALayer</code> 。在这种情况下，只能封装一个 <code>CALayer</code> 出来。</li>
</ul>
<h2 id="frame-和-bounds-的区别"><a class="header" href="#frame-和-bounds-的区别">frame 和 bounds 的区别?</a></h2>
<ul>
<li>
<p>frame: 表示<code>view</code>在父<code>view</code>坐标系统中的位置和大小，参照点是父视图的坐标系统。</p>
</li>
<li>
<p>bounds: 表示<code>view</code>在本地坐标系统中的位置和大小，参照点是本地坐标系统。</p>
</li>
</ul>
<h2 id="loadview-方法的作用"><a class="header" href="#loadview-方法的作用">loadView 方法的作用？</a></h2>
<ul>
<li>作用：用来创建 <code>UIViewController</code> 的<code>view</code>。每个<code>UIViewController</code>都有一个<code>loadView</code>方法。</li>
<li>调用时机：每次访问<code>UIViewController</code>的<code>view</code>(比如<code>controller.view</code>、<code>self.view</code>)而且<code>view</code>为<code>nil</code>时，<code>loadView</code>方法就会被调用。</li>
<li>默认实现：<code>loadView</code> 的默认实现在 <code>[super loadView]</code> 中：
<ol>
<li>查找与<code>UIViewController</code>相关联的xib文件，通过加载xib文件来创建UIViewController的<code>view</code>。如果在初始化<code>UIViewController</code>的时候指定了xib文件名，那么就会根据传入的xib文件名去加载对于的xib文件，如果没有明显的传入xib文件名，就会加载跟<code>UIViewController</code>同名的xib文件。</li>
<li>如果没有找到相关联的xib文件，就会创建一个空白的<code>UIView</code>,然后赋值给<code>UIViewController</code>的<code>view</code>属性。</li>
</ol>
</li>
<li>正确使用：用来自定义<code>UIViewController</code> 的<code>view</code>，可以在上面进行一些自定义设置。重写 <code>loadView</code> 方法，并且不需要调用 <code>[super loadView]</code>。</li>
</ul>
<pre><code class="language-objc">- (void)loadView {
    UIView *customView = [[UIView alloc] initWithFrame:[UIScreen mainScreen].bounds];
    self.view = customView;
}
</code></pre>
<h2 id="uibutton-的父类是什么uilabel-的父类又是什么"><a class="header" href="#uibutton-的父类是什么uilabel-的父类又是什么">UIButton 的父类是什么？UILabel 的父类又是什么？</a></h2>
<ul>
<li><code>UIButton</code> -&gt; <code>UIControl</code> -&gt; <code>UIView</code> -&gt; <code>UIResponder</code></li>
<li><code>UILabel</code> -&gt; <code>UIView</code> -&gt; <code>UIResponder</code></li>
</ul>
<p><code>UIControl</code> 实际上是针对点击触摸进行进一步的封装，可以方便得为点击等添加对应的<code>action</code>。继承自<code>UIControl</code>的控件包括
<code>UIButton</code>，<code>UIDatePicker</code>，<code>UIPageControl</code>，<code>UISegmentedControl</code>，<code>UITextField</code>，<code>UISwitch</code>，<code>UISlider</code>等，其它控件则直接继承自 <code>UIView</code>。</p>
<h2 id="uitableview-的继承关系"><a class="header" href="#uitableview-的继承关系"><code>UITableView</code> 的继承关系？</a></h2>
<p><code>UITableView</code> -&gt; <code>UIScrollView</code> -&gt; <code>UIView</code> -&gt; <code>UIResponder</code> -&gt; <code>NSObject</code></p>
<h2 id="uiviewcontroller-的生命周期"><a class="header" href="#uiviewcontroller-的生命周期">UIViewController 的生命周期</a></h2>
<pre><code class="language-objc">-[ViewController init]
-[ViewController loadView]
-[ViewController viewDidLoad]
-[ViewController viewWillAppear:]
-[ViewController viewWillLayoutSubviews]
-[ViewController viewDidLayoutSubviews]
-[ViewController viewDidAppear:]
-[ViewController viewWillDisappear:]
-[ViewController viewDidDisappear:]
-[ViewController dealloc]
</code></pre>
<p><img src="https://docs-assets.developer.apple.com/published/f06f30fa63/UIViewController_Class_Reference_2x_ddcaa00c-87d8-4c85-961e-ccfb9fa4aac2.png" alt="" /></p>
<h2 id="uiview-的生命周期"><a class="header" href="#uiview-的生命周期">UIView 的生命周期</a></h2>
<p>view层级操作</p>
<pre><code class="language-objc">- (void)addSubview:(UIView *)view;
- (void)didAddSubview:(UIView *)subview;
- (void)willRemoveSubview:(UIView *)subview;
- (void)willMoveToSuperview:(nullable UIView *)newSuperview;
- (void)didMoveToSuperview;
- (void)willMoveToWindow:(nullable UIWindow *)newWindow;
- (void)didMoveToWindow;
- (void)removeFromSuperview;
</code></pre>
<p>view布局操作</p>
<pre><code class="language-objc">- (void)layoutSubviews;
- (void)setNeedsLayout;
- (void)layoutIfNeeded;
</code></pre>
<p>UIView生命周期</p>
<p>init-&gt;willMoveToSuperview-&gt;didMoveSuperview-&gt;(如果有子view)-&gt;subview的willMoveToSuperview-&gt;subview的didMoveSuperview-&gt;didAddSubview-&gt;addSubview-viewWillAppear-&gt;loadViewIfNeeded-&gt;willMoveToWindow-&gt;(如果有子view)-&gt;subview的willMoveToWindow-&gt;subview的didMoveToWindow-&gt;didMoveToWindow-&gt;viewWillLayoutSubviews-&gt;viewDidLayoutSubviews-&gt;layoutSubviews-&gt;drawRect-&gt;viewDidAppear </p>
<h2 id="uiviewcontroller一旦收到内存警告会如何处理"><a class="header" href="#uiviewcontroller一旦收到内存警告会如何处理">UIViewController一旦收到内存警告会如何处理？</a></h2>
<p>当系统内存告急时， <code>ViewController</code> 会接收 <code>didReceiveMemoryWarning</code> :首先会判断当前的 <code>ViewController</code> 是否还显示在 <code>window</code> 上，如果不在就会移除当前的 <code>ViewController</code>，销毁<code>ViewController</code> 上面的子控件，并执行 <code>ViewDidUnload</code> 方法。</p>
<h2 id="setneedsdisplay-和-layoutifneeded-两者是什么关系"><a class="header" href="#setneedsdisplay-和-layoutifneeded-两者是什么关系">setNeedsDisplay 和 layoutIfNeeded 两者是什么关系？</a></h2>
<ul>
<li>
<p><code>setNeedsDisplay</code> 是给当前的视图做了标记。</p>
</li>
<li>
<p><code>layoutIfNeeded</code> 查找是否有标记，如果有标记及立刻刷新。</p>
</li>
</ul>
<p>只有这二者合起来使用，才会起到立刻刷新的效果。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="动画和渲染-1"><a class="header" href="#动画和渲染-1">动画和渲染</a></h1>
<h2 id="有哪些绘制圆角的方案不同方式的gpucpu占用分别怎么样的"><a class="header" href="#有哪些绘制圆角的方案不同方式的gpucpu占用分别怎么样的">有哪些绘制圆角的方案？不同方式的GPU、CPU占用分别怎么样的？</a></h2>
<p>主要有以下 4 种：</p>
<ol>
<li>设置 layer 的 cornerRadius</li>
<li>用贝塞尔曲线 <code>UIBezierPath</code> 作 mask 圆角</li>
<li>使用 CoreGraphics 重新绘制圆角</li>
<li>混合图层，用一张镂空的透明图片作遮罩</li>
</ol>
<h3 id="1-设置-layer-的-cornerradius"><a class="header" href="#1-设置-layer-的-cornerradius">1. 设置 layer 的 cornerRadius</a></h3>
<pre><code class="language-objc">view.layer.masksToBounds = YES;
view.layer.cornerRadius = 10.f;
</code></pre>
<h3 id="2-用贝塞尔曲线-uibezierpath-作-mask-圆角"><a class="header" href="#2-用贝塞尔曲线-uibezierpath-作-mask-圆角">2. 用贝塞尔曲线 <code>UIBezierPath</code> 作 mask 圆角</a></h3>
<p>CAShapeLayer + UIBezierPath:</p>
<pre><code class="language-objc">CAShapeLayer *layer = [CAShapeLayer layer];
UIBezierPath *aPath = [UIBezierPath bezierPathWithOvalInRect:view.bounds];
layer.path = aPath.CGPath;
view.layer.mask = layer;
</code></pre>
<h3 id="3-使用-coregraphics-重新绘制圆角"><a class="header" href="#3-使用-coregraphics-重新绘制圆角">3. 使用 CoreGraphics 重新绘制圆角</a></h3>
<p>使用 CoreGraphics 绘制圆角：</p>
<pre><code class="language-objc">@implementation UIImage (RoundedCorner)

- (UIImage *)drawCircleImage {
 CGFloat side = MIN(self.size.width, self.size.height);
 UIGraphicsBeginImageContextWithOptions(CGSizeMake(side, side), false, [UIScreen mainScreen].scale);
 CGContextAddPath(UIGraphicsGetCurrentContext(),
      [UIBezierPath bezierPathWithOvalInRect:CGRectMake(0, 0, side, side)].CGPath);
 CGContextClip(UIGraphicsGetCurrentContext());
 CGFloat marginX = -(self.size.width - side) / 2.f;
 CGFloat marginY = -(self.size.height - side) / 2.f;
 [self drawInRect:CGRectMake(marginX, marginY, self.size.width, self.size.height)];
 CGContextDrawPath(UIGraphicsGetCurrentContext(), kCGPathFillStroke);
 UIImage *output = UIGraphicsGetImageFromCurrentImageContext();
 UIGraphicsEndImageContext();
 return output;
}
@end
</code></pre>
<pre><code class="language-objc">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    UIImage *image = view.image;
    image = [image drawCircleImage];
    dispatch_async(dispatch_get_main_queue(), ^{
     view.image = image;
    });
});
</code></pre>
<h3 id="4-混合图层用一张镂空的透明图片作遮罩"><a class="header" href="#4-混合图层用一张镂空的透明图片作遮罩">4. 混合图层，用一张镂空的透明图片作遮罩</a></h3>
<pre><code class="language-objc">UIView *parent = [view superview];
UIImageView *cover = [[UIImageView alloc] initWithFrame:CGRectMake(0, 0, imgSize.width, imgSize.height)];
cover.image = [UIImage imageNamed:@&quot;cover&quot;];
[parent addSubview:cover];
cover.center = view.center;
</code></pre>
<h3 id="对比总结"><a class="header" href="#对比总结">对比总结</a></h3>
<ul>
<li>
<p>方法1 设置 layer 的 cornerRadius 的方式设置简单，苹果在 iOS9 上进行了优化，不再需要离屏渲染，性能差别不明显，简单圆角场景下推荐使用；</p>
</li>
<li>
<p>方法2 用贝塞尔曲线 <code>UIBezierPath</code> 作 mask 圆角，使用了矢量并与位图叠加，导致运算量上升，GPU运算量高；</p>
</li>
<li>
<p>方法3 使用 CoreGraphics 重新绘制圆角，基于单张位图运算，比方法2要好，适合位图尺寸很大，数量很多的情况下使用。但要注意内存警告，最好配合缓存机制使用，避免因内存溢出而崩溃；</p>
</li>
<li>
<p>方法4 混合图层，用一张镂空的透明图片作遮罩，基于透明位图，可用于异形遮罩，但需要根据图片大小做多张特殊位图，不是很方便。</p>
</li>
</ul>
<h2 id="ios中的动画方式"><a class="header" href="#ios中的动画方式">iOS中的动画方式</a></h2>
<ol>
<li>
<p>核心动画 Core Animation</p>
</li>
<li>
<p>UIView 动画</p>
</li>
</ol>
<h2 id="uiview-的-animation-和-core-animation-有什么区别"><a class="header" href="#uiview-的-animation-和-core-animation-有什么区别">UIView 的 Animation 和 Core Animation 有什么区别？</a></h2>
<ul>
<li>
<p>区别：</p>
<ul>
<li>核心动画只能添加到 CALayer(图层)，所以不能响应事件</li>
<li>核心动画一切都是假象，并不会改变真实的值;</li>
</ul>
</li>
<li>
<p>使用场景：</p>
<ul>
<li>如果需要与用户交互就使用 UIView 的动画;不需要与用户交互可以使用核心动画;</li>
</ul>
</li>
<li>
<p>Core Animation 使用较多的场景：</p>
<ul>
<li>在转场动画中,核心动画的类型比较多;</li>
<li>根据一个路径做动画,只能用核心动画（帧动画）;</li>
<li>动画组: 同时做多个动画;</li>
</ul>
</li>
</ul>
<h2 id="隐式动画"><a class="header" href="#隐式动画">隐式动画</a></h2>
<p>如果一个 <code>CALayer</code> 对象对应着 <code>UIView</code>，则称这个 Layer 是一个 Root Layer, 非 Root Layer 一般是通过 CALayer 或者其子类直接创建的。所有的非 Root Layer 在设置 Amimation Properties 的时候都存在隐式动画，默认的 duration 是0.25秒。</p>
<h3 id="如何关闭隐式动画"><a class="header" href="#如何关闭隐式动画">如何关闭隐式动画？</a></h3>
<p>可以通过动画事务 <code>CATransaction</code> 进行关闭。<br />
事务（transaction）实际上是Core Animation用来包含一系列属性动画集合的机制，用指定事务去改变可以做动画的图层属性，不会立刻发生变化，而是提交事务时用一个动画过渡到新值。任何 Layer 的可动画属性的设置都属于某个 CATransaction，事务的作用是为了保证多个属性的变化同时进行。事务可以嵌套，当事务嵌套时候，只有最外层的事务 commit 之后，整个动画才开始。</p>
<pre><code class="language-objc">[CATransaction begin];
[CATransaction setDisableActions:YES];

// 有隐式动画的逻辑

[CATransaction commit];
</code></pre>
<h2 id="uiview-在执行动画的过程中如何响应事件"><a class="header" href="#uiview-在执行动画的过程中如何响应事件">UIView 在执行动画的过程中如何响应事件？</a></h2>
<p>UIView 在执行动画的过程中，view 的 frame 只改变的一次，直接改到了最终的frame。比如下面代码，block 中的代码只会调用一次：</p>
<pre><code class="language-objc">[UIView animateWithDuration:2 animations:^{
    CGFloat Y = self.animationView.frame.origin.y + 50;
    self.animationView.frame = CGRectMake(self.animationView.frame.origin.x, Y, 100, 100);
} completion:^(BOOL finished) {
    
}];
</code></pre>
<p>并且，<strong>UIView 在执行动画的过程中不会响应事件</strong>。</p>
<p>想要响应事件可以通过UIView 的 touchesBegan: 方法中判断，有两种方法：</p>
<ol>
<li>通过 CALayer 的 presentationLayer 来访问对应的呈现树图层，presentationLayer 会动画不断变化，判断触发事件的点是否在 presentationLayer 上即可</li>
<li>直接调用 CALayer 的 <code>hitTest:</code> 方法</li>
</ol>
<p>比如下面的代码中，需要在 <code>animationView</code> 执行动画的过程中响应 <code>viweTapAction</code> 事件</p>
<pre><code class="language-objc">@interface ViewController ()

@property (nonatomic, strong) UIView *animationView; // 做动画的 view

@end

@implementation ViewController
- (void)viewDidLoad {
    [super viewDidLoad];
    
    self.animationView = [[UIView alloc] initWithFrame:CGRectMake(100, 100, 100, 100)];
    self.animationView.backgroundColor = [UIColor redColor];
    [self.view addSubview:self.animationView];
    self.animationView.userInteractionEnabled = NO;
}

// 执行动画
- (void)viewAnimationAction {
    // uiview animation 是隐式动画
    // animation 动画过程中不会响应事件
    [UIView animateWithDuration:2 animations:^{
        CGFloat Y = self.animationView.frame.origin.y + 50;
        self.animationView.frame = CGRectMake(self.animationView.frame.origin.x, Y, 100, 100);
    } completion:^(BOOL finished) {
        
    }];
}

// 点击事件，改变 view 的背景色
- (void)viweTapAction {
    self.animationView.backgroundColor = [UIColor colorWithRed:(arc4random()%255)/ 255.f green:(arc4random()%255)/ 255.f blue:(arc4random()%255)/ 255.f alpha:1];
}

@end
</code></pre>
<p>方法1:</p>
<pre><code class="language-objc">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event {
    // 获取到点击的位置
    UITouch *touch = touches.anyObject;
    CGPoint point = [touch locationInView:self.view];
    
    // 判断 redView.layer.presentationLayer 是否包含这个点
    if (CGRectContainsPoint(self.animationView.layer.presentationLayer.frame, point)) {
        [self viweTapAction]; // 响应事件
    }
}
</code></pre>
<p>方法2:</p>
<pre><code class="language-objc">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event {
    // 获取到点击的位置
    UITouch *touch = touches.anyObject;
    CGPoint point = [touch locationInView:self.view];
  
    if ([self.animationView.layer.presentationLayer hitTest:point] != nil) {
        [self viweTapAction]; // 响应事件
    }
}
</code></pre>
<h1 id="参考-2"><a class="header" href="#参考-2">参考</a></h1>
<ul>
<li><a href="https://www.jb51.net/article/154003.htm">iOS设置圆角的4种方法实例（附性能评测）</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ios-中的事件传递和响应者链"><a class="header" href="#ios-中的事件传递和响应者链">iOS 中的事件传递和响应者链</a></h1>
<p><img src="answer/02_uikit/./assets/img/ios_responder.png" alt="" /></p>
<p>事件的生命周期大概为三个阶段：</p>
<ol>
<li>事件的产生</li>
<li>事件的传递</li>
<li>事件的响应</li>
</ol>
<h2 id="事件的产生"><a class="header" href="#事件的产生">事件的产生</a></h2>
<p>苹果注册了一个 Source1 (基于 mach port 的) 用来接收系统事件，其回调函数为 __IOHIDEventSystemClientQueueCallback()。</p>
<p>当一个硬件事件(触摸/锁屏/摇晃等)发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收。这个过程的详细情况可以参考<a href="https://iphonedev.wiki/index.php/IOHIDFamily">这里</a>。SpringBoard 只接收按键(锁屏/静音等)，触摸，加速，接近传感器等几种 Event，随后用 mach port 转发给需要的App进程。随后苹果注册的那个 Source1 就会触发回调，并调用 _UIApplicationHandleEventQueue() 进行应用内部的分发。</p>
<p>_UIApplicationHandleEventQueue() 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture/处理屏幕旋转/发送给 UIWindow 等。通常事件比如 UIButton 点击、touchesBegin/Move/End/Cancel 事件都是在这个回调中完成的。</p>
<h2 id="事件的分类"><a class="header" href="#事件的分类">事件的分类</a></h2>
<p>iOS中的事件可以分为3大类型：</p>
<ul>
<li>触摸事件</li>
<li>加速计事件</li>
<li>远程控制事件</li>
</ul>
<p>这里是关注触摸事件。</p>
<p>在iOS中，并不是任何对象都能处理事件，只有继承了UIResponder的对象才能接受并处理事件，比如：</p>
<ul>
<li>UIApplication</li>
<li>UIViewController</li>
<li>UIView</li>
</ul>
<p>在UIResponder中提供了以下方法来处理触摸事件：</p>
<pre><code class="language-objc">- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event;
- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event;
- (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event;
- (void)touchesCancelled:(NSSet *)touches withEvent:(UIEvent *)event;
</code></pre>
<p>对于触摸事件，iOS中提供了UITouch对象对象，其作为用：</p>
<ul>
<li>保存着跟手指相关的信息，比如触摸的位置、时间、阶段</li>
<li>当手指移动时，系统会更新同一个UITouch对象，使之能够一直保存该手指在的触摸位置</li>
<li>当手指离开屏幕时，系统会销毁相应的UITouch对象</li>
</ul>
<p>比如在UIView的几个touch方法中，就是将UITouch作为参数传递进去的：</p>
<pre><code class="language-objc">- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event

- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event

- (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event


- (void)touchesCancelled:(NSSet *)touches withEvent:(UIEvent *)event
</code></pre>
<p>UITouch的产生为：</p>
<p>当用户用一根手指触摸屏幕时，会创建一个与手指相关的UITouch对象，并且一根手指对应一个UITouch对象。如果两根手指同时触摸一个view，那么view只会调用一次touchesBegan:withEvent:方法，touches参数中装着2个UITouch对象；如果这两根手指一前一后分开触摸同一个view，那么view会分别调用2次touchesBegan:withEvent:方法，并且每次调用时的touches参数中只包含一个UITouch对象。</p>
<h2 id="事件的传递"><a class="header" href="#事件的传递">事件的传递</a></h2>
<ul>
<li>发生触摸事件后，系统会将该事件加入到一个由UIApplication管理的事件队列中。</li>
<li>然后UIApplication会从事件队列中取出最前面的事件，并将事件分发下去以便处理，通常，先发送事件给应用程序的主窗口（keyWindow）。</li>
<li>主窗口keyWindow会在视图层次结构中找到一个最合适的视图来处理触摸事件，这也是整个事件处理过程的第一步。</li>
</ul>
<p>找到合适的视图控件后，就会调用视图控件的touches方法来作具体的事件处理。</p>
<p>也就是说，触摸事件的传递是从父控件传递到子控件，即UIApplication-&gt;window-&gt;寻找处理事件最合适的view的一个过程。</p>
<h3 id="寻找合适的控件来处理事件"><a class="header" href="#寻找合适的控件来处理事件">寻找合适的控件来处理事件</a></h3>
<ol>
<li>首先判断主窗口（keyWindow）自己是否能接受触摸事件</li>
<li>判断触摸点是否在自己身上</li>
<li>子控件数组中从后往前遍历子控件，重复前面的两个步骤</li>
<li>找到view，比如叫做fitView，那么会把这个事件交给这个fitView，再遍历这个fitView的子控件，直至没有更合适的view为止。</li>
<li>如果没有符合条件的子控件，那么就认为自己最合适处理这个事件。</li>
</ol>
<p>比如下面的四个View：白色、红色、蓝色、黄色，其中白色view是UIViewController的view，点击黄色view事件的传递过程为：</p>
<p>UIApplication -&gt; UIWindow -&gt; 白色view（UIViewController的view） -&gt; 红色view -&gt; 蓝色view -&gt; 黄色view</p>
<p><img src="answer/02_uikit/./../../assets/img/station_008.png" alt="" /></p>
<p>找到合适的控件依赖于<code>hitTest:withEvent:</code>和<code>pointInside:withEvent:</code>两个方法：</p>
<pre><code class="language-objc">// recursively calls -pointInside:withEvent:. point is in the receiver's coordinate system
- (nullable UIView *)hitTest:(CGPoint)point withEvent:(nullable UIEvent *)event;

// default returns YES if point is in bounds
- (BOOL)pointInside:(CGPoint)point withEvent:(nullable UIEvent *)event;   

</code></pre>
<h4 id="hittestwithevent-方法"><a class="header" href="#hittestwithevent-方法"><code>hitTest:withEvent:</code> 方法</a></h4>
<ul>
<li>作用：寻找并返回最合适的view。</li>
<li>调用时机：只要事件一传递给一个控件,这个控件就会调用他自己的hitTest：withEvent：方法。不管这个控件能不能处理事件，也不管触摸点在不在这个控件上，事件都会先传递给这个控件，随后再调用hitTest:withEvent:方法</li>
</ul>
<pre><code class="language-objc">- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event{
    // 1. 判断能否接收事件
    if (self.userInteractionEnabled == NO || self.hidden == YES ||  self.alpha &lt;= 0.01) return nil;
    
    // 2. 判断触摸点是否在自身上
    if ([self pointInside:point withEvent:event] == NO) return nil;
    
    // 3. 从后往前遍历子控件数组
    for (int i = (int)self.subviews.count - 1; i &gt;= 0; i--)     {
        UIView *childView = self.subviews[i];
        // 坐标系的转换, 把窗口上的点转换为子控件上的点
        CGPoint childP = [self convertPoint:point toView:childView];
        UIView *fitView = [childView hitTest:childP withEvent:event];
        if (fitView) { // 如果能找到最合适的view
            return fitView;
        }
    }
    
    // 4. 没有找到更合适的view，自己作为最合适处理这个事件的view。
    return self;
}

</code></pre>
<p><img src="https://docs-assets.developer.apple.com/published/7c21d852b9/f17df5bc-d80b-4e17-81cf-4277b1e0f6e4.png" alt="" /></p>
<h4 id="pointinsidewithevent-方法"><a class="header" href="#pointinsidewithevent-方法"><code>pointInside:withEvent:</code> 方法</a></h4>
<p><code>pointInside:withEvent:</code>方法判断点在不在当前view上（方法调用者的坐标系上）如果返回YES，代表点在方法调用者的坐标系上;返回NO代表点不在方法调用者的坐标系上，那么方法调用者也就不能处理事件。</p>
<h2 id="事件的响应"><a class="header" href="#事件的响应">事件的响应</a></h2>
<p>事件从UIApplication-&gt;UIWindow-&gt;寻找处理事件最合适的view传递后，就会调用控件的touches方法来作具体的事件处touchesBegan…touchesMoved…touchedEnded…等。touches 方法就是对事件的响应，事件的响应是顺着响应链向上传递的，这个传递是依赖于UIResponder的nextResponder：</p>
<ul>
<li>UIView ：如果view是VC的root view，则它的nextResponder是 VC；否则是父view</li>
<li>UIViewController ：如果 vc 是window的root vc，则它的nextResponder是 window，否则是父vc</li>
<li>UIWindow：它的nextResponder是UIApplication</li>
<li>UIApplication ：它的nextResponder是app delegate。</li>
</ul>
<p>所以整个事件在找到合适的view之后，判断当前view是否能处理这个事件，如果不能，则顺着nextResponder向父view传递，如果传递到VC也不能处理这个事件，则继续传递到UIWindow，如果window对象也不处理，则其将事件或消息传递给UIApplication对象，如果UIApplication也不能处理该事件或消息，则将其丢弃。其中任何一环能处理事件，则进行时间处理，整个事件的传递就结束了。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1055199-2a49a16e1e483b5c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/603/format/webp" alt="" /></p>
<h2 id="总结-1"><a class="header" href="#总结-1">总结</a></h2>
<p>事件处理的整个流程总结：</p>
<ol>
<li>触摸屏幕产生触摸事件后，触摸事件会被添加到由UIApplication管理的事件队列中（即，首先接收到事件的是UIApplication）。</li>
<li>UIApplication会从事件队列中取出最前面的事件，把事件传递给应用程序的主窗口（keyWindow）。</li>
<li>key window会在视图层次结构中找到一个最合适的视图来处理触摸事件。（至此，第一步已完成)</li>
<li>最合适的view会调用自己的touches方法处理事件</li>
<li>touches默认做法是把事件顺着响应者链条向上抛，即顺着nextResponder向上传递。</li>
</ol>
<p>事件的传递和响应的区别：<br />
事件的传递是从上到下（父控件到子控件），事件的响应是从下到上（顺着响应者链条向上传递：子控件到父控件。</p>
<h1 id="应用"><a class="header" href="#应用">应用</a></h1>
<h2 id="1-扩大按钮的响应区域"><a class="header" href="#1-扩大按钮的响应区域">1. 扩大按钮的响应区域</a></h2>
<p><code>pointInside:withEvent:</code>方法可以判断事件的点是否在当前view上，则可以重写该方法，扩大响应区域。有两种方式：</p>
<ol>
<li>继承自 UIButton 重写该方法</li>
<li>使用分类，在分类中重写该方法。（不建议，因为分类会覆盖本类的实现）</li>
</ol>
<p>代码可参考</p>
<ul>
<li>继承：<a href="https://gist.github.com/liumenghua/568e99957ff0ca226040751e14cff9d0">EnlargeButton</a></li>
<li>分类：<a href="https://gist.github.com/liumenghua/8d12460b933481bb4c333eac04997073">UIButton+Enlarge</a></li>
</ul>
<p>另外，不建议重写<code>hitTest:withEvent:</code>，因为会阻断事件的传递，比如上面的代码改成这样，并且把红色的button扩大较大的热区，则蓝色的button就不能响应事件：</p>
<pre><code class="language-objc">- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event {
    CGRect rect = [self enlargedRect];
    if (CGRectContainsPoint(rect, point)) {
        return self;
    }
    return nil;
}
</code></pre>
<p><img src="answer/02_uikit/./../../assets/img/station_009.png" alt="" /></p>
<h2 id="2-自定事件响应机制"><a class="header" href="#2-自定事件响应机制">2. 自定事件响应机制</a></h2>
<p>1.有一个viewA，viewA有一个subView叫做viewB，要求触摸viewB时,viewB会响应事件，而触摸viewA本身，不会响应该事件。如何实现？</p>
<p>在父View，即viewA中的hitTest:方法中，将自己从合适的view中去除：</p>
<pre><code class="language-objc">- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event{
    UIView *view = [super hitTest:point withEvent:event];
    if (view == self) {
        return nil;
    }
    return view;
}
</code></pre>
<p>2.一个事件多个对象处理</p>
<p>利用 touchs 方法，自己先响应事件，再向上传递</p>
<pre><code class="language-objc">- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event{ 
    // 1.自己先处理事件...
    NSLog(@&quot;do somthing...&quot;);

    // 2.再调用系统的默认做法，再把事件交给上一个响应者处理
    [super touchesBegan:touches withEvent:event]; 
}

</code></pre>
<h1 id="uiview-哪些情况下不能接收触摸事件"><a class="header" href="#uiview-哪些情况下不能接收触摸事件">UIView 哪些情况下不能接收触摸事件?</a></h1>
<p>有三种情况：</p>
<ul>
<li><code>userInteractionEnabled</code> 为 <code>NO</code></li>
<li>隐藏，即 <code>hidden</code> 为 <code>YES</code></li>
<li><code>alpha &lt;= 0.01</code></li>
</ul>
<h1 id="扩大按钮响应区域的方法有哪些"><a class="header" href="#扩大按钮响应区域的方法有哪些">扩大按钮响应区域的方法有哪些？</a></h1>
<ol>
<li>
<p>在 button 上面盖一个蒙层，用蒙层做事件响应</p>
</li>
<li>
<p>重写 UIButton 的 <code>pointInside:withEvent:</code> 方法，扩大响应区域，或者重写<code>hitTest:withEvent:</code>，但不建议，以为会阻断事件的传递。具体见<a href="answer/02_uikit/./102_ans_ch_2_uikit_10.html">iOS 中的事件传递和响应者链</a></p>
</li>
</ol>
<h1 id="手势冲突如何处理"><a class="header" href="#手势冲突如何处理">手势冲突如何处理？</a></h1>
<p>1.修改响应优先级</p>
<p>UIGestureRecognizer类中有两个方法</p>
<pre><code class="language-objc">// 让自身这个手势事件响应优先级低于其它手势事件
// 只是在对于比它响应优先级低的手势调用
- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldBeRequiredToFailByGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer  {
    return YES;
}

// 让自身这个手势事件响应优先级高于其它手势事件
// 只是在对于比它响应优先级高的手势调用
- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldRequireFailureOfGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer {
    return YES;
}
</code></pre>
<p>2.同时响应</p>
<pre><code class="language-objc">// 共存  A手势或者B手势 代理方法里shouldRecognizeSimultaneouslyWithGestureRecognizer   有一个是返回YES，就能共存
- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer {
    return YES;
}
</code></pre>
<h1 id="参考-3"><a class="header" href="#参考-3">参考</a></h1>
<ul>
<li><a href="https://developer.apple.com/documentation/uikit/touches_presses_and_gestures/using_responders_and_the_responder_chain_to_handle_events?language=objc">Using Responders and the Responder Chain to Handle Events</a></li>
<li><a href="https://www.jianshu.com/p/2e074db792ba">史上最详细的iOS之事件的传递和响应机制-原理篇</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="app-1"><a class="header" href="#app-1">APP</a></h1>
<h2 id="app-的生命周期"><a class="header" href="#app-的生命周期">APP 的生命周期</a></h2>
<p>iOS APP 的生命周期包含以下阶段：</p>
<ul>
<li>Not running（未运行状态）：app未启动或者被终止（无论是被系统还是用户）。</li>
<li>Inactive（不活跃状态）：app在前台运行但未接收事件。app只在转换到不同状态时会短暂地保持此状态。进入此状态后，app会很快进入后台（Background）或活动（Active）状态。（打电话时或者下拉通知栏时app会进入此状态）</li>
<li>Active（活动状态）：app在前台运行并且正在接收事件。处于前台的app通常状态就是Active。</li>
<li>Background（后台状态）：app在屏幕上不可见但是正在执行代码，这是后台状态。当用户退出应用后（应该是按home键），系统会将app在挂起（suspend）前短暂地移动到后台（Background）状态。</li>
<li>Suspended（挂起状态）：应用程序在内存中，但不执行代码。系统会挂起在后台（Background）状态的应用程序。系统可能会为了腾出内存空间，将app清除出内存。</li>
</ul>
<p><img src="answer/02_uikit//src/assets/img/station_001.png" alt="" /></p>
<p>UIApplication 提供了对APP的状态管理，可以从其 UIApplicationDelegate 中处理生命周期各个阶段的需要执行的业务，同时也有相应的通知。</p>
<h3 id="生命周期各阶段"><a class="header" href="#生命周期各阶段">生命周期各阶段</a></h3>
<ul>
<li>
<p><strong>APP 启动</strong></p>
<p>iOS APP的入口为mina函数：</p>
<pre><code class="language-objc">int main(int argc, char * argv[]) {
    NSString * appDelegateClassName;
    @autoreleasepool {
        // Setup code that might create autoreleased objects goes here.
        appDelegateClassName = NSStringFromClass([AppDelegate class]);
    }
    return UIApplicationMain(argc, argv, nil,   appDelegateClassName);
}
</code></pre>
<p>main函数执行并返回一个 UIApplicationMain 函数。UIApplicationMain 中会创建一个 UIApplication 的实例，是一个单例，可以通过 <code>[UIApplication sharedApplication]</code> 访问。主线程的 runloop 也是从 main 函数这里开始的：UIApplicationMian中创建了一个和主线程对应的runloop，一直处于消息处理和休息等待的循环，一直到app退出。</p>
</li>
<li>
<p><strong>APP 启动完成 FinishLaunching</strong></p>
<pre><code class="language-objc">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
    // Override point for customization after application launch.
    return YES;
}

// 对应通知
UIKIT_EXTERN NSNotificationName const UIApplicationDidFinishLaunchingNotification;
</code></pre>
</li>
<li>
<p><strong>程序由后台转入前台</strong>:前台是指app为当前手机展示. app首次启动时不会调用该方法</p>
<pre><code class="language-objc">- (void)applicationWillEnterForeground:(UIApplication *)application;

// 对应通知
UIKIT_EXTERN NSNotificationName const UIApplicationWillEnterForegroundNotification;
</code></pre>
</li>
<li>
<p><strong>程序进入活跃状态</strong>
该方法app首次进入就会调用, 由后台转入前台, 也会在 <code>applicationWillEnterForeground</code> 方法之后调用</p>
<pre><code class="language-objc">- (void)applicationDidBecomeActive:(UIApplication *)application;

// 对应通知
UIKIT_EXTERN NSNotificationName const UIApplicationDidBecomeActiveNotification;
</code></pre>
</li>
<li>
<p><strong>程序进入非活跃状态</strong>
比如有电话进来或者锁屏等情况, 此时应用会先进入非活跃状态, 也有可能是程序即将进入后台(进入后台前会先调用)</p>
<pre><code class="language-objc">- (void)applicationWillResignActive:(UIApplication *)application;

// 对应通知
UIKIT_EXTERN NSNotificationName const UIApplicationWillResignActiveNotification;
</code></pre>
</li>
<li>
<p><strong>程序进入后台</strong></p>
<pre><code class="language-objc">- (void)applicationDidEnterBackground:(UIApplication *)application;

// 对应通知
UIKIT_EXTERN NSNotificationName const UIApplicationDidEnterBackgroundNotification; 
</code></pre>
<p>当程序进入后台，很快便会就如挂起状态，在挂起状态下，无法执行任何代码。等到系统内存告急时会被杀死，如果有未完成的任务，可以在该方法下申请延时180s执行代码.</p>
<pre><code class="language-objc">  __block UIBackgroundTaskIdentifier backTaskId;
backTaskId = [application beginBackgroundTaskWithExpirationHandler:^{
    NSLog(@&quot;backgroundTask reaches 0&quot;);
    [application endBackgroundTask:backTaskId];
    backTaskId = UIBackgroundTaskInvalid;
}];
</code></pre>
</li>
<li>
<p><strong>程序即将退出</strong></p>
<pre><code class="language-objc">- (void)applicationWillTerminate:(UIApplication *)application;

// 对应通知
UIKIT_EXTERN NSNotificationName const UIApplicationWillTerminateNotification;
</code></pre>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="uikit-相关算法"><a class="header" href="#uikit-相关算法">UIKit 相关算法</a></h1>
<h2 id="1-找出两个-uiview-的最近的公共父-view如果不存在则输出-nil"><a class="header" href="#1-找出两个-uiview-的最近的公共父-view如果不存在则输出-nil">1. 找出两个 <code>UIView</code> 的最近的公共父 <code>View</code>，如果不存在，则输出 nil。</a></h2>
<p>如果是在不同的Window上，则没有公共父 view。</p>
<ul>
<li>思路：1. 用 set 保存 view1 的所有父view，再遍历 view2 的父view，如果set中有，则为最近父view</li>
<li>复杂度：时间 O(n)， set查找的复杂度为O(1)，空间 O(n)</li>
</ul>
<pre><code class="language-objc">- (UIView *)commonSuperViewFromView1:(UIView *)view1 view2:(UIView *)viwe2 {
    NSSet *view1SuperViews = [self superViews:view1];
    while (viwe2 != nil) {
        if ([view1SuperViews containsObject:viwe2]) return viwe2;
        viwe2 = [viwe2 superview];
    }
    return nil;
}

- (NSSet *)superViews:(UIView *)view {
    if (!view) return nil;
    
    NSMutableSet *set = [NSMutableSet set];
    while (view != nil) {
        [set addObject:view];
        view = [view superview];
    }
    return [set copy];
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="内存基础知识"><a class="header" href="#内存基础知识">内存基础知识</a></h1>
<ol>
<li>
<p>内存中的5大区分别是什么？</p>
</li>
<li>
<p>堆区和栈区的区别？</p>
</li>
<li>
<p>说一下什么是悬垂指针？什么是野指针? </p>
</li>
<li>
<p><code>BAD_ACCESS</code> 在什么情况下出现? </p>
</li>
<li>
<p>什么是深拷贝？什么是浅拷贝？</p>
</li>
<li>
<p>copy 和 mutableCopy 的区别？</p>
</li>
</ol>
<h1 id="ios-内存管理策略"><a class="header" href="#ios-内存管理策略">iOS 内存管理策略</a></h1>
<ol>
<li>
<p>iOS 内存管理有哪些关键字，说一下对这些关键字的理解？</p>
</li>
<li>
<p><code>assign</code> 修饰对象会有什么问题？</p>
</li>
<li>
<p><code>weak</code> 和 <code>assign</code> 的区别？</p>
</li>
<li>
<p><code>weak</code> 的实现原理？</p>
</li>
<li>
<p>delegate 为何要用 <code>weak</code> 修饰?</p>
</li>
<li>
<p><code>block</code> 属性为什么需要用 <code>copy</code> 来修饰？</p>
</li>
<li>
<p>内存管理默认的关键字是什么？</p>
</li>
<li>
<p>nil 和 release 的区别？</p>
</li>
<li>
<p>为什么不要在初始化方法和 dealloc 中使用访问器方法(setter 和 getter)？</p>
</li>
<li>
<p>ObjC 对象在 dealloc 中会做些什么事情？</p>
</li>
<li>
<p><code>NSString</code> 使用 <code>strong</code> 可以吗？<code>NSArray</code> 呢？</p>
</li>
<li>
<p><code>NSNumber</code>、<code>NSString</code>、<code>NSDate</code> 的内存管理? 或者说 Tagged Pointer。</p>
</li>
<li>
<p>iOS 中哪些情况会导致循环引用？如何检测？</p>
</li>
</ol>
<h1 id="arc"><a class="header" href="#arc">ARC</a></h1>
<ol>
<li>
<p>ARC 内存管理的原则？</p>
</li>
<li>
<p>使用自动引用数ARC应该遵循的原则? </p>
</li>
<li>
<p>ARC 的 <code>retainCount</code> 怎么存储的？</p>
</li>
<li>
<p>ARC 在编译时做了哪些工作？在运行时做了哪些工作？ </p>
</li>
</ol>
<h1 id="autoreleasepool"><a class="header" href="#autoreleasepool">AutoreleasePool</a></h1>
<ol>
<li>
<p>简要说一下 <code>@autoreleasepool</code> 的数据结构？</p>
</li>
<li>
<p><code>@autoreleasepool</code> 的释放时机？</p>
</li>
<li>
<p><code>@autoreleasepool</code> 与 <code>NSThread</code>、<code>NSRunLoop</code> 的关系? </p>
</li>
<li>
<p>什么场景需要手动添加 <code>@autoreleasepool</code> ？</p>
</li>
<li>
<p><code>autorelease</code> 对象什么时候释放？</p>
</li>
<li>
<p>访问 <code>__weak</code> 修饰的变量，是否已经被注册在了 <code>@autoreleasePool</code> 中？为什么？</p>
</li>
<li>
<p>为什么已经有了 ARC ,但还是需要 <code>@autoreleasepool</code> 的存在？</p>
</li>
<li>
<p>方法或函数返回一个对象时，会对对象 <code>autorelease</code> 么？为什么？</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="objective-c-对象"><a class="header" href="#objective-c-对象">Objective-C 对象</a></h1>
<ol>
<li>
<p>一个 NSObject 对象占用多少内存？</p>
</li>
<li>
<p>ObjC 中有几种类型的对象？</p>
</li>
<li>
<p>对象的 <code>isa</code> 指针指向哪里？</p>
</li>
<li>
<p>ObjC 的类信息存放在哪里？</p>
</li>
<li>
<p>Selector, Method 和 IMP 的区别与联系？</p>
</li>
<li>
<p>为什么需要在初始化方法中调用 <code>self = [super init]</code> ？</p>
</li>
<li>
<p>下面的代码输出什么？</p>
<pre><code class="language-objc">@implementation Son : Father
- (id)init {
	self = [super init];
	if (self) {
		NSLog(@&quot;%@&quot;, NSStringFromClass([self class]));
		NSLog(@&quot;%@&quot;, NSStringFromClass([super class]));
	}
	return self;
}
@end	
</code></pre>
</li>
</ol>
<h1 id="category"><a class="header" href="#category">Category</a></h1>
<ol>
<li>
<p>Category 的使用场合是什么？</p>
</li>
<li>
<p>Category 的实现原理 </p>
</li>
<li>
<p>Category 在编译过后，是在什么时机与原有的类合并到一起的? </p>
</li>
<li>
<p>Category 和 Class Extension 的区别是什么？</p>
</li>
<li>
<p>Category 中有 load 方法吗？load 方法是什么时候调用的？load 方法能继承吗？</p>
</li>
<li>
<p>load、initialize 方法的区别什么？它们在 category 中的调用的顺序？以及出现继承时他们之间的调用过程？</p>
</li>
<li>
<p>Category 能否添加成员变量？如果可以，如何给 Category 添加成员变量？</p>
</li>
<li>
<p>关联对象以什么形式进行存储？关联对象的生命周期如何管理？</p>
</li>
<li>
<p>关联对象是线程安全的么？</p>
</li>
<li>
<p>Apple 为什么不把关联对象实现的成员变量添加到类的结构中去，而是单独的提供一个关联对象 manager 来存储和管理？</p>
</li>
</ol>
<h1 id="runtime"><a class="header" href="#runtime">Runtime</a></h1>
<ol>
<li>
<p>如何理解Objective-C的动态性？/为什么说 Objective-C 是一门动态的语言？</p>
</li>
<li>
<p>在 Obj-C 中为什么叫发消息而不叫函数调用？</p>
</li>
<li>
<p>说一下 Runtime 的方法调用流程，即消息发送、方法解析、消息转发? </p>
</li>
<li>
<p>NSInvocation 和 NSMethodSignature 是什么？</p>
</li>
<li>
<p>类的方法缓存存储在哪？是先缓存还是先调用？</p>
</li>
<li>
<p>runtime 在项目中的应用？</p>
</li>
<li>
<p>如何运用 Runtime 字典转模型？进行模型的归解档？</p>
</li>
<li>
<p>说一下 Runtime 的方法缓存？存储的形式、数据结构以及查找的过程？</p>
</li>
<li>
<p>是否了解 Type Encoding? </p>
</li>
<li>
<p>Objective-C 如何实现多重继承？</p>
</li>
<li>
<p>说一下 Method Swizzling? 说一下在实际开发中你在什么场景下使用过?</p>
</li>
<li>
<p><code>@synthesize</code> 和 <code>@dynamic</code> 关键字？</p>
</li>
<li>
<p><code>_cmd</code> 关键字的作用？</p>
</li>
<li>
<p><code>isMemberOfClass</code> 和 <code>isKindOfClass</code> 的区别？</p>
</li>
</ol>
<h1 id="应用-1"><a class="header" href="#应用-1">应用</a></h1>
<ol>
<li>如何只hook某些个特定实例，对其他的不影响？</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="runloop"><a class="header" href="#runloop">Runloop</a></h1>
<ol>
<li>
<p>讲一下 Runloop 的 Mode? </p>
</li>
<li>
<p>讲一下 Observer ？</p>
</li>
<li>
<p>讲一下 Runloop 的内部实现逻辑? </p>
</li>
</ol>
<h1 id="runloop-和线程"><a class="header" href="#runloop-和线程">Runloop 和线程</a></h1>
<ol>
<li>
<p>Runloop 和线程的关系? </p>
</li>
<li>
<p>GCD 在 Runloop 中的使用？</p>
</li>
<li>
<p>如何使用 Runloop 实现一个常驻线程？这种线程一般有什么作用？</p>
</li>
<li>
<p>主线程 RunLoop 是什么时候初始化的? </p>
</li>
</ol>
<h1 id="runloop-和定时器"><a class="header" href="#runloop-和定时器">Runloop 和定时器</a></h1>
<ol>
<li>
<p>NSTimer 的本质？</p>
</li>
<li>
<p>为什么 NSTimer 有时候不好使? 怎么解决？</p>
</li>
<li>
<p><code>performSelector:afterDelay:</code> 这个方法在子线程中是否起作用？为什么？怎么解决？</p>
</li>
<li>
<p>CADisplayLink 是什么？</p>
</li>
<li>
<p>NSTimer 的循环引用? </p>
</li>
</ol>
<h1 id="runloop-应用"><a class="header" href="#runloop-应用">Runloop 应用</a></h1>
<ol>
<li>
<p>Runloop 有哪些应用？</p>
</li>
<li>
<p>AFNetworking 中如何运用 Runloop ? </p>
</li>
<li>
<p>利用 Runloop 解释一下页面的渲染的过程? </p>
</li>
<li>
<p>如何检测 App 运行过程中是否卡顿? </p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="进程和线程"><a class="header" href="#进程和线程">进程和线程</a></h1>
<ol>
<li>
<p>进程、线程，进程和线程的关系？</p>
</li>
<li>
<p>进程的通信方式? </p>
</li>
<li>
<p>多线程的实质（原理）？</p>
</li>
<li>
<p>多线程的优点和缺点？</p>
</li>
<li>
<p>并行和并发的理解？</p>
</li>
<li>
<p>同步与异步</p>
</li>
</ol>
<h1 id="ios-多线程"><a class="header" href="#ios-多线程">iOS 多线程</a></h1>
<ol>
<li>
<p>iOS 种有哪几种多线程方式？</p>
</li>
<li>
<p>NSThread 一般什么时候用？</p>
</li>
<li>
<p>GCD 相关知识 </p>
</li>
<li>
<p>GCD 有哪些队列，默认提供哪些队列？ </p>
</li>
<li>
<p>NSOperation 和 NSOperationQueue 相关知识 </p>
</li>
<li>
<p>NSOperationQueue如何实现串行队列？</p>
</li>
<li>
<p>GCD 与 NSOperationQueue 有哪些异同? </p>
</li>
<li>
<p>如何自定义 NSOperation？</p>
</li>
<li>
<p>线程和 RunLoop 的关系？</p>
</li>
<li>
<p>为什么 iOS 中要将 UI 操作放在主线程？</p>
</li>
<li>
<p>如何用 GCD 实现一个类似 NSOperation 的控制并发数量的模块? [</p>
</li>
<li>
<p>如何用 GCD 实现类似 NSOperation 的 cancel 功能？</p>
</li>
<li>
<p>如何用 GCD 实现类似 NSOperation 的依赖功能？</p>
</li>
</ol>
<h1 id="线程安全"><a class="header" href="#线程安全">线程安全</a></h1>
<ol>
<li>
<p>多线程技术在使用过程中有哪些注意事项？</p>
</li>
<li>
<p>如何确保线程安全？</p>
</li>
<li>
<p>如何实现线性编程？</p>
</li>
<li>
<p>iOS 种有哪些锁？性能如何？</p>
</li>
<li>
<p>OSSpinLock 存在的问题？</p>
</li>
<li>
<p>自旋锁和互斥锁的区别和使用场景？</p>
</li>
<li>
<p>@synchronized 的原理？</p>
</li>
<li>
<p>解释一下多线程中的死锁，有哪些场景？</p>
</li>
<li>
<p>子线程是否会出现死锁？ </p>
</li>
<li>
<p><code>dispatch_sync</code> 什么时候会产生死锁？</p>
</li>
<li>
<p><code>NSMutableArray</code>、和 <code>NSMutableDictionary</code> 是线程安全的吗？<code>NSCache</code> 呢？</p>
</li>
<li>
<p>atomic 和 nonatomic 的区别? </p>
</li>
<li>
<p><code>atomic</code> 修饰的属性是绝对安全的吗？为什么？</p>
</li>
<li>
<p><code>atomic</code> 的进行加锁的时候使用的是什么锁？</p>
</li>
<li>
<p>dispatch_once 原理? 为什么可以保证只执行一次？[</p>
</li>
</ol>
<h1 id="题目"><a class="header" href="#题目">题目</a></h1>
<ol>
<li>
<p>下列代码的输出。</p>
<pre><code class="language-objc">__block int a = 0;
while (a &lt; 5) {
    dispatch_async(dispatch_get_global_queue(0, 0), ^{
        a++;
    });
}
NSLog(@&quot;%d&quot;, a);
</code></pre>
</li>
<li>
<p>下面代码的输出 </p>
<pre><code class="language-objc">dispatch_queue_t serial_queue = dispatch_queue_create(&quot;com.xxx.test&quot;, DISPATCH_QUEUE_SERIAL);

dispatch_sync(serial_queue, ^{
   sleep(3);
   NSLog(@&quot;task 1 %@&quot;, NSThread.currentThread);
});

dispatch_sync(serial_queue, ^{
   NSLog(@&quot;task 2 %@&quot;, NSThread.currentThread);
});

dispatch_async(serial_queue, ^{
   NSLog(@&quot;task 3 %@&quot;, NSThread.currentThread);
});

dispatch_async(serial_queue, ^{
   NSLog(@&quot;task 4 %@&quot;, NSThread.currentThread);
});

NSLog(@&quot;test end&quot;);
</code></pre>
</li>
<li>
<p>下列代码的输出 </p>
<pre><code class="language-objc">dispatch_queue_t queue = dispatch_queue_create(&quot;Felix&quot;, DISPATCH_QUEUE_CONCURRENT);
NSMutableArray *marr = @[].mutableCopy;
for (int i = 0; i &lt; 1000; i++) {
    dispatch_async(queue, ^{
        [marr addObject:@(i)];
    });
}
NSLog(@&quot;%lu&quot;, marr.count);
</code></pre>
</li>
<li>
<p>下列代码的运行结果 </p>
<pre><code class="language-objc">- (void)viewDidLoad {
   [super viewDidLoad];
   NSLog(@&quot;1&quot;);
   dispatch_sync(dispatch_get_main_queue(), ^{
       NSLog(@&quot;2&quot;);
   });
   NSLog(@&quot;3&quot;);
}
</code></pre>
</li>
<li>
<p>下面代码的运行结果 </p>
<pre><code class="language-objc">dispatch_queue_t queue = dispatch_queue_create(&quot;com.xxx.xxx&quot;, DISPATCH_QUEUE_SERIAL);
NSLog(@&quot;之前: %@&quot;, [NSThread currentThread]);
dispatch_async(queue, ^{
    NSLog(@&quot;sync 之前： %@&quot;, [NSThread currentThread]);
    dispatch_sync(queue, ^{
        NSLog(@&quot;sync: %@&quot;, [NSThread currentThread]);
    });
    NSLog(@&quot;sync 之后： %@&quot;, [NSThread currentThread]);
});
</code></pre>
</li>
<li>
<p>下面代码的运行结果。把 0 换成 1 或者 2 后是什么结果？ </p>
<pre><code class="language-objc">dispatch_semaphore_t t1 = dispatch_semaphore_create(0);

dispatch_async(dispatch_get_global_queue(0, 0), ^{
    NSLog(@&quot;1&quot;);
    dispatch_semaphore_signal(t1);
});
dispatch_semaphore_wait(t1, DISPATCH_TIME_FOREVER);

dispatch_async(dispatch_get_global_queue(0, 0), ^{
    NSLog(@&quot;2&quot;);
	sleep(2);
    dispatch_semaphore_signal(t1);
});
dispatch_semaphore_wait(t1, DISPATCH_TIME_FOREVER);

dispatch_async(dispatch_get_global_queue(0, 0), ^{
    NSLog(@&quot;3&quot;);
    dispatch_semaphore_signal(t1);
});
</code></pre>
</li>
<li>
<p>下面代码的运行结果？将 <code>performSelector:</code> 换成 <code>performSelectorOnMainThread:</code> 呢？</p>
<pre><code class="language-objc">- (void)viewDidLoad {
	[super viewDidLoad];

	dispatch_async(dispatch_get_global_queue(0, 0), ^{
    	NSLog(@&quot;1&quot;);

    	[self performSelector:@selector(test) withObject:nil afterDelay:0];
    	
		NSLog(@&quot;3&quot;);
	});
}

- (void)test {
	NSLog(@&quot;2&quot;);
}
</code></pre>
</li>
<li>
<p>下面代码的运行结果？</p>
<pre><code class="language-objc">dispatch_async(dispatch_get_main_queue(), ^{
    NSLog(@&quot;1, thrad: %@&quot;, [NSThread currentThread]);
});

dispatch_async(dispatch_get_main_queue(), ^{
    NSLog(@&quot;2, thrad: %@&quot;, [NSThread currentThread]);
});

dispatch_async(dispatch_get_main_queue(), ^{
    NSLog(@&quot;3, thrad: %@&quot;, [NSThread currentThread]);
});
</code></pre>
</li>
<li>
<p>有一个 <code>generateContent</code> 比较耗时的方法，会生成特定的内容返回，现在需要调用这个方法：1. 如果方法立马返回，则立即返回这内容 2. 如果 3s 未返回，则返回为空。如何实现？</p>
</li>
<li>
<p>有A、B、C三个耗时任务需要异步执行，当这三个任务都执行完成后更新UI，如何实现？</p>
</li>
<li>
<p>有三个线程轮流执行，第一个线程打印A，第二个线程打印B，第三个线程打印C……循环10次。如何实现？</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><ol>
<li>
<p>什么是 block？ block 和 函数指针 的区别? </p>
</li>
<li>
<p>block 有几种类型？每种类型调用 copy 的结果分别是怎样的？</p>
</li>
<li>
<p>栈 block 存在什么问题？</p>
</li>
<li>
<p>block 如何捕获自动变量？</p>
</li>
<li>
<p>如何捕获对象？</p>
</li>
<li>
<p><code>__block</code> 的作用？</p>
</li>
<li>
<p>block 结构里的 <code>forwarding</code> 指针的作用？</p>
</li>
<li>
<p>为什么 block 属性使用 copy 关键字？</p>
</li>
<li>
<p>block 的循环引用？</p>
</li>
<li>
<p>为什么 Masonry 中的 self 不会循环引用? </p>
</li>
<li>
<p>weakSelf 能解决循环引用问题，为什么还需要 strongSelf？</p>
</li>
<li>
<p>使用 strongSelf 后为什么不会造成循环引用？</p>
</li>
<li>
<p>Block 内部使用 self -&gt; _xxx 是否会出现循环引用？</p>
</li>
</ol>
<h1 id="block-循环引用判断题目"><a class="header" href="#block-循环引用判断题目">Block 循环引用判断题目</a></h1>
<ol>
<li>
<p>下面的代码存在循环引用吗？如果有如何解决？</p>
<pre><code class="language-objc">#import &lt;Foundation/Foundation.h&gt;

typedef void(^Study)();
@interface Student : NSObject
@property (copy , nonatomic) NSString *name;
@property (copy , nonatomic) Study study;

@end

#import &quot;ViewController.h&quot;
#import &quot;Student.h&quot;

@interface ViewController ()
@end

@implementation ViewController

- (void)viewDidLoad {
     [super viewDidLoad];

     Student *student = [[Student alloc]init];
     student.name = @&quot;Hello World&quot;;

     student.study = ^{
         NSLog(@&quot;my name is = %@&quot;,student.name);
     };
 }
</code></pre>
</li>
<li>
<p>下面的代码存在循环引用吗？如果有如何解决？</p>
<pre><code class="language-objc"> #import &lt;Foundation/Foundation.h&gt;

 typedef void(^Study)(NSString *name);
 @interface Student : NSObject
 @property (copy , nonatomic) NSString *name;
 @property (copy , nonatomic) Study study;

 @end

 #import &quot;ViewController.h&quot;
 #import &quot;Student.h&quot;

 @interface ViewController ()
 @end

 @implementation ViewController

 - (void)viewDidLoad {
     [super viewDidLoad];

     Student *student = [[Student alloc]init];
     student.name = @&quot;Hello World&quot;;

     student.study = ^(NSString *name){
          NSLog(@&quot;name is = %@&quot;, name);
     };
 }
</code></pre>
</li>
<li>
<p>下面的代码存在循环引用吗？如果有如何解决？</p>
<pre><code class="language-objc"> #import &lt;Foundation/Foundation.h&gt;
 #import &quot;Student.h&quot;

 @interface Teacher : NSObject
 @property (copy , nonatomic) NSString *name;
 @property (strong, nonatomic) Student *stu;
 @end

 #import &quot;ViewController.h&quot;
 #import &quot;Student.h&quot;
 #import &quot;Teacher.h&quot;

 @interface ViewController ()
 @end

 @implementation ViewController

 - (void)viewDidLoad {
     [super viewDidLoad];
 
     Student *student = [[Student alloc]init];
     Teacher *teacher = [[Teacher alloc]init];
 
     teacher.name = @&quot;i'm teacher&quot;;
     teacher.stu = student;
 
     student.name = @&quot;halfrost&quot;;

     student.study = ^{
         NSLog(@&quot;my name is = %@&quot;,teacher.name);
     };
 
     student.study();
 }

</code></pre>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kvo"><a class="header" href="#kvo">KVO</a></h1>
<ol>
<li>
<p>iOS 用什么方式实现对一个对象的 KVO？（KVO 的本质是什么？）</p>
</li>
<li>
<p>KVO 使用了哪些存储结构？observers 存储在哪里？</p>
</li>
<li>
<p>如何手动触发 KVO？</p>
</li>
<li>
<p>直接修改成员变量会触发 KVO 吗？</p>
</li>
<li>
<p>KVO的优缺点? </p>
</li>
<li>
<p>KVO如何防护? </p>
</li>
</ol>
<h1 id="kvc"><a class="header" href="#kvc">KVC</a></h1>
<ol>
<li>
<p>KVC 的取值和设值原理？</p>
</li>
<li>
<p>KVC 设值会触发 KVO 吗？</p>
</li>
</ol>
<h1 id="通知"><a class="header" href="#通知">通知</a></h1>
<ol>
<li>
<p>实现原理（结构设计、通知如何存储的、name&amp;observer&amp;SEL之间的关系等）</p>
</li>
<li>
<p>通知的发送是同步还是异步的？</p>
</li>
<li>
<p>如何异步发送通知？</p>
</li>
<li>
<p>如何保证通知接收的线程在主线程？</p>
</li>
<li>
<p>NSNotificationQueue 和 Runloop 的关系？</p>
</li>
<li>
<p>页面销毁时不移除通知会崩溃吗？</p>
</li>
<li>
<p>多次添加同一个通知会是什么结果？多次移除通知呢？</p>
</li>
<li>
<p>下面的方式能接收到通知吗？为什么? </p>
<pre><code class="language-objc">// 发送通知
[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(handleNotification:) name:@&quot;TestNotification&quot; object:@1];

// 接收通知
[NSNotificationCenter.defaultCenter postNotificationName:@&quot;TestNotification&quot; object:nil];
</code></pre>
</li>
</ol>
<h1 id="delegate"><a class="header" href="#delegate">Delegate</a></h1>
<ol>
<li>
<p>delegate 通常使用什么关键字修饰？为什么？</p>
</li>
<li>
<p>delegate 和 Block 的区别？哪个效率更高一些？</p>
</li>
</ol>
<h1 id="比较"><a class="header" href="#比较">比较</a></h1>
<ol>
<li>KVO、Delegate、Notification 异同？如何选择？</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><ol>
<li>
<p>了解哪些数据持久化方式？</p>
</li>
<li>
<p>什么情况下用 keychain，系统重装 app 删除、更新，对keychain有影响吗？</p>
</li>
<li>
<p>了解LRU/LFU吗</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="设计模式"><a class="header" href="#设计模式">设计模式</a></h1>
<ol>
<li>
<p>编程中的六大设计原则？</p>
</li>
<li>
<p>了解哪些设计模式？</p>
</li>
<li>
<p>单例会有什么弊端？</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="卡顿优化"><a class="header" href="#卡顿优化">卡顿优化</a></h1>
<ol>
<li>
<p>屏幕成像的原理？CPU 和 GPU 的作用？</p>
</li>
<li>
<p>解释一下什么是屏幕卡顿、掉帧？该如何避免？</p>
</li>
<li>
<p>如何提升 tableview 的流畅度？</p>
</li>
<li>
<p>tableview 加载大图如何优化？</p>
</li>
<li>
<p>如何使用 Instruments 进行性能调优？</p>
</li>
<li>
<p>FPS怎么检测？</p>
</li>
<li>
<p>如何进行卡顿监控？除了 Runloop 还有什么方案？</p>
</li>
<li>
<p>如何抓取卡顿堆栈？</p>
</li>
<li>
<p>什么是离屏渲染？什么情况下会触发？该如何应对？[</p>
</li>
<li>
<p>如何高性能的画一个圆角？</p>
</li>
</ol>
<h1 id="启动优化"><a class="header" href="#启动优化">启动优化</a></h1>
<ol>
<li>
<p>APP 的启动过程，main 文件说起，main 函数中有什么函数？有什么作用？</p>
</li>
<li>
<p>如何优化 APP 的启动时间？</p>
</li>
<li>
<p>静态库和动态库的区别？</p>
</li>
</ol>
<h1 id="编译优化"><a class="header" href="#编译优化">编译优化</a></h1>
<ol>
<li>
<p>Xcode 的编译过程？</p>
</li>
<li>
<p>Xcode 点击 run 之后发生了什么？</p>
</li>
<li>
<p>如何提升编译速度？</p>
</li>
</ol>
<h1 id="包瘦身"><a class="header" href="#包瘦身">包瘦身</a></h1>
<ol>
<li>
<p>如何有效降低 APP 包的大小？</p>
</li>
<li>
<p>如何检测名字不同，但内容相同的图片？</p>
</li>
<li>
<p>如何进行无用代码检测？</p>
</li>
</ol>
<h1 id="内存优化"><a class="header" href="#内存优化">内存优化</a></h1>
<ol>
<li>
<p>如何优化 APP 的内存？</p>
</li>
<li>
<p>是否了解 OOM？如何做 OOM 监控？如何优化？</p>
</li>
<li>
<p>日常如何检查内存泄露？</p>
</li>
</ol>
<h1 id="电量优化"><a class="header" href="#电量优化">电量优化</a></h1>
<ol>
<li>
<p>如何优化 APP 的电量？</p>
</li>
<li>
<p>APP 的哪些功能是比较耗电的？</p>
</li>
</ol>
<h1 id="网络优化"><a class="header" href="#网络优化">网络优化</a></h1>
<ol>
<li>如何优化 APP 的网络流量？</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="五层协议"><a class="header" href="#五层协议">五层协议</a></h1>
<ol>
<li>
<p>TCP/IP 五层模型和每层作用，每层的代表协议？</p>
</li>
<li>
<p>NDS 工作在哪一层？</p>
</li>
<li>
<p>DNS 使用的是 TCP 还是 UDP ？</p>
</li>
<li>
<p>DNS 的解析过程？ </p>
</li>
<li>
<p>DNS 劫持的解决方案？</p>
</li>
<li>
<p>DNS 如何优化 </p>
</li>
</ol>
<h1 id="tcp-vs-udp"><a class="header" href="#tcp-vs-udp">TCP vs UDP</a></h1>
<ol>
<li>
<p>TCP 和 UDP 的区别？</p>
</li>
<li>
<p>TCP 是如何保证可靠传输的？</p>
</li>
<li>
<p>TCP 的流量控制和拥塞控制？</p>
</li>
<li>
<p>TCP 三次握手，为什么需要三次？两次是否可以？</p>
</li>
<li>
<p>TCP 四次挥手，为什么需要四次？三次是否可以？</p>
</li>
<li>
<p>为什么数据要在传输层就分块，而不是等到网络层再分片传递给数据链路层？</p>
</li>
</ol>
<h1 id="httphttps"><a class="header" href="#httphttps">HTTP/HTTPS</a></h1>
<ol>
<li>
<p>HTTP 的请求报文和响应报文的结构？</p>
</li>
<li>
<p>HTTP 的请求方式有哪些？</p>
</li>
<li>
<p>GET 和 POST 请求的区别？</p>
</li>
<li>
<p>HTTP 常见的状态码有哪些？</p>
</li>
<li>
<p>HTTP 1.0、1.2 和 2.0 几个版本的区别？</p>
</li>
<li>
<p>HTTP 的常见头部字段和作用？</p>
</li>
<li>
<p>HTTP 和 HTTPS 的区别？为什么会更安全？加密过程如何处理的？</p>
</li>
<li>
<p>SSL 传输协议？说一下 SSL 验证过程？</p>
</li>
<li>
<p>证书验证具体做了什么工作？如何确保证书可靠？</p>
</li>
<li>
<p>对称加密和非对称加密的区别？</p>
</li>
</ol>
<h1 id="应用-2"><a class="header" href="#应用-2">应用</a></h1>
<ol>
<li>
<p>从输入URL到页面加载发生了什么？</p>
</li>
<li>
<p>抓包软件 Charles 的原理是什么? </p>
</li>
<li>
<p>谈一谈网络中的 session 和 cookie? </p>
</li>
<li>
<p>NSURLConnection 和 NSUURLSession 的区别？</p>
</li>
<li>
<p>NSUrlProtocol 用过吗？用在什么地方了？</p>
</li>
<li>
<p>断点续传功能该怎么实现？</p>
</li>
<li>
<p>大文件下载的功能有什么注意点？</p>
</li>
<li>
<p>发送网络请求的时候，如果带宽 1M，如何针对某些请求，限制其流量?</p>
</li>
<li>
<p>不用 Charles，在 app 内抓包的方法，抓取 app 内所有请求，打印输出，怎么实现？</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="书籍"><a class="header" href="#书籍">书籍</a></h1>
<h2 id="ios书籍"><a class="header" href="#ios书籍">iOS书籍</a></h2>
<ul>
<li>《Effective Objective-C 2.0》</li>
<li>《Objective-C 高级编程》</li>
<li>《高性能iOS应用开发》</li>
<li><a href="https://zsisme.gitbooks.io/ios-/content/index.html">《iOS核心动画高级技巧》</a></li>
</ul>
<h2 id="操作系统"><a class="header" href="#操作系统">操作系统</a></h2>
<ul>
<li>《程序员的自我修养》</li>
</ul>
<h2 id="计算机网络"><a class="header" href="#计算机网络">计算机网络</a></h2>
<ul>
<li>《图解HTTP》</li>
</ul>
<h2 id="数据结构和算法"><a class="header" href="#数据结构和算法">数据结构和算法</a></h2>
<ul>
<li>《剑指Offer》</li>
</ul>
<h1 id="博客"><a class="header" href="#博客">博客</a></h1>
<ul>
<li><a href="https://juejin.cn/user/782508012091645/posts">师大小海腾</a></li>
<li><a href="https://juejin.cn/user/3562073402387006/posts">J_Knight</a></li>
<li><a href="https://juejin.cn/user/1838039172387262/posts">字节跳动技术团队</a></li>
<li><a href="https://github.com/draveness/analyze">draveness</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
