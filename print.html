<!DOCTYPE HTML>
<html lang="zh-CN" class="sidebar-visible no-js rust">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>iOS 小站</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "rust";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="questions/chapter_0_forward.html">前言</a></li><li class="chapter-item expanded "><a href="questions/chapter_1_foundation.html"><strong aria-hidden="true">1.</strong> Foundation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="answer/01_foundation/01_ans_foundation_01.html"><strong aria-hidden="true">1.1.</strong> Foundation</a></li><li class="chapter-item expanded "><a href="answer/01_foundation/01_ans_foundation_02.html"><strong aria-hidden="true">1.2.</strong> 集合</a></li><li class="chapter-item expanded "><a href="answer/01_foundation/01_ans_foundation_03.html"><strong aria-hidden="true">1.3.</strong> C/C++</a></li></ol></li><li class="chapter-item expanded "><a href="questions/chapter_2_uikit.html"><strong aria-hidden="true">2.</strong> UIKit</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="answer/02_uikit/02_ans_uikit_01.html"><strong aria-hidden="true">2.1.</strong> UIKit</a></li><li class="chapter-item expanded "><a href="answer/02_uikit/02_ans_uikit_02.html"><strong aria-hidden="true">2.2.</strong> 动画和渲染</a></li><li class="chapter-item expanded "><a href="answer/02_uikit/02_ans_uikit_03.html"><strong aria-hidden="true">2.3.</strong> 响应者链</a></li><li class="chapter-item expanded "><a href="answer/02_uikit/02_ans_uikit_04.html"><strong aria-hidden="true">2.4.</strong> APP</a></li><li class="chapter-item expanded "><a href="answer/02_uikit/02_ans_uikit_05.html"><strong aria-hidden="true">2.5.</strong> UIKit相关算法</a></li></ol></li><li class="chapter-item expanded "><a href="questions/chapter_3_memory.html"><strong aria-hidden="true">3.</strong> 内存管理</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="answer/03_memory/02_ans_memory_01.html"><strong aria-hidden="true">3.1.</strong> 内存基础</a></li><li class="chapter-item expanded "><a href="answer/03_memory/02_ans_memory_02.html"><strong aria-hidden="true">3.2.</strong> iOS内存管理</a></li><li class="chapter-item expanded "><a href="answer/03_memory/02_ans_memory_03.html"><strong aria-hidden="true">3.3.</strong> 循环引用</a></li><li class="chapter-item expanded "><a href="answer/03_memory/02_ans_memory_04.html"><strong aria-hidden="true">3.4.</strong> ARC</a></li><li class="chapter-item expanded "><a href="answer/03_memory/02_ans_memory_05.html"><strong aria-hidden="true">3.5.</strong> AutoreleasePool</a></li></ol></li><li class="chapter-item expanded "><a href="questions/chapter_4_runtime.html"><strong aria-hidden="true">4.</strong> Runtime</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="answer/04_runtime/03_ans_runtime_01.html"><strong aria-hidden="true">4.1.</strong> NSObject对象</a></li><li class="chapter-item expanded "><a href="answer/04_runtime/03_ans_runtime_02.html"><strong aria-hidden="true">4.2.</strong> Category</a></li><li class="chapter-item expanded "><a href="answer/04_runtime/03_ans_runtime_03.html"><strong aria-hidden="true">4.3.</strong> 关联对象</a></li><li class="chapter-item expanded "><a href="answer/04_runtime/03_ans_runtime_04.html"><strong aria-hidden="true">4.4.</strong> 消息发送</a></li></ol></li><li class="chapter-item expanded "><a href="questions/chapter_5_runloop.html"><strong aria-hidden="true">5.</strong> Runloop</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="answer/05_runloop/05_ans_runloop_01.html"><strong aria-hidden="true">5.1.</strong> Runloop</a></li><li class="chapter-item expanded "><a href="answer/05_runloop/05_ans_runloop_02.html"><strong aria-hidden="true">5.2.</strong> Runloop与Timer</a></li></ol></li><li class="chapter-item expanded "><a href="questions/chapter_6_thread.html"><strong aria-hidden="true">6.</strong> 多线程</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="answer/06_thread/06_ans_thread_01.html"><strong aria-hidden="true">6.1.</strong> 进程和线程</a></li><li class="chapter-item expanded "><a href="answer/06_thread/06_ans_thread_02.html"><strong aria-hidden="true">6.2.</strong> iOS多线程</a></li><li class="chapter-item expanded "><a href="answer/06_thread/06_ans_thread_03.html"><strong aria-hidden="true">6.3.</strong> 线程同步</a></li><li class="chapter-item expanded "><a href="answer/06_thread/06_ans_thread_04.html"><strong aria-hidden="true">6.4.</strong> GCD题目</a></li><li class="chapter-item expanded "><a href="answer/06_thread/06_ans_thread_05.html"><strong aria-hidden="true">6.5.</strong> GCD进阶</a></li></ol></li><li class="chapter-item expanded "><a href="questions/chapter_7_block.html"><strong aria-hidden="true">7.</strong> Block</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="answer/07_block/07_ans_block_01.html"><strong aria-hidden="true">7.1.</strong> Block</a></li><li class="chapter-item expanded "><a href="answer/07_block/07_ans_block_02.html"><strong aria-hidden="true">7.2.</strong> Block循环引用</a></li></ol></li><li class="chapter-item expanded "><a href="questions/chapter_8_notification_delegate_kvo.html"><strong aria-hidden="true">8.</strong> 通知代理KVO</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="answer/08_notify_delegate_kvo/08_ans_notify_01.html"><strong aria-hidden="true">8.1.</strong> KVO</a></li><li class="chapter-item expanded "><a href="answer/08_notify_delegate_kvo/08_ans_notify_03.html"><strong aria-hidden="true">8.2.</strong> Notification</a></li><li class="chapter-item expanded "><a href="answer/08_notify_delegate_kvo/08_ans_notify_02.html"><strong aria-hidden="true">8.3.</strong> 对比</a></li></ol></li><li class="chapter-item expanded "><a href="questions/chapter_9_data.html"><strong aria-hidden="true">9.</strong> 持久化</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="answer/09_data/09_ans_data_01.html"><strong aria-hidden="true">9.1.</strong> 持久化</a></li></ol></li><li class="chapter-item expanded "><a href="questions/chapter_10_design.html"><strong aria-hidden="true">10.</strong> 设计模式</a></li><li class="chapter-item expanded "><a href="questions/chapter_11_performance.html"><strong aria-hidden="true">11.</strong> 性能优化</a></li><li class="chapter-item expanded "><a href="questions/chapter_12_network.html"><strong aria-hidden="true">12.</strong> 计算机网络</a></li><li class="chapter-item expanded affix "><a href="chapter_books.html">推荐书目和博客</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">iOS 小站</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/liumenghua/station_ios" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p>本项目用于巩固 iOS 基础知识。构建工具：</p>
<ul>
<li><a href="https://code.visualstudio.com/">Visual Studio Code</a> 书写</li>
<li><a href="https://github.com/rust-lang/mdBook">mdBook</a> 构建</li>
<li><a href="https://pages.github.com/">GitHub Pages</a> 发布</li>
<li><a href="https://github.com/features/actions">Github Actions</a> 自动部署</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="foundation"><a class="header" href="#foundation">Foundation</a></h1>
<ol>
<li>
<p><code>nil</code>、<code>NIL</code>、<code>NSNULL</code> 有什么区别？</p>
</li>
<li>
<p><code>struct</code>和<code>class</code>的区别? </p>
</li>
<li>
<p>实现 <code>isEqual</code> 和 <code>hash</code> 方法时要注意什么？</p>
</li>
<li>
<p>自定义对象用作字典的 key 的时需要注意什么？</p>
</li>
<li>
<p><code>id</code> 和 <code>instancetype</code> 有什么区别？</p>
</li>
<li>
<p><code>typeof()</code> 和 <code>__typeof()</code>，<code>__typeof__()</code> 的区别? </p>
</li>
<li>
<p><code>import</code> 和 <code>include</code> <code>@class</code> 的区别？</p>
</li>
<li>
<p><code>define</code> 和 <code>extern</code> 的区别？[</p>
</li>
<li>
<p><code>NSInteger</code> 的范围？32位系统和64位系统的差别？</p>
</li>
<li>
<p><code>imageNamed:</code> 和 <code>imageWithContentsOfFile:</code> 哪一个性能更好？为什么？</p>
</li>
<li>
<p><code>NSProxy</code> 和 <code>NSObject</code> 的区别？</p>
</li>
<li>
<p><code>NSMutableArray</code> 是线程安全的吗？如何实现一个线程安全的 <code>NSMutableArray</code>? </p>
</li>
<li>
<p><code>NSCache</code> 和 <code>NSMutableDictionary</code> 的区别和对比？</p>
</li>
<li>
<p><code>NSMutableSet</code> 和 <code>NSMutableArray</code> 的区别？</p>
</li>
<li>
<p><code>NSMapTable</code> 、 <code>NSHashTable</code> 、 <code>NSPointerArray</code> 在什么情况下使用？</p>
</li>
</ol>
<h1 id="cc-基础"><a class="header" href="#cc-基础">C/C++ 基础</a></h1>
<ol>
<li>
<p>下列代码中 p 的结果是多少？</p>
<pre><code class="language-c">int* p = 200;
p++;
printf(&quot;p:%d\n&quot;, p); 
</code></pre>
</li>
<li>
<p><code>char* p = &quot;123&quot;;</code> 和 <code>char p[] = &quot;123&quot;;</code> 的区别？[</p>
</li>
<li>
<p><code>sizeof</code> 的作用？ 32 位 和 64 位 系统下 <code>sizeof(NSInteger)</code> 为多少？</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="foundation-1"><a class="header" href="#foundation-1">Foundation</a></h1>
<h2 id="nilnilnsnull-有什么区别"><a class="header" href="#nilnilnsnull-有什么区别"><code>nil</code>、<code>NIL</code>、<code>NSNULL</code> 有什么区别？</a></h2>
<ul>
<li>
<p><code>nil</code>、<code>NIL</code>、<code>null</code> 可以说是等价的，都代表内存中一块空地址。</p>
</li>
<li>
<p><code>NSNULL</code> 代表一个指向 <code>nil</code> 的对象。通常在集合中占位使用，避免crash。</p>
</li>
</ul>
<h2 id="struct和class的区别"><a class="header" href="#struct和class的区别">struct和class的区别</a></h2>
<ul>
<li>本质区别：
<ul>
<li><code>class</code> 是引用类型，它在堆中分配空间，栈中保存的只是引用；</li>
<li><code>struct</code> 是值类型，它在栈中分配空间。</li>
</ul>
</li>
<li>使用场景：
<ul>
<li><code>struct</code> 有性能优势</li>
<li><code>class</code> 有面向对象的扩展优势.</li>
</ul>
</li>
</ul>
<h2 id="实现-isequal-和-hash-方法时要注意什么"><a class="header" href="#实现-isequal-和-hash-方法时要注意什么">实现 isEqual 和 hash 方法时要注意什么?</a></h2>
<p>在 iOS 中，判断两个对象内容是否相等，一般调用 <code>isEqual</code> 方法。用 <code>==</code> 来判断两个对象是否相等，其实是判断两个对象的地址是否相等。<code>isEqual</code> 系统默认实现是比较两个对象的指针。所以在项目中如果需要指定一套自己判断两个对象是否相同的标准的时候就需要重写<code>isEqual</code>。</p>
<p><code>hash</code> 方法的存在，是因为将对象加到 <code>NSSet</code> 等集合中时，需要利用对象的 <code>Hash</code> 值来标示对象在集合中的位置，将集合查找元素的时间复杂度优化成 O(1)。对于 <code>Hash</code> 值，系统默认是返回该对象的内存地址。</p>
<p>下面是一般<code>isEqual</code>和<code>hash</code>的写法模版。</p>
<pre><code class="language-objc">- (BOOL)isEqual:(id)object {
    // 1. == 判断地址
    if (self == object) return YES;
    
    // 2. isKindOfClass 判断对象类型
    if (![object isKindOfClass:[self class]]) return NO;

    // 3. 进行业务逻辑判断
    return [self isEqualToAnother:(Person *)object];
}

- (BOOL)isEqualToAnother:(Person *)anotherObj {
    // 业务逻辑
    if ([self.name isEqualToString:anotherObj.name]) {
        return YES;
    } else {
        return NO;
    }
}

- (NSUInteger)hash {
    return [self.name hash] ^ [self.job hash];
}

</code></pre>
<h2 id="自定义对象用作字典的-key-的时需要注意什么"><a class="header" href="#自定义对象用作字典的-key-的时需要注意什么">自定义对象用作字典的 key 的时需要注意什么？</a></h2>
<p>1.遵守<code>NSCopying</code>协议，并实现<code>copyWithZone:</code> 方法：字典的key需要遵守NSCopying协议，所以自定义对象作为key时，也需要遵守NSCopying协议，并实现copyWithZone方法</p>
<p>2.同时还需要实现 <code>isEqual</code> 和 <code>hash</code> 方法</p>
<p>实现：</p>
<pre><code class="language-objc">@interface CustomDictKey : NSObject&lt;NSCopying&gt;

@property (nonatomic, copy) NSString *name;

@end

@implementation CustomDictKey

- (id)copyWithZone:(nullable NSZone *)zone {
    CustomDictKey *aCopy = [[CustomDictKey allocWithZone:zone] init];
    if (aCopy) {
        aCopy.name = [self.name copyWithZone:zone];
    }
    return aCopy;
}

- (BOOL)isEqual:(id)other {
    if (other == self) return YES;
        
    if (![other isKindOfClass:[self class]]) return NO;
    
    return [self isEqualToAnother:(CustomDictKey *)other];
}

- (BOOL)isEqualToAnother:(CustomDictKey *)anotherObj {
    if ([self.name isEqualToString:anotherObj.name]) {
        return YES;
    } else {
        return NO;
    }
}

- (NSUInteger)hash {
    return [self.name hash] ^ [self.name hash];
}

@end
</code></pre>
<p>使用：</p>
<pre><code class="language-objc">    CustomDictKey *keyA = [[CustomDictKey alloc] init];
    keyA.name = @&quot;keyA&quot;;
    CustomDictKey *keyB = [[CustomDictKey alloc] init];
    keyB.name = @&quot;keyB&quot;;
    
    NSMutableDictionary *dict =[NSMutableDictionary dictionary];
    [dict setObject:@&quot;testObjectA&quot; forKey:keyA];
    [dict setObject:@&quot;testObjectB&quot; forKey:keyB];
    
    NSLog(@&quot;dict: %@&quot;, dict);
    // &quot;&lt;CustomDictKey: 0x600002e8c4c0&gt;&quot; = testObjectA;
    // &quot;&lt;CustomDictKey: 0x600002e8c4f0&gt;&quot; = testObjectB;
    
    NSLog(@&quot;objA: %@&quot;, [dict objectForKey:keyA]); // objA: testObjectA
    NSLog(@&quot;objB: %@&quot;, [dict objectForKey:keyB]); // objB: testObjectB
</code></pre>
<h2 id="id-和-instancetype-有什么区别"><a class="header" href="#id-和-instancetype-有什么区别">id 和 instancetype 有什么区别？</a></h2>
<p>id 和 instancetype 的区别主要为关联返回类型和非关联返回类型的区别。</p>
<h3 id="关联返回类型"><a class="header" href="#关联返回类型">关联返回类型</a></h3>
<p>即方法的返回结果为所在类的类型的对象。在ObjC中，根据Cocoa的命名规则，满足下述规则的方法都为关联返回类型：</p>
<ol>
<li>类方法中，以<code>alloc</code>或<code>new</code>开头</li>
<li>实例方法中，以<code>autorelease</code>，<code>init</code>，<code>retain</code>或<code>self</code>开头</li>
</ol>
<p>比如:</p>
<pre><code class="language-objc">NSArray *array = [[NSArray alloc] init];
</code></pre>
<p>[NSArray alloc]与[[NSArray alloc]init]返回的都为NSArray的对象</p>
<h3 id="非关联返回类型"><a class="header" href="#非关联返回类型">非关联返回类型</a></h3>
<p>即方法的返回结果不为所在类的类型的对象。</p>
<p>比如:</p>
<pre><code class="language-objc">@interface CustomObject : NSObject

+ (id)factoryMethodB;

@end
</code></pre>
<p><code>+ factoryMethodB</code> 方法的返回值为id，可以为任意类型，所以不一定是<code>CustomObject*</code>类型。</p>
<h3 id="instancetype-的作用"><a class="header" href="#instancetype-的作用">instancetype 的作用</a></h3>
<p>使用 instancetype 作为返回值，返回的返回结果为所在类的类型的对象，即关联返回类型。</p>
<pre><code class="language-objc">@interface CustomObject : NSObject

+ (instancetype)factoryMethodB;

@end
</code></pre>
<pre><code class="language-objc">id obj =  [CustomObject factoryMethodB]; 
</code></pre>
<p>obj 为 <code>CustomObject*</code> 类型。</p>
<h3 id="instancetype-vs-id"><a class="header" href="#instancetype-vs-id">instancetype vs id</a></h3>
<p>一个例子：</p>
<pre><code class="language-objc">@interface CustomObject : NSObject

+ (instancetype)factoryMethodA;
+ (id)factoryMethodB;

@end

@implementation CustomObject

+ (instancetype)factoryMethodA {
    return [[[self class] alloc] init];
}

+ (id)factoryMethodB {
    return [[[self class] alloc] init];
}

@end
</code></pre>
<pre><code class="language-objc">// 因为 instancetype 期望的类型是 CustomObject*，由于 CustomObject 没有 -count 方法，所以编译器会报错
NSUInteger x = [[CustomObject factoryMethodA] count];
    
// 因为 id 类型可以为任意的类，由于有可能 -count 方法存在于其它类中，所以编译器不会报错
NSUInteger y = [[CustomObject factoryMethodB] count];
</code></pre>
<h3 id="总结"><a class="header" href="#总结">总结</a></h3>
<ul>
<li>相同点：都可以作为方法的返回类型。</li>
<li>不同点：
<ul>
<li><code>instancetype</code>可以返回和方法所在类相同类型的对象，<code>id</code>只能返回未知类型的对象；</li>
<li><code>instancetype</code>只能作为返回值，不能像<code>id</code>那样作为参数。</li>
</ul>
</li>
</ul>
<h2 id="typeof-和-__typeof__typeof__-的区别"><a class="header" href="#typeof-和-__typeof__typeof__-的区别"><code>typeof</code> 和 <code>__typeof</code>，<code>__typeof__</code> 的区别?</a></h2>
<p><code>__typeof__()</code>和<code>__typeof()</code>和<code>typeof()</code>都是C的扩展,且意思是相同的，标准C不包括这样的运算符标准。</p>
<p>在标准C 中写扩展是 以 <code>__</code> 开头,所以在标准C中要写成 <code>__typeof() </code>或 <code>__typeof__()</code>。在GNU C 中支持直接写 <code>typeof() </code>或者 <code>__typeof()</code> 或者 <code>__typeof__()</code>。iOS 使用Clang编译器,默认用的C语言版本是GNU99。</p>
<h2 id="import-和-include-class-的区别"><a class="header" href="#import-和-include-class-的区别"><code>import</code> 和 <code>include</code> <code>@class</code> 的区别？</a></h2>
<p>在 ObjC 中，可以使用 <code>#include</code> 、<code>#import</code>、<code>@class</code> 三种方式引用文件。</p>
<h3 id="include"><a class="header" href="#include"><code>#include</code></a></h3>
<ul>
<li>
<p>在C语言中，使用<code>#include</code>来引用头文件。使用<code>#include “xx.h”</code>来引入自定义的头文件，使用<code>#include&lt;xx.h&gt;</code>来引入库中的头文件。</p>
</li>
<li>
<p><code>#include</code> 一般<strong>不能防止重复引用头文件</strong>，如果要防止，操作比较复杂，具体为如下方式引用：</p>
<pre><code class="language-c">#ifndef  ViewController_h

#define ViewController_h

#endif
</code></pre>
</li>
</ul>
<h3 id="import"><a class="header" href="#import"><code>#import</code></a></h3>
<ul>
<li><code>#import</code>是<code>#include</code>的升级版，可以防止重复引入头文件这种现象的发生。</li>
<li><code>#import</code>在引入头的时候，是<strong>完全将头文件拷贝到现在的文件中</strong>，所以也有效率上的问题。</li>
<li>使用<code>#import</code>需要避免出现头文件递归引入的现象。（如：A引入B，B引入A，那么A、B的头文件会互相不停的拷贝）</li>
</ul>
<h3 id="class"><a class="header" href="#class"><code>@class</code></a></h3>
<ul>
<li><code>@class</code>用来告诉编译器有这样一个类，在写代码时不会报错。 @class只是使导入的类名在引用时不受影响，不能创建该类的对象，因为创建对象时也需要访问其内部方法。</li>
<li>因为<code>#import</code>引入头文件有效率问题，所以当还没有调用类中方法，仅仅是定义类变量的时候，使用<code>@class</code>来提醒编译器，而在真正需要调用类方法的时候，再进行<code>#import</code>。</li>
<li>如果A是B的父类，那么这是在B.h中就必须要使用<code>#import</code>来引入A的头，因为需要知道A类中有哪些变量和方法，以免B类中重复定义。</li>
<li>能使用 <code>@class</code> 的地方尽量使用 <code>@class</code>，延后进行 <code>#import</code>。</li>
</ul>
<h2 id="define-和-extern-的区别"><a class="header" href="#define-和-extern-的区别">define 和 extern 的区别？</a></h2>
<ul>
<li>
<p>define是宏定义，即简单的替换，不会对数据类型做校验 <code>#define MY_HOST @&quot;www.xxxx.com&quot;</code></p>
</li>
<li>
<p>extern 和常量结合使用，会分配内存空间，编译器会做类型检查 </p>
<pre><code class="language-objc">// Prefs.h
extern NSString * const PREFS_MY_CONSTANT;

// Prefs.m
NSString * const PREFS_MY_CONSTANT = @&quot;prefs_my_constant&quot;;
</code></pre>
</li>
</ul>
<h2 id="nsinteger-的范围32位系统和64位系统的差别"><a class="header" href="#nsinteger-的范围32位系统和64位系统的差别">NSInteger 的范围？32位系统和64位系统的差别？</a></h2>
<p>32位和64位NSInteger定义:</p>
<pre><code class="language-objc">#if __LP64__ || 0 || NS_BUILD_32_LIKE_64
typedef long NSInteger;
typedef unsigned long NSUInteger;
#else
typedef int NSInteger;
typedef unsigned int NSUInteger;
#endif
</code></pre>
<p>可以看到 NSInteger 在 32 位系统上是 int 的别称，在 64 位系统上是 long 的别称。</p>
<ul>
<li>int占4个字节(byte) 32位(bit), 2^32 = 4294967296:</li>
<li>long 占4个字节 32位 范围： -2147483648 ~ 2147483647</li>
<li>long long 占8个字节 64位 范围： -9223372036854775808 ~ 9223372036854775807</li>
</ul>
<h3 id="32位系统"><a class="header" href="#32位系统">32位系统</a></h3>
<p>NSInteger 是 int 的别称，NSUInteger 是 unsigned int 的别称：</p>
<ul>
<li>
<p>NSInteger 有正负，则范围为： -2^16 + 1 ~ 2^16</p>
</li>
<li>
<p>NSUInteger 不带符号，占4个字节，32位 范围： 0 ~ 2^32</p>
</li>
</ul>
<h3 id="64位系统"><a class="header" href="#64位系统">64位系统</a></h3>
<p>NSInteger 是 long 的别称，NSUInteger 是 unsigned long 的别称：</p>
<ul>
<li>
<p>NSInteger 有正负： -2^32+1 ~ 2^32</p>
</li>
<li>
<p>NSUInteger 不带符号： 0 ~2^64-1</p>
</li>
</ul>
<h2 id="imagenamed-和-imagewithcontentsoffile-哪一个性能更好为什么"><a class="header" href="#imagenamed-和-imagewithcontentsoffile-哪一个性能更好为什么"><code>imageNamed:</code> 和 <code>imageWithContentsOfFile:</code> 哪一个性能更好？为什么？</a></h2>
<ul>
<li>
<p><code>imageNamed:</code>：在生成image对象的同时，会将数据根据name缓存到系统内存中，以提高该方法获取相同图片对象的性能。即使生成的对象被<code>autoreleasePool</code>释放了，这份缓存也不会释放。在应用中需要使用大量相同的图片时非常有用，可以提供性能和内存利用率。</p>
</li>
<li>
<p><code>imageWithContentsOfFile:</code>：该方法不会进行缓存，创建的对象被<code>autoreleasePool</code>释放后，下次使用相同名称的图片需要重新创建。</p>
</li>
</ul>
<p>对比总结：大量使用<code>imageNamed:</code>方式会在不需要缓存的地方增加额外开销CPU的时间。当需要加载一张比较大的图片并且仅作一次性使用时，没必要去缓存这个图片，使用<code>imageWithContentsOfFile:</code>方法会更经济。</p>
<h2 id="nsproxy-和-nsobject-的区别"><a class="header" href="#nsproxy-和-nsobject-的区别"><code>NSProxy</code> 和 <code>NSObject</code> 的区别？</a></h2>
<p>NSProxy 是一个类似于 NSObject 的基类，是一等公民。NSProxy是一个抽象的超类，为充当其他对象或尚不存在的对象的代理对象定义API。通常，发送给代理的消息被转发到实际对象，或者导致代理加载（或转换为）真实对象。NSProxy的子类可用于实现透明的分布式消息传递（例如，NSDistantObject）或用于延迟实例化创建代价高昂的对象。</p>
<p>NSProxy 的常见用法：</p>
<ul>
<li>作为中间对象解决 NSTimer 的循环引用</li>
<li>模拟多继承</li>
</ul>
<p><code>NSProxy</code> 和 <code>NSObject</code> 的区别：</p>
<ul>
<li><code>NSProxy</code> 进行消息转发的效率更高：
<ul>
<li><code>NSObject</code> 的消息转发流程需要经历三个步骤：从自身和 superclass 的方法列表中查找方法，找不到再进行动态方法解析以及备用接收者，最后才是完整的消息转发。</li>
<li><code>NSProxy</code> 是先从自身方法中查找方法，找不到立马调用<code>-methodSignatureForSelector:</code> 和 <code>-forwardInvocation:</code> 进行消息转发。所以在 解决timer的循环引用时基本使用 <code>NSProxy</code> 作为中间件。</li>
</ul>
</li>
<li><code>NSProxy</code> 更轻量级</li>
</ul>
<h1 id="参考"><a class="header" href="#参考">参考</a></h1>
<ul>
<li><a href="https://developer.apple.com/library/archive/releasenotes/ObjectiveC/ModernizationObjC/AdoptingModernObjective-C/AdoptingModernObjective-C.html">Adopting Modern Objective-C</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="foundation-中的集合"><a class="header" href="#foundation-中的集合">Foundation 中的集合</a></h1>
<h1 id="nscache-和-nsmutabledictionary-的区别和对比"><a class="header" href="#nscache-和-nsmutabledictionary-的区别和对比"><code>NSCache</code> 和 <code>NSMutableDictionary</code> 的区别和对比？</a></h1>
<h2 id="对比"><a class="header" href="#对比">对比</a></h2>
<ul>
<li>
<p>相同：<code>NSCache</code> 是一种可变集合，用于临时存储在资源不足时容易被回收的 key-value 键值对。NSCache 具有字典的所有功能，并且提供的API和<code>NSMutableDictionary</code>都是相似的。</p>
</li>
<li>
<p>区别：<code>NSCache</code>还具有如下特性：</p>
<ul>
<li>内存不足时，<code>NSCache</code> 会自动清理缓存，并且提供了是否需要清理的开关和缓存清理时的回调；</li>
<li><code>NSCache</code> 是线程安全的；</li>
<li>区别于 <code>NSMutableDictionary</code> ，<code>NSCache</code> 不需要对 key 进行拷贝。</li>
</ul>
</li>
</ul>
<h2 id="nscache-的实现"><a class="header" href="#nscache-的实现">NSCache 的实现</a></h2>
<ul>
<li>
<p>缓存淘汰：GNUSetup 使用 LRU/LFU 机制进行淘汰，使用频率较少的元素先淘汰；Swfit Foundation 依据对象的 cost 进行淘汰，cost 较少的先淘汰。GNUSetup 中使用 maptable 存储缓存对象，使用 array 维护 LRU/LFU 排序后的对象，用于缓存淘汰；Swfit Foundation 中使用 dictionary 存储缓存对象，维护一个排序的双向链表，用于缓存淘汰。</p>
</li>
<li>
<p>线程安全：GNUSetup 中没有保证 cache 线程安全的代码；Swfit Foundation 中使用 NSLock 保证缓存读写的线程安全</p>
</li>
</ul>
<h2 id="nscache-的应用"><a class="header" href="#nscache-的应用">NSCache 的应用</a></h2>
<h3 id="1-sdwebimage-的应用中"><a class="header" href="#1-sdwebimage-的应用中">1. SDWebImage 的应用中</a></h3>
<p>在 SDWebImage 中，通过将图片放到 NSCache 中，利用 NSCache 自动释放内存的特点在内存不足时自动淘汰不常用的图片。在读取图片时，先检查内存里是否有，有则直接返回；没有再从磁盘里读取。以此减少磁盘操作，保证空间合理释放。</p>
<pre><code class="language-objc">- (nullable UIImage *)imageFromCacheForKey:(nullable NSString *)key options:(SDImageCacheOptions)options context:(nullable SDWebImageContext *)context {
    // 先检查内存里是否有，有则直接返回
    UIImage *image = [self imageFromMemoryCacheForKey:key];
    if (image) {
        return image;
    }
    
    // 再从磁盘里读取
    image = [self imageFromDiskCacheForKey:key options:options context:context];
    return image;
}

- (nullable UIImage *)imageFromMemoryCacheForKey:(nullable NSString *)key {
    return [self.memoryCache objectForKey:key];
}
</code></pre>
<p>代码中 self.memoryCache 为 SDMemoryCache， SDMemoryCache 内部就是将 NSCache 扩展为了 SDMemoryCache 协议：</p>
<pre><code class="language-objc">@protocol SDMemoryCache &lt;NSObject&gt;
@required
- (nonnull instancetype)initWithConfig:(nonnull SDImageCacheConfig *)config;
- (nullable id)objectForKey:(nonnull id)key;
- (void)setObject:(nullable id)object forKey:(nonnull id)key;
- (void)setObject:(nullable id)object forKey:(nonnull id)key cost:(NSUInteger)cost;
- (void)removeObjectForKey:(nonnull id)key;
- (void)removeAllObjects;
@end

@interface SDMemoryCache &lt;KeyType, ObjectType&gt; : NSCache &lt;KeyType, ObjectType&gt; &lt;SDMemoryCache&gt;
@property (nonatomic, strong, nonnull, readonly) SDImageCacheConfig *config;
@end
</code></pre>
<h2 id="nsmutableset-和-nsmutablearray-的区别"><a class="header" href="#nsmutableset-和-nsmutablearray-的区别"><code>NSMutableSet</code> 和 <code>NSMutableArray</code> 的区别？</a></h2>
<ul>
<li>
<p>是否有序：<code>NSMutableSet</code> 中的元素是<strong>无序的</strong>，<code>NSMutableArray</code> 则是有序的</p>
</li>
<li>
<p>元素是否重复：<code>NSMutableSet</code> 中<strong>不会存在重复元素</strong>，<code>NSMutableArray</code> 则可以存在重复元素</p>
</li>
<li>
<p>查找的复杂度：<strong>搜索一个元素时 <code>NSMutableSet</code> 比 <code>NSMutableArray</code> 效率高</strong>，主要是它用到了 hash 算法。
比如你要存储元素A，一个 hash 算法直接就能直接找到A应该存储的位置；同样，当你要访问A时，一个hash过程就能找到A存储的位置。而对于NSArray，若想知道A到底在不在数组中，则需要遍历整个数组，显然效率较低了；</p>
<pre><code class="language-objc">[set containsObject:@&quot;C++&quot;];

[array containsObject:@&quot;C++&quot;];
</code></pre>
</li>
<li>
<p>使用场景：</p>
<ul>
<li><code>NSSet</code> / <code>NSMutableSet</code>：不需要保证顺序的集合、去重、经常查询元素</li>
<li><code>NSArray</code> / <code>NSMutableArray</code>: 需要保证顺序、有重复元素</li>
</ul>
</li>
<li>
<p>实现原理：</p>
<ul>
<li><code>NSSet</code> / <code>NSMutableSet</code>：</li>
</ul>
</li>
</ul>
<h2 id="nsmaptable--nshashtable--nspointerarray"><a class="header" href="#nsmaptable--nshashtable--nspointerarray"><code>NSMapTable</code> 、 <code>NSHashTable</code> 、 <code>NSPointerArray</code></a></h2>
<p>iOS 中，常见的强持有元素的集合为：<code>NSArray</code> 、<code>NSDictionary</code> 、<code>NSSet</code>，同时也提供了弱引用元素的集合：<code>NSMapTable</code>、<code>NSHashTable</code> 、 <code>NSPointerArray</code>等，当不需要集合强持有里面的元素是，可以使用。</p>
<p>使用场景举例：</p>
<ol>
<li>比如有一个数组，数组里面存放了 100 个 view，每隔 10 分钟就会遍历这个数组，然后将这些 view 的 backgroundColor 改变。但是这个数组是输出给其它业务方使用的，也无妨拿到其中的某个 view，在进行一些操作后，就会 <code>removeFromSuperView</code></li>
</ol>
<p>问题：</p>
<ol>
<li>view <code>removeFromSuperView</code> 后，数组中的 view 会释放吗？</li>
</ol>
<p>答案：不会，因为数组对里面的对象是强引用的，数组还持有这个 view，所以不会释放。</p>
<ol start="2">
<li>因为 view 不会释放，所以每次遍历的时候虽然有些 view 已经需要了，但是还存在，影响着性能，怎么解决？</li>
</ol>
<p>答案：目的就是做到当 view <code>removeFromSuperView</code> 后就释放，不释放的根本原因就是因为数组强引用着 view，那么可以从这里入手，让数组不强持有这个view。这里可以使用 NSPointerArray`。</p>
<h1 id="参考-1"><a class="header" href="#参考-1">参考</a></h1>
<ul>
<li><a href="https://juejin.cn/post/6942823617080066085#heading-9">NSCache 源码阅读</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cc"><a class="header" href="#cc">C/C++</a></h1>
<h2 id="指针运算"><a class="header" href="#指针运算">指针运算</a></h2>
<h3 id="下列代码中-p-的结果是多少"><a class="header" href="#下列代码中-p-的结果是多少">下列代码中 p 的结果是多少？</a></h3>
<pre><code class="language-c">int* p = 200;
p++;
printf(&quot;p:%d\n&quot;, p); 
</code></pre>
<p>答案：204</p>
<p>原因：<strong>当一个加法运算，加号左边的操作数是一个指针，而右边的操作数是一个整数时，这个整数值先乘以指针类型的大小（sizeof(int)），然后再加到左边的数上</strong>。如果是 double，则为 8，char 为 1。</p>
<p>扩展：当同一个数组的两个成员的指针相减时，其差值为：地址值的差，再除以一个数组成员的size。这个结果代表了两个指针对应元素的下标之差。</p>
<h3 id="char-p--123-和-char-p--123-的区别"><a class="header" href="#char-p--123-和-char-p--123-的区别"><code>char* p = &quot;123&quot;;</code> 和 <code>char p[] = &quot;123&quot;;</code> 的区别？</a></h3>
<p>答案：</p>
<ul>
<li><code>char* p</code>是一个 <code>&quot;123&quot;</code>的指针，存储的是<code>1</code> <code>2</code> <code>3</code>字符数组，<code>printf(&quot;p:%s\n&quot;, p);</code> 可输出其内容；</li>
<li><code>char p[]</code> 是一个 char 数组，存放了<code>1</code> <code>2</code> <code>3</code>字符，<code>printf(&quot;p:%s\n&quot;, p);</code>可输出其内容。</li>
</ul>
<h3 id="sizeof-的作用-32-位-和-64-位-系统下-sizeofnsinteger-为多少"><a class="header" href="#sizeof-的作用-32-位-和-64-位-系统下-sizeofnsinteger-为多少"><code>sizeof</code> 的作用？ 32 位 和 64 位 系统下 <code>sizeof(NSInteger)</code> 为多少？</a></h3>
<p><code>sizeof</code> 不是一个函数，而是一个运算符。根据数据的类型计算其占用的字节数，<code>sizeof</code> 传入的其实是一个变量，在编译的时候就确定了：</p>
<pre><code class="language-objc">int age = 10000;
sizeof(age);

// 等价于
sizeof(int);
</code></pre>
<p>NSInteger 在 32 和 64 位系统上表现不同：</p>
<ul>
<li>32位系统，NSInteger 是 int 的别称</li>
<li>64位系统，NSInteger 是 long 的别称</li>
</ul>
<pre><code class="language-objc">#if __LP64__ || 0 || NS_BUILD_32_LIKE_64
typedef long NSInteger;
typedef unsigned long NSUInteger;
#else
typedef int NSInteger;
typedef unsigned int NSUInteger;
#endif
</code></pre>
<ul>
<li>32 位系统中，NSInteger 占 4 个字节，所以 <code>sizeof(NSInteger)</code> = 4</li>
<li>64 位系统中，NSInteger 占 8 个字节，所以 <code>sizeof(NSInteger)</code> = 8</li>
</ul>
<p>同样 CGFloat 的实现类似：</p>
<ul>
<li>32位系统，CGFloat 是 float 的别称， 占用 4 字节</li>
<li>64位系统，CGFloat 是 double 的别称， 占用 8 字节</li>
</ul>
<pre><code class="language-objc">typedef CGFLOAT_TYPE CGFloat;
#if defined(__LP64__) &amp;&amp; __LP64__
# define CGFLOAT_TYPE double
#else
# define CGFLOAT_TYPE float
#endif
</code></pre>
<p>各种类型的数据占用的字节数量：</p>
<ul>
<li>BOOL：1</li>
<li>int：4 </li>
<li>long: 8</li>
<li>float: 4
<pre><code class="language-objc">NSLog(@&quot;%ld&quot;, sizeof(float)); // 8
</code></pre>
</li>
<li>double: 8
<pre><code class="language-objc">NSLog(@&quot;%ld&quot;, sizeof(double)); // 8
</code></pre>
</li>
<li>指针: 8 
<pre><code class="language-objc">char *p = 200;
NSLog(@&quot;%ld&quot;, sizeof(p)); // 8
</code></pre>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="uikit"><a class="header" href="#uikit">UIKit</a></h1>
<ol>
<li>
<p><code>UIView</code> 和 <code>CALayer</code> 是什么关系？有何区别？</p>
</li>
<li>
<p><code>frame</code> 和 <code>bounds</code> 的区别? </p>
</li>
<li>
<p><code>loadView</code> 方法的作用？</p>
</li>
<li>
<p><code>UIButton</code> 的父类是什么？<code>UILabel</code> 的父类又是什么？</p>
</li>
<li>
<p><code>UITableView</code> 的继承关系？一直到 <code>NSObject</code> </p>
</li>
<li>
<p><code>UIViewController</code> 的生命周期？</p>
</li>
<li>
<p><code>UIView</code> 的生命周期？</p>
</li>
<li>
<p><code>UIViewController</code>一旦收到内存警告会如何处理？</p>
</li>
<li>
<p><code>setNeedsDisplay</code> 和 <code>layoutIfNeeded</code> 两者是什么关系？</p>
</li>
</ol>
<h1 id="动画和渲染"><a class="header" href="#动画和渲染">动画和渲染</a></h1>
<ol>
<li>
<p>有哪些绘制圆角的方案？不同方式的GPU、CPU占用分别怎么样的？</p>
</li>
<li>
<p>讲讲 CAlayer 的渲染树？</p>
</li>
<li>
<p>iOS中有哪些动画方式？</p>
</li>
<li>
<p>UIView 的 Animation 和 Core Animation 有什么区别？</p>
</li>
<li>
<p>隐式动画是什么？如何关闭？</p>
</li>
<li>
<p>UIView 的 animate.. block方式执行动画，是隐式动画吗？</p>
</li>
<li>
<p>UIView 在执行动画的过程中如何响应事件？</p>
</li>
</ol>
<h1 id="responder-chain"><a class="header" href="#responder-chain">Responder Chain</a></h1>
<ol>
<li>
<p>说一说事件传递和响应者链。 </p>
</li>
<li>
<p>UIView 哪些情况下不能接收触摸事件？</p>
</li>
<li>
<p>扩大按钮响应区域的方法有哪些？</p>
</li>
<li>
<p>手势冲突如何处理？ </p>
</li>
</ol>
<h1 id="app"><a class="header" href="#app">APP</a></h1>
<ol>
<li>APP 的生命周期？</li>
</ol>
<h1 id="算法"><a class="header" href="#算法">算法</a></h1>
<ol>
<li>
<p>找出两个 <code>UIView</code> 的最近的公共父 <code>View</code>，如果不存在，则输出 nil。</p>
</li>
<li>
<p>实现 <code>convertRect: toView:</code> 方法？</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="uikit-1"><a class="header" href="#uikit-1">UIKit</a></h1>
<h2 id="uiview-和-calayer-是什么关系有何区别"><a class="header" href="#uiview-和-calayer-是什么关系有何区别">UIView 和 CALayer 是什么关系？有何区别？</a></h2>
<ul>
<li>
<p><code>UIView</code> 是对 <code>CALayer</code> 的封装。<code>UIView</code> 和 <code>CALayer</code> 的相似行为都依赖于 <code>CALayer</code> 的实现。</p>
</li>
<li>
<p><code>CALayer</code> 继承自 <code>NSObject</code> ，<strong>不能够响应事件</strong>。</p>
</li>
<li>
<p><code>UIView</code> 继承自 <code>UIReponder</code>，负责响应事件。</p>
</li>
<li>
<p><code>UIView</code> 依赖于 <code>CALayer</code> 得以显示。无论是修改了 layer 的可视内容或是几何信息，view 都会跟着变化，反之也是如此，比如下列代码: </p>
<pre><code class="language-objc">UIView *view = [[UIView alloc] initWithFrame:CGRectMake(100, 100, 100, 100)];
view.backgroundColor = [UIColor redColor];

// 1. 修改 layer 的颜色
view.layer.backgroundColor = [[UIColor blueColor] CGColor]; // view 将显示呈蓝色
NSLog(@&quot;view color: %@&quot;, view.backgroundColor); // view color:  0 0 1 1
NSLog(@&quot;layer color: %@&quot;, view.layer.backgroundColor); // layer color: 0 0 1 1

// 2. 修改 layer 的位置
view.layer.frame = CGRectMake(100, 200, 100, 100);
NSLog(@&quot;view y: %f&quot;, view.frame.origin.y); // view y: 200.000000
NSLog(@&quot;layer y: %f&quot;, view.layer.frame.origin.y); // layer y: 200.000000

[self.view addSubview:view];
</code></pre>
</li>
</ul>
<h2 id="为什么需求分离uiview和calayer"><a class="header" href="#为什么需求分离uiview和calayer">为什么需求分离UIView和CALayer</a></h2>
<p>主要是基于两点考虑：</p>
<ul>
<li>职责不同：<code>UIVIew</code> 的主要职责是负责接收并响应事件；而 <code>CALayer</code> 的主要职责是负责显示 UI。</li>
<li>需要复用：在 macOS 和 App 系统上，<code>NSView</code> 和 <code>UIView</code> 虽然行为相似，在实现上却有着显著的区别，却又都依赖于 <code>CALayer</code> 。在这种情况下，只能封装一个 <code>CALayer</code> 出来。</li>
</ul>
<h2 id="frame-和-bounds-的区别"><a class="header" href="#frame-和-bounds-的区别">frame 和 bounds 的区别?</a></h2>
<ul>
<li>
<p>frame: 表示<code>view</code>在父<code>view</code>坐标系统中的位置和大小，参照点是父视图的坐标系统。</p>
</li>
<li>
<p>bounds: 表示<code>view</code>在本地坐标系统中的位置和大小，参照点是本地坐标系统。</p>
</li>
</ul>
<h2 id="loadview-方法的作用"><a class="header" href="#loadview-方法的作用">loadView 方法的作用？</a></h2>
<ul>
<li>作用：用来创建 <code>UIViewController</code> 的<code>view</code>。每个<code>UIViewController</code>都有一个<code>loadView</code>方法。</li>
<li>调用时机：每次访问<code>UIViewController</code>的<code>view</code>(比如<code>controller.view</code>、<code>self.view</code>)而且<code>view</code>为<code>nil</code>时，<code>loadView</code>方法就会被调用。</li>
<li>默认实现：<code>loadView</code> 的默认实现在 <code>[super loadView]</code> 中：
<ol>
<li>查找与<code>UIViewController</code>相关联的xib文件，通过加载xib文件来创建UIViewController的<code>view</code>。如果在初始化<code>UIViewController</code>的时候指定了xib文件名，那么就会根据传入的xib文件名去加载对于的xib文件，如果没有明显的传入xib文件名，就会加载跟<code>UIViewController</code>同名的xib文件。</li>
<li>如果没有找到相关联的xib文件，就会创建一个空白的<code>UIView</code>,然后赋值给<code>UIViewController</code>的<code>view</code>属性。</li>
</ol>
</li>
<li>正确使用：用来自定义<code>UIViewController</code> 的<code>view</code>，可以在上面进行一些自定义设置。重写 <code>loadView</code> 方法，并且不需要调用 <code>[super loadView]</code>。</li>
</ul>
<pre><code class="language-objc">- (void)loadView {
    UIView *customView = [[UIView alloc] initWithFrame:[UIScreen mainScreen].bounds];
    self.view = customView;
}
</code></pre>
<h2 id="uibutton-的父类是什么uilabel-的父类又是什么"><a class="header" href="#uibutton-的父类是什么uilabel-的父类又是什么">UIButton 的父类是什么？UILabel 的父类又是什么？</a></h2>
<ul>
<li><code>UIButton</code> -&gt; <code>UIControl</code> -&gt; <code>UIView</code> -&gt; <code>UIResponder</code></li>
<li><code>UILabel</code> -&gt; <code>UIView</code> -&gt; <code>UIResponder</code></li>
</ul>
<p><code>UIControl</code> 实际上是针对点击触摸进行进一步的封装，可以方便得为点击等添加对应的<code>action</code>。继承自<code>UIControl</code>的控件包括
<code>UIButton</code>，<code>UIDatePicker</code>，<code>UIPageControl</code>，<code>UISegmentedControl</code>，<code>UITextField</code>，<code>UISwitch</code>，<code>UISlider</code>等，其它控件则直接继承自 <code>UIView</code>。</p>
<h2 id="uitableview-的继承关系"><a class="header" href="#uitableview-的继承关系"><code>UITableView</code> 的继承关系？</a></h2>
<p><code>UITableView</code> -&gt; <code>UIScrollView</code> -&gt; <code>UIView</code> -&gt; <code>UIResponder</code> -&gt; <code>NSObject</code></p>
<h2 id="uiviewcontroller-的生命周期"><a class="header" href="#uiviewcontroller-的生命周期">UIViewController 的生命周期</a></h2>
<pre><code class="language-objc">-[ViewController init]
-[ViewController loadView]
-[ViewController viewDidLoad]
-[ViewController viewWillAppear:]
-[ViewController viewWillLayoutSubviews]
-[ViewController viewDidLayoutSubviews]
-[ViewController viewDidAppear:]
-[ViewController viewWillDisappear:]
-[ViewController viewDidDisappear:]
-[ViewController dealloc]
</code></pre>
<p><img src="https://docs-assets.developer.apple.com/published/f06f30fa63/UIViewController_Class_Reference_2x_ddcaa00c-87d8-4c85-961e-ccfb9fa4aac2.png" alt="" /></p>
<h2 id="uiview-的生命周期"><a class="header" href="#uiview-的生命周期">UIView 的生命周期</a></h2>
<p>view层级操作</p>
<pre><code class="language-objc">- (void)addSubview:(UIView *)view;
- (void)didAddSubview:(UIView *)subview;
- (void)willRemoveSubview:(UIView *)subview;
- (void)willMoveToSuperview:(nullable UIView *)newSuperview;
- (void)didMoveToSuperview;
- (void)willMoveToWindow:(nullable UIWindow *)newWindow;
- (void)didMoveToWindow;
- (void)removeFromSuperview;
</code></pre>
<p>view布局操作</p>
<pre><code class="language-objc">- (void)layoutSubviews;
- (void)setNeedsLayout;
- (void)layoutIfNeeded;
</code></pre>
<p>UIView生命周期</p>
<p>init-&gt;willMoveToSuperview-&gt;didMoveSuperview-&gt;(如果有子view)-&gt;subview的willMoveToSuperview-&gt;subview的didMoveSuperview-&gt;didAddSubview-&gt;addSubview-viewWillAppear-&gt;loadViewIfNeeded-&gt;willMoveToWindow-&gt;(如果有子view)-&gt;subview的willMoveToWindow-&gt;subview的didMoveToWindow-&gt;didMoveToWindow-&gt;viewWillLayoutSubviews-&gt;viewDidLayoutSubviews-&gt;layoutSubviews-&gt;drawRect-&gt;viewDidAppear </p>
<h2 id="uiviewcontroller一旦收到内存警告会如何处理"><a class="header" href="#uiviewcontroller一旦收到内存警告会如何处理">UIViewController一旦收到内存警告会如何处理？</a></h2>
<p>当系统内存告急时， <code>ViewController</code> 会接收 <code>didReceiveMemoryWarning</code> :首先会判断当前的 <code>ViewController</code> 是否还显示在 <code>window</code> 上，如果不在就会移除当前的 <code>ViewController</code>，销毁<code>ViewController</code> 上面的子控件，并执行 <code>ViewDidUnload</code> 方法。</p>
<h2 id="setneedsdisplay-和-layoutifneeded-两者是什么关系"><a class="header" href="#setneedsdisplay-和-layoutifneeded-两者是什么关系">setNeedsDisplay 和 layoutIfNeeded 两者是什么关系？</a></h2>
<ul>
<li>
<p><code>setNeedsDisplay</code> 是给当前的视图做了标记。</p>
</li>
<li>
<p><code>layoutIfNeeded</code> 查找是否有标记，如果有标记及立刻刷新。</p>
</li>
</ul>
<p>只有这二者合起来使用，才会起到立刻刷新的效果。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="动画和渲染-1"><a class="header" href="#动画和渲染-1">动画和渲染</a></h1>
<h2 id="有哪些绘制圆角的方案不同方式的gpucpu占用分别怎么样的"><a class="header" href="#有哪些绘制圆角的方案不同方式的gpucpu占用分别怎么样的">有哪些绘制圆角的方案？不同方式的GPU、CPU占用分别怎么样的？</a></h2>
<p>主要有以下 4 种：</p>
<ol>
<li>设置 layer 的 cornerRadius</li>
<li>用贝塞尔曲线 <code>UIBezierPath</code> 作 mask 圆角</li>
<li>使用 CoreGraphics 重新绘制圆角</li>
<li>混合图层，用一张镂空的透明图片作遮罩</li>
</ol>
<h3 id="1-设置-layer-的-cornerradius"><a class="header" href="#1-设置-layer-的-cornerradius">1. 设置 layer 的 cornerRadius</a></h3>
<pre><code class="language-objc">view.layer.masksToBounds = YES;
view.layer.cornerRadius = 10.f;
</code></pre>
<h3 id="2-用贝塞尔曲线-uibezierpath-作-mask-圆角"><a class="header" href="#2-用贝塞尔曲线-uibezierpath-作-mask-圆角">2. 用贝塞尔曲线 <code>UIBezierPath</code> 作 mask 圆角</a></h3>
<p>CAShapeLayer + UIBezierPath:</p>
<pre><code class="language-objc">CAShapeLayer *layer = [CAShapeLayer layer];
UIBezierPath *aPath = [UIBezierPath bezierPathWithOvalInRect:view.bounds];
layer.path = aPath.CGPath;
view.layer.mask = layer;
</code></pre>
<h3 id="3-使用-coregraphics-重新绘制圆角"><a class="header" href="#3-使用-coregraphics-重新绘制圆角">3. 使用 CoreGraphics 重新绘制圆角</a></h3>
<p>使用 CoreGraphics 绘制圆角：</p>
<pre><code class="language-objc">@implementation UIImage (RoundedCorner)

- (UIImage *)drawCircleImage {
 CGFloat side = MIN(self.size.width, self.size.height);
 UIGraphicsBeginImageContextWithOptions(CGSizeMake(side, side), false, [UIScreen mainScreen].scale);
 CGContextAddPath(UIGraphicsGetCurrentContext(),
      [UIBezierPath bezierPathWithOvalInRect:CGRectMake(0, 0, side, side)].CGPath);
 CGContextClip(UIGraphicsGetCurrentContext());
 CGFloat marginX = -(self.size.width - side) / 2.f;
 CGFloat marginY = -(self.size.height - side) / 2.f;
 [self drawInRect:CGRectMake(marginX, marginY, self.size.width, self.size.height)];
 CGContextDrawPath(UIGraphicsGetCurrentContext(), kCGPathFillStroke);
 UIImage *output = UIGraphicsGetImageFromCurrentImageContext();
 UIGraphicsEndImageContext();
 return output;
}
@end
</code></pre>
<pre><code class="language-objc">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    UIImage *image = view.image;
    image = [image drawCircleImage];
    dispatch_async(dispatch_get_main_queue(), ^{
     view.image = image;
    });
});
</code></pre>
<h3 id="4-混合图层用一张镂空的透明图片作遮罩"><a class="header" href="#4-混合图层用一张镂空的透明图片作遮罩">4. 混合图层，用一张镂空的透明图片作遮罩</a></h3>
<pre><code class="language-objc">UIView *parent = [view superview];
UIImageView *cover = [[UIImageView alloc] initWithFrame:CGRectMake(0, 0, imgSize.width, imgSize.height)];
cover.image = [UIImage imageNamed:@&quot;cover&quot;];
[parent addSubview:cover];
cover.center = view.center;
</code></pre>
<h3 id="对比总结"><a class="header" href="#对比总结">对比总结</a></h3>
<ul>
<li>
<p>方法1 设置 layer 的 cornerRadius 的方式设置简单，苹果在 iOS9 上进行了优化，不再需要离屏渲染，性能差别不明显，简单圆角场景下推荐使用；</p>
</li>
<li>
<p>方法2 用贝塞尔曲线 <code>UIBezierPath</code> 作 mask 圆角，使用了矢量并与位图叠加，导致运算量上升，GPU运算量高；</p>
</li>
<li>
<p>方法3 使用 CoreGraphics 重新绘制圆角，基于单张位图运算，比方法2要好，适合位图尺寸很大，数量很多的情况下使用。但要注意内存警告，最好配合缓存机制使用，避免因内存溢出而崩溃；</p>
</li>
<li>
<p>方法4 混合图层，用一张镂空的透明图片作遮罩，基于透明位图，可用于异形遮罩，但需要根据图片大小做多张特殊位图，不是很方便。</p>
</li>
</ul>
<h2 id="ios中的动画方式"><a class="header" href="#ios中的动画方式">iOS中的动画方式</a></h2>
<ol>
<li>
<p>核心动画 Core Animation</p>
</li>
<li>
<p>UIView 动画</p>
</li>
</ol>
<h2 id="uiview-的-animation-和-core-animation-有什么区别"><a class="header" href="#uiview-的-animation-和-core-animation-有什么区别">UIView 的 Animation 和 Core Animation 有什么区别？</a></h2>
<ul>
<li>
<p>区别：</p>
<ul>
<li>核心动画只能添加到 CALayer(图层)，所以不能响应事件</li>
<li>核心动画一切都是假象，并不会改变真实的值;</li>
</ul>
</li>
<li>
<p>使用场景：</p>
<ul>
<li>如果需要与用户交互就使用 UIView 的动画;不需要与用户交互可以使用核心动画;</li>
</ul>
</li>
<li>
<p>Core Animation 使用较多的场景：</p>
<ul>
<li>在转场动画中,核心动画的类型比较多;</li>
<li>根据一个路径做动画,只能用核心动画（帧动画）;</li>
<li>动画组: 同时做多个动画;</li>
</ul>
</li>
</ul>
<h2 id="隐式动画"><a class="header" href="#隐式动画">隐式动画</a></h2>
<p>如果一个 <code>CALayer</code> 对象对应着 <code>UIView</code>，则称这个 Layer 是一个 Root Layer, 非 Root Layer 一般是通过 CALayer 或者其子类直接创建的。所有的非 Root Layer 在设置 Amimation Properties 的时候都存在隐式动画，默认的 duration 是0.25秒。</p>
<h3 id="如何关闭隐式动画"><a class="header" href="#如何关闭隐式动画">如何关闭隐式动画？</a></h3>
<p>可以通过动画事务 <code>CATransaction</code> 进行关闭。<br />
事务（transaction）实际上是Core Animation用来包含一系列属性动画集合的机制，用指定事务去改变可以做动画的图层属性，不会立刻发生变化，而是提交事务时用一个动画过渡到新值。任何 Layer 的可动画属性的设置都属于某个 CATransaction，事务的作用是为了保证多个属性的变化同时进行。事务可以嵌套，当事务嵌套时候，只有最外层的事务 commit 之后，整个动画才开始。</p>
<pre><code class="language-objc">[CATransaction begin];
[CATransaction setDisableActions:YES];

// 有隐式动画的逻辑

[CATransaction commit];
</code></pre>
<h2 id="uiview-在执行动画的过程中如何响应事件"><a class="header" href="#uiview-在执行动画的过程中如何响应事件">UIView 在执行动画的过程中如何响应事件？</a></h2>
<p>UIView 在执行动画的过程中，view 的 frame 只改变的一次，直接改到了最终的frame。比如下面代码，block 中的代码只会调用一次：</p>
<pre><code class="language-objc">[UIView animateWithDuration:2 animations:^{
    CGFloat Y = self.animationView.frame.origin.y + 50;
    self.animationView.frame = CGRectMake(self.animationView.frame.origin.x, Y, 100, 100);
} completion:^(BOOL finished) {
    
}];
</code></pre>
<p>并且，<strong>UIView 在执行动画的过程中不会响应事件</strong>。</p>
<p>想要响应事件可以通过UIView 的 touchesBegan: 方法中判断，有两种方法：</p>
<ol>
<li>通过 CALayer 的 presentationLayer 来访问对应的呈现树图层，presentationLayer 会动画不断变化，判断触发事件的点是否在 presentationLayer 上即可</li>
<li>直接调用 CALayer 的 <code>hitTest:</code> 方法</li>
</ol>
<p>比如下面的代码中，需要在 <code>animationView</code> 执行动画的过程中响应 <code>viweTapAction</code> 事件</p>
<pre><code class="language-objc">@interface ViewController ()

@property (nonatomic, strong) UIView *animationView; // 做动画的 view

@end

@implementation ViewController
- (void)viewDidLoad {
    [super viewDidLoad];
    
    self.animationView = [[UIView alloc] initWithFrame:CGRectMake(100, 100, 100, 100)];
    self.animationView.backgroundColor = [UIColor redColor];
    [self.view addSubview:self.animationView];
    self.animationView.userInteractionEnabled = NO;
}

// 执行动画
- (void)viewAnimationAction {
    // uiview animation 是隐式动画
    // animation 动画过程中不会响应事件
    [UIView animateWithDuration:2 animations:^{
        CGFloat Y = self.animationView.frame.origin.y + 50;
        self.animationView.frame = CGRectMake(self.animationView.frame.origin.x, Y, 100, 100);
    } completion:^(BOOL finished) {
        
    }];
}

// 点击事件，改变 view 的背景色
- (void)viweTapAction {
    self.animationView.backgroundColor = [UIColor colorWithRed:(arc4random()%255)/ 255.f green:(arc4random()%255)/ 255.f blue:(arc4random()%255)/ 255.f alpha:1];
}

@end
</code></pre>
<p>方法1:</p>
<pre><code class="language-objc">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event {
    // 获取到点击的位置
    UITouch *touch = touches.anyObject;
    CGPoint point = [touch locationInView:self.view];
    
    // 判断 redView.layer.presentationLayer 是否包含这个点
    if (CGRectContainsPoint(self.animationView.layer.presentationLayer.frame, point)) {
        [self viweTapAction]; // 响应事件
    }
}
</code></pre>
<p>方法2:</p>
<pre><code class="language-objc">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event {
    // 获取到点击的位置
    UITouch *touch = touches.anyObject;
    CGPoint point = [touch locationInView:self.view];
  
    if ([self.animationView.layer.presentationLayer hitTest:point] != nil) {
        [self viweTapAction]; // 响应事件
    }
}
</code></pre>
<h1 id="参考-2"><a class="header" href="#参考-2">参考</a></h1>
<ul>
<li><a href="https://www.jb51.net/article/154003.htm">iOS设置圆角的4种方法实例（附性能评测）</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ios-中的事件传递和响应者链"><a class="header" href="#ios-中的事件传递和响应者链">iOS 中的事件传递和响应者链</a></h1>
<p><img src="answer/02_uikit/./assets/img/ios_responder.png" alt="" /></p>
<p>事件的生命周期大概为三个阶段：</p>
<ol>
<li>事件的产生</li>
<li>事件的传递</li>
<li>事件的响应</li>
</ol>
<h2 id="事件的产生"><a class="header" href="#事件的产生">事件的产生</a></h2>
<p>苹果注册了一个 Source1 (基于 mach port 的) 用来接收系统事件，其回调函数为 __IOHIDEventSystemClientQueueCallback()。</p>
<p>当一个硬件事件(触摸/锁屏/摇晃等)发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收。这个过程的详细情况可以参考<a href="https://iphonedev.wiki/index.php/IOHIDFamily">这里</a>。SpringBoard 只接收按键(锁屏/静音等)，触摸，加速，接近传感器等几种 Event，随后用 mach port 转发给需要的App进程。随后苹果注册的那个 Source1 就会触发回调，并调用 _UIApplicationHandleEventQueue() 进行应用内部的分发。</p>
<p>_UIApplicationHandleEventQueue() 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture/处理屏幕旋转/发送给 UIWindow 等。通常事件比如 UIButton 点击、touchesBegin/Move/End/Cancel 事件都是在这个回调中完成的。</p>
<h2 id="事件的分类"><a class="header" href="#事件的分类">事件的分类</a></h2>
<p>iOS中的事件可以分为3大类型：</p>
<ul>
<li>触摸事件</li>
<li>加速计事件</li>
<li>远程控制事件</li>
</ul>
<p>这里是关注触摸事件。</p>
<p>在iOS中，并不是任何对象都能处理事件，只有继承了UIResponder的对象才能接受并处理事件，比如：</p>
<ul>
<li>UIApplication</li>
<li>UIViewController</li>
<li>UIView</li>
</ul>
<p>在UIResponder中提供了以下方法来处理触摸事件：</p>
<pre><code class="language-objc">- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event;
- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event;
- (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event;
- (void)touchesCancelled:(NSSet *)touches withEvent:(UIEvent *)event;
</code></pre>
<p>对于触摸事件，iOS中提供了UITouch对象对象，其作为用：</p>
<ul>
<li>保存着跟手指相关的信息，比如触摸的位置、时间、阶段</li>
<li>当手指移动时，系统会更新同一个UITouch对象，使之能够一直保存该手指在的触摸位置</li>
<li>当手指离开屏幕时，系统会销毁相应的UITouch对象</li>
</ul>
<p>比如在UIView的几个touch方法中，就是将UITouch作为参数传递进去的：</p>
<pre><code class="language-objc">- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event

- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event

- (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event


- (void)touchesCancelled:(NSSet *)touches withEvent:(UIEvent *)event
</code></pre>
<p>UITouch的产生为：</p>
<p>当用户用一根手指触摸屏幕时，会创建一个与手指相关的UITouch对象，并且一根手指对应一个UITouch对象。如果两根手指同时触摸一个view，那么view只会调用一次touchesBegan:withEvent:方法，touches参数中装着2个UITouch对象；如果这两根手指一前一后分开触摸同一个view，那么view会分别调用2次touchesBegan:withEvent:方法，并且每次调用时的touches参数中只包含一个UITouch对象。</p>
<h2 id="事件的传递"><a class="header" href="#事件的传递">事件的传递</a></h2>
<ul>
<li>发生触摸事件后，系统会将该事件加入到一个由UIApplication管理的事件队列中。</li>
<li>然后UIApplication会从事件队列中取出最前面的事件，并将事件分发下去以便处理，通常，先发送事件给应用程序的主窗口（keyWindow）。</li>
<li>主窗口keyWindow会在视图层次结构中找到一个最合适的视图来处理触摸事件，这也是整个事件处理过程的第一步。</li>
</ul>
<p>找到合适的视图控件后，就会调用视图控件的touches方法来作具体的事件处理。</p>
<p>也就是说，触摸事件的传递是从父控件传递到子控件，即UIApplication-&gt;window-&gt;寻找处理事件最合适的view的一个过程。</p>
<h3 id="寻找合适的控件来处理事件"><a class="header" href="#寻找合适的控件来处理事件">寻找合适的控件来处理事件</a></h3>
<ol>
<li>首先判断主窗口（keyWindow）自己是否能接受触摸事件</li>
<li>判断触摸点是否在自己身上</li>
<li>子控件数组中从后往前遍历子控件，重复前面的两个步骤</li>
<li>找到view，比如叫做fitView，那么会把这个事件交给这个fitView，再遍历这个fitView的子控件，直至没有更合适的view为止。</li>
<li>如果没有符合条件的子控件，那么就认为自己最合适处理这个事件。</li>
</ol>
<p>比如下面的四个View：白色、红色、蓝色、黄色，其中白色view是UIViewController的view，点击黄色view事件的传递过程为：</p>
<p>UIApplication -&gt; UIWindow -&gt; 白色view（UIViewController的view） -&gt; 红色view -&gt; 蓝色view -&gt; 黄色view</p>
<p><img src="answer/02_uikit/./../../assets/img/station_008.png" alt="" /></p>
<p>找到合适的控件依赖于<code>hitTest:withEvent:</code>和<code>pointInside:withEvent:</code>两个方法：</p>
<pre><code class="language-objc">// recursively calls -pointInside:withEvent:. point is in the receiver's coordinate system
- (nullable UIView *)hitTest:(CGPoint)point withEvent:(nullable UIEvent *)event;

// default returns YES if point is in bounds
- (BOOL)pointInside:(CGPoint)point withEvent:(nullable UIEvent *)event;   

</code></pre>
<h4 id="hittestwithevent-方法"><a class="header" href="#hittestwithevent-方法"><code>hitTest:withEvent:</code> 方法</a></h4>
<ul>
<li>作用：寻找并返回最合适的view。</li>
<li>调用时机：只要事件一传递给一个控件,这个控件就会调用他自己的hitTest：withEvent：方法。不管这个控件能不能处理事件，也不管触摸点在不在这个控件上，事件都会先传递给这个控件，随后再调用hitTest:withEvent:方法</li>
</ul>
<pre><code class="language-objc">- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event{
    // 1. 判断能否接收事件
    if (self.userInteractionEnabled == NO || self.hidden == YES ||  self.alpha &lt;= 0.01) return nil;
    
    // 2. 判断触摸点是否在自身上
    if ([self pointInside:point withEvent:event] == NO) return nil;
    
    // 3. 从后往前遍历子控件数组
    for (int i = (int)self.subviews.count - 1; i &gt;= 0; i--)     {
        UIView *childView = self.subviews[i];
        // 坐标系的转换, 把窗口上的点转换为子控件上的点
        CGPoint childP = [self convertPoint:point toView:childView];
        UIView *fitView = [childView hitTest:childP withEvent:event];
        if (fitView) { // 如果能找到最合适的view
            return fitView;
        }
    }
    
    // 4. 没有找到更合适的view，自己作为最合适处理这个事件的view。
    return self;
}

</code></pre>
<p><img src="https://docs-assets.developer.apple.com/published/7c21d852b9/f17df5bc-d80b-4e17-81cf-4277b1e0f6e4.png" alt="" /></p>
<h4 id="pointinsidewithevent-方法"><a class="header" href="#pointinsidewithevent-方法"><code>pointInside:withEvent:</code> 方法</a></h4>
<p><code>pointInside:withEvent:</code>方法判断点在不在当前view上（方法调用者的坐标系上）如果返回YES，代表点在方法调用者的坐标系上;返回NO代表点不在方法调用者的坐标系上，那么方法调用者也就不能处理事件。</p>
<h2 id="事件的响应"><a class="header" href="#事件的响应">事件的响应</a></h2>
<p>事件从UIApplication-&gt;UIWindow-&gt;寻找处理事件最合适的view传递后，就会调用控件的touches方法来作具体的事件处touchesBegan…touchesMoved…touchedEnded…等。touches 方法就是对事件的响应，事件的响应是顺着响应链向上传递的，这个传递是依赖于UIResponder的nextResponder：</p>
<ul>
<li>UIView ：如果view是VC的root view，则它的nextResponder是 VC；否则是父view</li>
<li>UIViewController ：如果 vc 是window的root vc，则它的nextResponder是 window，否则是父vc</li>
<li>UIWindow：它的nextResponder是UIApplication</li>
<li>UIApplication ：它的nextResponder是app delegate。</li>
</ul>
<p>所以整个事件在找到合适的view之后，判断当前view是否能处理这个事件，如果不能，则顺着nextResponder向父view传递，如果传递到VC也不能处理这个事件，则继续传递到UIWindow，如果window对象也不处理，则其将事件或消息传递给UIApplication对象，如果UIApplication也不能处理该事件或消息，则将其丢弃。其中任何一环能处理事件，则进行时间处理，整个事件的传递就结束了。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1055199-2a49a16e1e483b5c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/603/format/webp" alt="" /></p>
<h2 id="总结-1"><a class="header" href="#总结-1">总结</a></h2>
<p>事件处理的整个流程总结：</p>
<ol>
<li>触摸屏幕产生触摸事件后，触摸事件会被添加到由UIApplication管理的事件队列中（即，首先接收到事件的是UIApplication）。</li>
<li>UIApplication会从事件队列中取出最前面的事件，把事件传递给应用程序的主窗口（keyWindow）。</li>
<li>key window会在视图层次结构中找到一个最合适的视图来处理触摸事件。（至此，第一步已完成)</li>
<li>最合适的view会调用自己的touches方法处理事件</li>
<li>touches默认做法是把事件顺着响应者链条向上抛，即顺着nextResponder向上传递。</li>
</ol>
<p>事件的传递和响应的区别：<br />
事件的传递是从上到下（父控件到子控件），事件的响应是从下到上（顺着响应者链条向上传递：子控件到父控件。</p>
<h1 id="应用"><a class="header" href="#应用">应用</a></h1>
<h2 id="1-扩大按钮的响应区域"><a class="header" href="#1-扩大按钮的响应区域">1. 扩大按钮的响应区域</a></h2>
<p><code>pointInside:withEvent:</code>方法可以判断事件的点是否在当前view上，则可以重写该方法，扩大响应区域。有两种方式：</p>
<ol>
<li>继承自 UIButton 重写该方法</li>
<li>使用分类，在分类中重写该方法。（不建议，因为分类会覆盖本类的实现）</li>
</ol>
<p>代码可参考</p>
<ul>
<li>继承：<a href="https://gist.github.com/liumenghua/568e99957ff0ca226040751e14cff9d0">EnlargeButton</a></li>
<li>分类：<a href="https://gist.github.com/liumenghua/8d12460b933481bb4c333eac04997073">UIButton+Enlarge</a></li>
</ul>
<p>另外，不建议重写<code>hitTest:withEvent:</code>，因为会阻断事件的传递，比如上面的代码改成这样，并且把红色的button扩大较大的热区，则蓝色的button就不能响应事件：</p>
<pre><code class="language-objc">- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event {
    CGRect rect = [self enlargedRect];
    if (CGRectContainsPoint(rect, point)) {
        return self;
    }
    return nil;
}
</code></pre>
<p><img src="answer/02_uikit/./../../assets/img/station_009.png" alt="" /></p>
<h2 id="2-自定事件响应机制"><a class="header" href="#2-自定事件响应机制">2. 自定事件响应机制</a></h2>
<p>1.有一个viewA，viewA有一个subView叫做viewB，要求触摸viewB时,viewB会响应事件，而触摸viewA本身，不会响应该事件。如何实现？</p>
<p>在父View，即viewA中的hitTest:方法中，将自己从合适的view中去除：</p>
<pre><code class="language-objc">- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event{
    UIView *view = [super hitTest:point withEvent:event];
    if (view == self) {
        return nil;
    }
    return view;
}
</code></pre>
<p>2.一个事件多个对象处理</p>
<p>利用 touchs 方法，自己先响应事件，再向上传递</p>
<pre><code class="language-objc">- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event{ 
    // 1.自己先处理事件...
    NSLog(@&quot;do somthing...&quot;);

    // 2.再调用系统的默认做法，再把事件交给上一个响应者处理
    [super touchesBegan:touches withEvent:event]; 
}

</code></pre>
<h1 id="uiview-哪些情况下不能接收触摸事件"><a class="header" href="#uiview-哪些情况下不能接收触摸事件">UIView 哪些情况下不能接收触摸事件?</a></h1>
<p>有三种情况：</p>
<ul>
<li><code>userInteractionEnabled</code> 为 <code>NO</code></li>
<li>隐藏，即 <code>hidden</code> 为 <code>YES</code></li>
<li><code>alpha &lt;= 0.01</code></li>
</ul>
<h1 id="扩大按钮响应区域的方法有哪些"><a class="header" href="#扩大按钮响应区域的方法有哪些">扩大按钮响应区域的方法有哪些？</a></h1>
<ol>
<li>
<p>在 button 上面盖一个蒙层，用蒙层做事件响应</p>
</li>
<li>
<p>重写 UIButton 的 <code>pointInside:withEvent:</code> 方法，扩大响应区域，或者重写<code>hitTest:withEvent:</code>，但不建议，以为会阻断事件的传递。具体见<a href="answer/02_uikit/./102_ans_ch_2_uikit_10.html">iOS 中的事件传递和响应者链</a></p>
</li>
</ol>
<h1 id="手势冲突如何处理"><a class="header" href="#手势冲突如何处理">手势冲突如何处理？</a></h1>
<p>1.修改响应优先级</p>
<p>UIGestureRecognizer类中有两个方法</p>
<pre><code class="language-objc">// 让自身这个手势事件响应优先级低于其它手势事件
// 只是在对于比它响应优先级低的手势调用
- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldBeRequiredToFailByGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer  {
    return YES;
}

// 让自身这个手势事件响应优先级高于其它手势事件
// 只是在对于比它响应优先级高的手势调用
- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldRequireFailureOfGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer {
    return YES;
}
</code></pre>
<p>2.同时响应</p>
<pre><code class="language-objc">// 共存  A手势或者B手势 代理方法里shouldRecognizeSimultaneouslyWithGestureRecognizer   有一个是返回YES，就能共存
- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer {
    return YES;
}
</code></pre>
<h1 id="参考-3"><a class="header" href="#参考-3">参考</a></h1>
<ul>
<li><a href="https://developer.apple.com/documentation/uikit/touches_presses_and_gestures/using_responders_and_the_responder_chain_to_handle_events?language=objc">Using Responders and the Responder Chain to Handle Events</a></li>
<li><a href="https://www.jianshu.com/p/2e074db792ba">史上最详细的iOS之事件的传递和响应机制-原理篇</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="app-1"><a class="header" href="#app-1">APP</a></h1>
<h2 id="app-的生命周期"><a class="header" href="#app-的生命周期">APP 的生命周期</a></h2>
<p>iOS APP 的生命周期包含以下阶段：</p>
<ul>
<li>Not running（未运行状态）：app未启动或者被终止（无论是被系统还是用户）。</li>
<li>Inactive（不活跃状态）：app在前台运行但未接收事件。app只在转换到不同状态时会短暂地保持此状态。进入此状态后，app会很快进入后台（Background）或活动（Active）状态。（打电话时或者下拉通知栏时app会进入此状态）</li>
<li>Active（活动状态）：app在前台运行并且正在接收事件。处于前台的app通常状态就是Active。</li>
<li>Background（后台状态）：app在屏幕上不可见但是正在执行代码，这是后台状态。当用户退出应用后（应该是按home键），系统会将app在挂起（suspend）前短暂地移动到后台（Background）状态。</li>
<li>Suspended（挂起状态）：应用程序在内存中，但不执行代码。系统会挂起在后台（Background）状态的应用程序。系统可能会为了腾出内存空间，将app清除出内存。</li>
</ul>
<p><img src="answer/02_uikit//src/assets/img/station_001.png" alt="" /></p>
<p>UIApplication 提供了对APP的状态管理，可以从其 UIApplicationDelegate 中处理生命周期各个阶段的需要执行的业务，同时也有相应的通知。</p>
<h3 id="生命周期各阶段"><a class="header" href="#生命周期各阶段">生命周期各阶段</a></h3>
<ul>
<li>
<p><strong>APP 启动</strong></p>
<p>iOS APP的入口为mina函数：</p>
<pre><code class="language-objc">int main(int argc, char * argv[]) {
    NSString * appDelegateClassName;
    @autoreleasepool {
        // Setup code that might create autoreleased objects goes here.
        appDelegateClassName = NSStringFromClass([AppDelegate class]);
    }
    return UIApplicationMain(argc, argv, nil,   appDelegateClassName);
}
</code></pre>
<p>main函数执行并返回一个 UIApplicationMain 函数。UIApplicationMain 中会创建一个 UIApplication 的实例，是一个单例，可以通过 <code>[UIApplication sharedApplication]</code> 访问。主线程的 runloop 也是从 main 函数这里开始的：UIApplicationMian中创建了一个和主线程对应的runloop，一直处于消息处理和休息等待的循环，一直到app退出。</p>
</li>
<li>
<p><strong>APP 启动完成 FinishLaunching</strong></p>
<pre><code class="language-objc">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
    // Override point for customization after application launch.
    return YES;
}

// 对应通知
UIKIT_EXTERN NSNotificationName const UIApplicationDidFinishLaunchingNotification;
</code></pre>
</li>
<li>
<p><strong>程序由后台转入前台</strong>:前台是指app为当前手机展示. app首次启动时不会调用该方法</p>
<pre><code class="language-objc">- (void)applicationWillEnterForeground:(UIApplication *)application;

// 对应通知
UIKIT_EXTERN NSNotificationName const UIApplicationWillEnterForegroundNotification;
</code></pre>
</li>
<li>
<p><strong>程序进入活跃状态</strong>
该方法app首次进入就会调用, 由后台转入前台, 也会在 <code>applicationWillEnterForeground</code> 方法之后调用</p>
<pre><code class="language-objc">- (void)applicationDidBecomeActive:(UIApplication *)application;

// 对应通知
UIKIT_EXTERN NSNotificationName const UIApplicationDidBecomeActiveNotification;
</code></pre>
</li>
<li>
<p><strong>程序进入非活跃状态</strong>
比如有电话进来或者锁屏等情况, 此时应用会先进入非活跃状态, 也有可能是程序即将进入后台(进入后台前会先调用)</p>
<pre><code class="language-objc">- (void)applicationWillResignActive:(UIApplication *)application;

// 对应通知
UIKIT_EXTERN NSNotificationName const UIApplicationWillResignActiveNotification;
</code></pre>
</li>
<li>
<p><strong>程序进入后台</strong></p>
<pre><code class="language-objc">- (void)applicationDidEnterBackground:(UIApplication *)application;

// 对应通知
UIKIT_EXTERN NSNotificationName const UIApplicationDidEnterBackgroundNotification; 
</code></pre>
<p>当程序进入后台，很快便会就如挂起状态，在挂起状态下，无法执行任何代码。等到系统内存告急时会被杀死，如果有未完成的任务，可以在该方法下申请延时180s执行代码.</p>
<pre><code class="language-objc">  __block UIBackgroundTaskIdentifier backTaskId;
backTaskId = [application beginBackgroundTaskWithExpirationHandler:^{
    NSLog(@&quot;backgroundTask reaches 0&quot;);
    [application endBackgroundTask:backTaskId];
    backTaskId = UIBackgroundTaskInvalid;
}];
</code></pre>
</li>
<li>
<p><strong>程序即将退出</strong></p>
<pre><code class="language-objc">- (void)applicationWillTerminate:(UIApplication *)application;

// 对应通知
UIKIT_EXTERN NSNotificationName const UIApplicationWillTerminateNotification;
</code></pre>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="uikit-相关算法"><a class="header" href="#uikit-相关算法">UIKit 相关算法</a></h1>
<h2 id="1-找出两个-uiview-的最近的公共父-view如果不存在则输出-nil"><a class="header" href="#1-找出两个-uiview-的最近的公共父-view如果不存在则输出-nil">1. 找出两个 <code>UIView</code> 的最近的公共父 <code>View</code>，如果不存在，则输出 nil。</a></h2>
<p>如果是在不同的Window上，则没有公共父 view。</p>
<ul>
<li>思路：1. 用 set 保存 view1 的所有父view，再遍历 view2 的父view，如果set中有，则为最近父view</li>
<li>复杂度：时间 O(n)， set查找的复杂度为O(1)，空间 O(n)</li>
</ul>
<pre><code class="language-objc">- (UIView *)commonSuperViewFromView1:(UIView *)view1 view2:(UIView *)viwe2 {
    NSSet *view1SuperViews = [self superViews:view1];
    while (viwe2 != nil) {
        if ([view1SuperViews containsObject:viwe2]) return viwe2;
        viwe2 = [viwe2 superview];
    }
    return nil;
}

- (NSSet *)superViews:(UIView *)view {
    if (!view) return nil;
    
    NSMutableSet *set = [NSMutableSet set];
    while (view != nil) {
        [set addObject:view];
        view = [view superview];
    }
    return [set copy];
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="内存基础知识"><a class="header" href="#内存基础知识">内存基础知识</a></h1>
<ol>
<li>
<p>内存中的5大区分别是什么？</p>
</li>
<li>
<p>堆区和栈区的区别？</p>
</li>
<li>
<p>说一下什么是悬垂指针？什么是野指针? </p>
</li>
<li>
<p><code>BAD_ACCESS</code> 在什么情况下出现? </p>
</li>
<li>
<p>什么是深拷贝？什么是浅拷贝？</p>
</li>
<li>
<p>copy 和 mutableCopy 的区别？</p>
</li>
</ol>
<h1 id="ios-内存管理策略"><a class="header" href="#ios-内存管理策略">iOS 内存管理策略</a></h1>
<ol>
<li>
<p>iOS 内存管理有哪些关键字，说一下对这些关键字的理解？</p>
</li>
<li>
<p><code>assign</code> 修饰对象会有什么问题？</p>
</li>
<li>
<p><code>weak</code> 和 <code>assign</code> 的区别？</p>
</li>
<li>
<p><code>weak</code> 的实现原理？</p>
</li>
<li>
<p>delegate 为何要用 <code>weak</code> 修饰?</p>
</li>
<li>
<p><code>block</code> 属性为什么需要用 <code>copy</code> 来修饰？</p>
</li>
<li>
<p>内存管理默认的关键字是什么？</p>
</li>
<li>
<p>nil 和 release 的区别？</p>
</li>
<li>
<p>为什么不要在初始化方法和 dealloc 中使用访问器方法(setter 和 getter)？</p>
</li>
<li>
<p>ObjC 对象在 dealloc 中会做些什么事情？</p>
</li>
<li>
<p><code>NSString</code> 使用 <code>strong</code> 可以吗？<code>NSArray</code> 呢？</p>
</li>
<li>
<p><code>NSNumber</code>、<code>NSString</code>、<code>NSDate</code> 的内存管理? 或者说 Tagged Pointer。</p>
</li>
<li>
<p>iOS 中哪些情况会导致循环引用？如何检测？</p>
</li>
</ol>
<h1 id="arc"><a class="header" href="#arc">ARC</a></h1>
<ol>
<li>
<p>ARC 内存管理的原则？</p>
</li>
<li>
<p>使用自动引用数ARC应该遵循的原则? </p>
</li>
<li>
<p>ARC 的 <code>retainCount</code> 怎么存储的？</p>
</li>
<li>
<p>ARC 在编译时做了哪些工作？在运行时做了哪些工作？ </p>
</li>
</ol>
<h1 id="autoreleasepool"><a class="header" href="#autoreleasepool">AutoreleasePool</a></h1>
<ol>
<li>
<p>简要说一下 <code>@autoreleasepool</code> 的数据结构？</p>
</li>
<li>
<p><code>@autoreleasepool</code> 的释放时机？</p>
</li>
<li>
<p><code>@autoreleasepool</code> 与 <code>NSThread</code>、<code>NSRunLoop</code> 的关系? </p>
</li>
<li>
<p>什么场景需要手动添加 <code>@autoreleasepool</code> ？</p>
</li>
<li>
<p><code>autorelease</code> 对象什么时候释放？</p>
</li>
<li>
<p>访问 <code>__weak</code> 修饰的变量，是否已经被注册在了 <code>@autoreleasePool</code> 中？为什么？</p>
</li>
<li>
<p>为什么已经有了 ARC ,但还是需要 <code>@autoreleasepool</code> 的存在？</p>
</li>
<li>
<p>方法或函数返回一个对象时，会对对象 <code>autorelease</code> 么？为什么？</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="内存基础"><a class="header" href="#内存基础">内存基础</a></h1>
<h2 id="内存中的5大区分别是什么"><a class="header" href="#内存中的5大区分别是什么">内存中的5大区分别是什么？</a></h2>
<ul>
<li><strong>栈区 Stack</strong>：存放函数的参数值、局部变量的值等，从高地址向低地址生长。其操作方式为FIFO，由编译器自动分配释放，不需要程序员管理。</li>
<li><strong>堆区 Heap</strong>：动态内存分配区域，通过 alloc 分配，从高地址向低地址生长。</li>
<li><strong>全局区／静态区 Static</strong>：全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后由系统释放。
<pre><code class="language-c">// 未初始化的
int a;

// 已初始化的
int b = 100;
</code></pre>
</li>
<li><strong>常量区</strong>：常量字符串就是放在这里的。 程序结束后由系统释放。</li>
<li><strong>代码区</strong>：存放函数体的二进制代码。</li>
</ul>
<p><img src="answer/03_memory/./../../assets/img/station_002.png" alt="" /></p>
<ul>
<li>
<p>堆区的内存是应用程序共享的，堆中的内存分配是系统负责的；系统使用一个链表来维护所有已经分配的内存空间（系统仅仅纪录，并不管理具体的内容）；变量使用结束后，需要释放内存，OC中是根据引用计数＝＝0，就说明没有任何变量使用该空间，那么系统将直接收回；</p>
</li>
<li>
<p>当一个app启动后，代码区，常量区，全局区大小已固定，因此指向这些区的指针不会产生崩溃性的错误。而堆区和栈区是时时刻刻变化的（堆的创建销毁，栈的弹入弹出），所以当使用一个指针指向这两个区里面的内存时，一定要注意内存是否已经被释放，否则会产生程序崩溃（也即是野指针报错）。</p>
</li>
</ul>
<h2 id="堆区和栈区的区别"><a class="header" href="#堆区和栈区的区别">堆区和栈区的区别？</a></h2>
<ul>
<li>
<p>申请方式：栈区由系统自动分配，自动释放，无需程序员管理；堆区是动态内存分配区域，由程序员申请和释放。</p>
</li>
<li>
<p>生长方向：栈区从高地址向低地址生长，堆区相反。</p>
</li>
</ul>
<h2 id="什么是悬垂指针什么是野指针"><a class="header" href="#什么是悬垂指针什么是野指针">什么是悬垂指针？什么是野指针?</a></h2>
<ul>
<li>
<p>悬垂指针 Dangling Pointer: 指针指向的内存已经被释放了，但是指针还存在，这就是一个 悬垂指针 或者说 迷途指针</p>
</li>
<li>
<p>野指针 Wild Pointer：没有进行初始化的指针，其实都是野指针</p>
</li>
</ul>
<h2 id="bad_access-在什么情况下出现"><a class="header" href="#bad_access-在什么情况下出现">BAD_ACCESS 在什么情况下出现?</a></h2>
<p>访问了已经被销毁的内存空间，就会报出这个错误。 根本原因是有 悬垂指针 没有被释放。</p>
<h2 id="深拷贝-vs-浅拷贝"><a class="header" href="#深拷贝-vs-浅拷贝">深拷贝 VS 浅拷贝</a></h2>
<ul>
<li>
<p><strong>深拷贝</strong>: 拷贝出来的对象与原对象地址不一致，修改拷贝对象的值对源对象的值没有任何影响。 深拷贝是直接拷贝整个对象内容到另一块内存中。</p>
</li>
<li>
<p><strong>浅拷贝</strong>: 拷贝出来的对象与原对象地址一致，修改拷贝对象的值会直接影响源对象的值。</p>
</li>
</ul>
<p>总结：<strong>浅复制就是指针拷贝；深复制就是内容拷贝</strong></p>
<h3 id="copy-vs-mutablecopy"><a class="header" href="#copy-vs-mutablecopy">copy VS mutableCopy</a></h3>
<ul>
<li>
<p><code>copy</code>: 拷贝出来的对象类型总是不可变类型(例如, NSString, NSArray, NSDictionary等等)</p>
</li>
<li>
<p><code>mutableCopy</code>: 拷贝出来的对象类型总是可变类型(例如, NSMutableString, NSMutableArray, NSMutableDictionary等等)</p>
</li>
</ul>
<p>使用copy/mutableCopy和直接赋值有什么区别？</p>
<p>直接赋值实际上还是同一个对象，如果之前的对象是一个可变结合，将其赋值到一个不可变集合上，对原来集合的操作也是对新的集合的操作，因为本质是一同一个对象。比如</p>
<pre><code class="language-objc">NSMutableArray * arr1 = [NSMutableArray array];
[arr1 addObject:@&quot;A&quot;];

NSArray * arr2 = [NSArray array];
arr2 = arr1;

[arr1 addObject:@&quot;C&quot;];

NSLog(@&quot;arr1 = %@&quot;, arr1); // A,C
NSLog(@&quot;arr2 = %@&quot;, arr2); // A,c
</code></pre>
<p>直接赋值之后，<code>arr1</code> 和 <code>arr2</code> 完全就是同一个对象，指向同一个地址，所以赋值之后再给 <code>arr1</code> 添加对象，实际上也是给 <code>arr2</code> 添加对象。而如果使用copy之后赋值，就是两个完全不一样的对象，后续的操作也不会有影响。</p>
<ul>
<li><code>copy</code>：<strong>如果调用对象是不可变的，则是浅拷贝；如果调用对象是可变的，则是深拷贝</strong>。</li>
<li><code>mutableCopy</code>: 对集合使用 <code>mutableCopy</code> ，<strong>都是深拷贝</strong>。</li>
</ul>
<h3 id="集合内容实现深拷贝"><a class="header" href="#集合内容实现深拷贝">集合内容实现深拷贝</a></h3>
<p>在Foundation框架中，<strong>所有的 collectioon 类在默认的情况下都执行浅拷贝</strong>，也就是说只拷贝容器对象本身，不复制其中的数据。这样做的目的是，<strong>容器内的对象未必都能拷贝，而且调用者也未必想在拷贝容器时一并拷贝其中的某个对象</strong>。</p>
<p>验证：</p>
<pre><code class="language-objc">NSArray *array = @[@&quot;Java&quot;, @&quot;Swift&quot;, @&quot;Objective-C&quot;];
NSLog(@&quot;obj1: %p&quot;, [array firstObject]); // obj1: 0x10b7392a8

NSArray *array2 = [array copy];
NSLog(@&quot;obj1-copy: %p&quot;, [array2 firstObject]); // obj1-copy: 0x10b7392a8

NSMutableArray *array3 = [array mutableCopy];
NSLog(@&quot;obj1-mutableCopy: %p&quot;, [array3 firstObject]); // obj1-mutableCopy: 0x10b7392a8
</code></pre>
<p>可以发现 <code>NSArray</code> 进行 copy 和 mutableCopy 之后和之前，内部的对象都是同一个。同样，<code>NSMutableArray</code> 的结果也一样：</p>
<pre><code class="language-objc">NSMutableArray *array = [NSMutableArray arrayWithObjects:@&quot;Java&quot;, @&quot;Swift&quot;, @&quot;Objective-C&quot;, nil];
NSLog(@&quot;obj1: %p&quot;, [array firstObject]); // obj1: 0x10f6e02a8

NSArray *array2 = [array copy];
NSLog(@&quot;obj1-copy: %p&quot;, [array2 firstObject]); // obj1-copy: 0x10f6e02a8

NSMutableArray *array3 = [array mutableCopy];
NSLog(@&quot;obj1-copy: %p&quot;, [array3 firstObject]); // obj1-copy: 0x10f6e02a8
</code></pre>
<p>集合想要实现深拷贝，有以下方式：</p>
<p>1.使用系统提供的方法，比如 <code>initWithArray:copyItems:</code> 将 flag 设置为YES即可深拷贝。
集合里的每个对象都会收到 copyWithZone: 消息。如果集合里的对象遵循 NSCopying 协议，那么对象就会被深复制到新的集合。如果对象没有遵循 NSCopying 协议，而尝试用这种方法进行深复制，会在运行时出错。</p>
<pre><code class="language-objc">// NSArray
- (instancetype)initWithArray:(NSArray&lt;ObjectType&gt; *)array copyItems:(BOOL)flag;

// NSDictionary
- (instancetype)initWithDictionary:(NSDictionary&lt;KeyType, ObjectType&gt; *)otherDictionary copyItems:(BOOL)flag;

// 使用
NSArray *deepCopyArray=[[NSArray alloc] initWithArray:someArray copyItems:YES];
</code></pre>
<p>2.将集合进行归档(archive)，然后解档(unarchive)</p>
<pre><code class="language-objc">NSArray *trueDeepCopyArray = [NSKeyedUnarchiver unarchiveObjectWithData:[NSKeyedArchiver archivedDataWithRootObject:oldArray]];
</code></pre>
<h1 id="参考-4"><a class="header" href="#参考-4">参考</a></h1>
<ul>
<li><a href="https://liumenghua.github.io/2018/05/17/%E8%B0%88%E8%B0%88Objective-C%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%8B%B7%E8%B4%9D/#%E6%B7%B1%E6%8B%B7%E8%B4%9D-deep-copy-%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D-shallow-copy-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F">谈谈Objective-C的对象拷贝</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ios-内存管理策略-1"><a class="header" href="#ios-内存管理策略-1">iOS 内存管理策略</a></h1>
<h2 id="ios-内存管理有哪些关键字说一下对这些关键字的理解"><a class="header" href="#ios-内存管理有哪些关键字说一下对这些关键字的理解">iOS 内存管理有哪些关键字，说一下对这些关键字的理解？</a></h2>
<ul>
<li>
<p><code>strong</code>: 表示指向并持有该对象，对象的引用计数会加1。该对象只要引用计数不为0就不会被销毁。当然可以通过将变量强制赋值 <code>nil</code> 来进行销毁。</p>
</li>
<li>
<p><code>weak</code>: 表示指向但是并不持有该对象，引用计数也不会加1，是一种弱引用。在 Runtime 中对该属性进行了相关操作，无需处理，可以自动销毁，即置为 nil。<code>weak</code> 用来修饰对象，多用于避免循环引用的地方。<code>weak</code> 不可以修饰基本数据类型。</p>
</li>
<li>
<p><code>assign</code>: 主要用于修饰基本数据类型， 例如 <code>NSInteger</code>，<code>CGFloat</code>，存储在栈中，内存不用程序员管理。<code>assign</code> 是可以修饰对象的，但是会出现问题。如果用assign修饰对象，当对象释放后（因为不存在强引用，离开作用域对象内存可能被回收），指针的地址还是存在的，也就是说指针并没有被置为nil,下次再访问该对象就会造成野指针异常。对象是分配在堆上的，堆上的内存由程序员手动释放。</p>
</li>
<li>
<p><code>copy</code>: <code>copy</code> 和 <code>strong</code> 类似，但会在内存里拷贝一份对象，两个指针指向不同的内存地址。一般用来修饰 <code>NSString</code> 等有对应可变类型的对象，因为他们有可能和对应的可变类型（<code>NSMutableString</code>）之间进行赋值操作，为确保对象中的字符串不被修改 ，应该在设置属性是拷贝一份。而若用 <code>strong</code> 修饰，如果对象在外部被修改了，会影响到属性。</p>
</li>
</ul>
<h2 id="assign-修饰对象会有什么问题"><a class="header" href="#assign-修饰对象会有什么问题"><code>assign</code> 修饰对象会有什么问题？</a></h2>
<p>如果用 <code>assign</code> 修饰对象，当对象释放后（因为不存在强引用，离开作用域对象内存可能被回收），指针的地址还是存在的，也就是说指针并没有被置为 <code>nil</code>,下次再访问该对象就会造成<strong>野指针异常</strong>。对象是分配在堆上的，堆上的内存由程序员手动释放。</p>
<h2 id="weak-和-assign-的区别"><a class="header" href="#weak-和-assign-的区别"><code>weak</code> 和 <code>assign</code> 的区别？</a></h2>
<ul>
<li>
<p><code>weak</code>: <code>weak</code> 是用来修饰对象的，是一种弱引用，并在对象被释放的时候，会自动置为 <code>nil。</code></p>
</li>
<li>
<p><code>assign</code>: <code>assign</code> 用来修饰基础数据类型，这些基础数据类型在栈上分配，不需要程序员手动管理生命周期。如果用 <code>assign</code> 修饰对象，当对象释放后（因为不存在强引用，离开作用域对象内存可能被回收），指针的地址还是存在的，也就是说指针并没有被置为nil,下次再访问该对象就会造成野指针异常。对象是分配在堆上的，堆上的内存由程序员手动释放。</p>
</li>
</ul>
<h2 id="weak-的实现原理"><a class="header" href="#weak-的实现原理">weak 的实现原理</a></h2>
<ul>
<li>
<p>weak的作用：weak 关键字的作用是弱引用，所引用对象的计数器<strong>不会</strong>加1，并在引用对象被释放的时候自动被设置为 nil。</p>
</li>
<li>
<p>weak的原理：底层维护了一张weak_table_t结构的hash表，key是所指对象的地址，value是weak指针的地址数组。</p>
</li>
</ul>
<p>比如下面的代码：</p>
<pre><code class="language-objc">#import &quot;Person.h&quot;
#import &quot;Dog.h&quot;

@interface Person()

@property (nonatomic, weak) Dog *a;

@end
</code></pre>
<p>waek表中的key就是 a 指向 Dog 对象的地址，value就是 a 这个指针的地址。</p>
<h2 id="delegate-为何要用-weak-修饰"><a class="header" href="#delegate-为何要用-weak-修饰">delegate 为何要用 <code>weak</code> 修饰?</a></h2>
<p>在 ARC 环境下，为避免循环引用，往往会把 <code>delegate</code> 属性用 <code>weak</code> 修饰；在 MRC 下使用 <code>assign</code> 修饰。</p>
<h2 id="block-属性为什么需要用-copy-来修饰"><a class="header" href="#block-属性为什么需要用-copy-来修饰"><code>block</code> 属性为什么需要用 <code>copy</code> 来修饰？</a></h2>
<p>因为在 MRC 下，<code>block</code> 在创建的时候，它的内存是分配在栈(stack)上的，而不是在堆(heap)上，可能被随时回收。他本身的作于域是属于创建时候的作用域，一旦在创建时候的作用域外面调用block将导致程序崩溃。通过 <code>copy</code> 可以把 <code>block</code> 从栈上拷贝到堆上，保证 <code>block</code> 的声明域外使用。<strong>在 ARC 下写不写都行，编译器会自动对 <code>block</code> 进行 <code>copy</code> 操作</strong>。</p>
<h2 id="内存管理默认的关键字是什么"><a class="header" href="#内存管理默认的关键字是什么">内存管理默认的关键字是什么？</a></h2>
<ul>
<li>对象类型为：<code>strong</code></li>
<li>基础数据类型为: <code>assign</code></li>
</ul>
<h2 id="nil-和-release-的区别"><a class="header" href="#nil-和-release-的区别">nil 和 release 的区别？</a></h2>
<p>nil是将一个对象的指针置为空，只是切断了指针和内存中对象的联系，并没有释放对象内存；而release才是真正释放对象内存的操作。</p>
<h2 id="为什么不要在初始化方法和-dealloc-中使用访问器方法setter-和-getter"><a class="header" href="#为什么不要在初始化方法和-dealloc-中使用访问器方法setter-和-getter">为什么不要在初始化方法和 dealloc 中使用访问器方法(setter 和 getter)？</a></h2>
<p>在初始化方法和dealloc中，对象的存在与否还不确定，它可能还未初始化完毕，所以给对象发消息可能不会成功，或者导致一些问题的发生。</p>
<ul>
<li>
<p>假如我们在init中使用setter方法初始化实例变量。在init中，我们会调用self = [super init]对父类的东西先进行初始化，即子类先调用父类的init方法（注意： 调用的父类的init方法中的self还是子类对象）。如果父类的init中使用setter方法初始化实例变量，且子类重写了该setter方法，那么在初始化父类的时候就会调用子类的setter方法。而此时只是在进行父类的初始化，子类初始化还未完成，所以可能会发生错误。</p>
</li>
<li>
<p>在销毁子类对象时，首先是调用子类的dealloc，最后调用[super dealloc]（这与init相反）。如果在父类的dealloc中调用了setter方法且该方法被子类重写，就会调用到子类的setter方法，但此时子类已经被销毁，所以这也可能会发生错误。</p>
</li>
</ul>
<h2 id="objc-对象在-dealloc-中会做些什么事情"><a class="header" href="#objc-对象在-dealloc-中会做些什么事情">ObjC 对象在 dealloc 中会做些什么事情？</a></h2>
<ol>
<li>
<p>判断销毁对象前有没有需要处理的东西（如弱引用、关联对象、C++的析构函数、SideTabel的引用计数表等等）；</p>
</li>
<li>
<p>如果没有就直接调用free函数销毁对象；</p>
</li>
<li>
<p>如果有就先调用 object_dispose 做一些释放对象前的处理（置弱引用指针置为nil、移除关联对象、object_cxxDestruct、在SideTabel的引用计数表中擦出引用计数等等），再用free函数销毁对象。</p>
</li>
</ol>
<h2 id="nsstring-使用-strong-可以吗nsarray-呢"><a class="header" href="#nsstring-使用-strong-可以吗nsarray-呢"><code>NSString</code> 使用 <code>strong</code> 可以吗？<code>NSArray</code> 呢？</a></h2>
<p><code>copy</code> 和 <code>strong</code> 类似，但会在内存里拷贝一份对象，两个指针指向不同的内存地址。一般用来修饰 <code>NSString</code> 等有对应可变类型的对象，因为他们有可能和对应的可变类型（<code>NSMutableString</code>）之间进行赋值操作，为确保对象中的字符串不被修改 ，应该在设置属性是拷贝一份。而若用 <code>strong</code> 修饰，如果对象在外部被修改了，会影响到属性。</p>
<p>比如:</p>
<pre><code class="language-objc">@interface ViewController ()

@property (nonatomic, strong) NSString *name;

@end

- (void)viewDidLoad {
    [super viewDidLoad];

    NSMutableString *anotherName = [NSMutableString string];
    [anotherName appendString:@&quot;Swift&quot;];

    self.name = anotherName;
    NSLog(@&quot;self.name: %@&quot;, self.name); // self.name: Swift
    
    [anotherName appendString:@&quot; Java&quot;];
    NSLog(@&quot;self.name: %@&quot;, self.name); // self.name: Swift Java
    NSLog(@&quot;anotherName: %@&quot;, anotherName); // self.name: Swift Java
}
</code></pre>
<p>可见将 <code>NSMutableString</code> 赋值给 <code>NSString</code> 后，它们就是同一个对象了，后续对 <code>NSMutableString</code> 的操作，也就是对 <code>NSString</code> 的操作。
使用 copy 后就就没有问题。</p>
<pre><code class="language-objc">@interface ViewController ()

@property (nonatomic, copy) NSString *name;

@end

- (void)viewDidLoad {
    [super viewDidLoad];

    NSMutableString *anotherName = [NSMutableString string];
    [anotherName appendString:@&quot;Swift&quot;];

    self.name = anotherName;
    NSLog(@&quot;self.name: %@&quot;, self.name); // self.name: Swift
    
    [anotherName appendString:@&quot; Java&quot;];
    NSLog(@&quot;self.name: %@&quot;, self.name); // self.name: Swift
    NSLog(@&quot;anotherName: %@&quot;, anotherName); // self.name: Swift Java
}
</code></pre>
<p>同理，<code>NSArray</code>、<code>NSDictionary</code>等也是容器一样的，它们都有可变版本，用作属性是都采用 <code>copy</code> 修饰。</p>
<h2 id="nsnumbernsstringnsdate-的内存管理-或者说-tagged-pointer"><a class="header" href="#nsnumbernsstringnsdate-的内存管理-或者说-tagged-pointer"><code>NSNumber</code>、<code>NSString</code>、<code>NSDate</code> 的内存管理? 或者说 Tagged Pointer</a></h2>
<h3 id="tagged-pointer"><a class="header" href="#tagged-pointer">Tagged Pointer</a></h3>
<p>为了节省内存和提高执行效率，苹果在64bit程序中引入了 Tagged Pointer 技术，用于优化 <code>NSNumber</code>、<code>NSDate</code>、<code>NSString</code>等小对象的存储。</p>
<p>在引入 Tagged Pointer 技术之前 <code>NSNumber</code> 等对象存储在堆上，<code>NSNumber</code> 的指针中存储的是堆中 <code>NSNumber</code> 对象的地址值。
由于基本数据类型所占的存储空间并不大，比如 NSInteger 在 32 系统上占 4 个字节，64 位系统上占 8 个字节，但是由于 <code>NSNumber</code> 继承自 NSObject ,它有isa指针，加上内存对齐的处理，系统给NSNumber对象分配了 32 个字节内存，存在很大的浪费。</p>
<h3 id="tagged-pointer-原理"><a class="header" href="#tagged-pointer-原理">Tagged Pointer 原理</a></h3>
<p>将小型对象直接在指针上存储数据，不用再开辟堆内存。使用 Tagged Pointer 之后，NSNumber 指针里面存储的数据变成了：Tag + Data，也就是将数据直接存储在了指针中, 当指针不够存储数据时，才会使用动态分配内存的方式来存储数据。
<img src="answer/03_memory//src/assets/img/station_003.png" alt="" /></p>
<h3 id="应用-1"><a class="header" href="#应用-1">应用</a></h3>
<p>以下两段代码的运行会出现什么结果？</p>
<pre><code class="language-objc">    dispatch_queue_t queue = dispatch_get_global_queue(0, 0);
    for (int i = 0; i &lt; 1000; i++) {
        dispatch_async(queue, ^{
            self.name = [NSString stringWithFormat:@&quot;abcdefghij&quot;];
        });
    }
</code></pre>
<pre><code class="language-objc">    dispatch_queue_t queue = dispatch_get_global_queue(0, 0);
    for (int i = 0; i &lt; 1000; i++) {
        dispatch_async(queue, ^{
            self.name = [NSString stringWithFormat:@&quot;abcdefghi&quot;];
        });
    }
</code></pre>
<p>第一段代码会Crash，而第二段却没有问题。分别打印两段代码的 <code>self.name</code> 类型看看：</p>
<ul>
<li>
<p>第一段代码中<code>self.name</code>为<code>__NSCFString</code>类型，其存储在堆上，它是个正常对象，需要维护引用计数的。由于异步并发执行调用 <code>name</code> 的 <code>setter</code> 方法，可能就会有多条线程同时执行 <code>[_name release]</code>，连续<code>release</code>两次就会造成对象的过度释放，导致Crash。</p>
</li>
<li>
<p>第二段代码中为<code>NSTaggedPointerString</code>类型。在<code>objc_release</code>函数中会判断指针是不是<code>TaggedPointer</code>类型，是的话就不对对象进行<code>release</code>操作，也就避免了因过度释放对象而导致的Crash，因为根本就没执行释放操作。</p>
</li>
</ul>
<h3 id="如何判断-tagged-pointer-"><a class="header" href="#如何判断-tagged-pointer-">如何判断 Tagged Pointer ？</a></h3>
<p>通过 Tagged Pointer 标识位：</p>
<ul>
<li>iOS平台，最高有效位是1（第64bit）</li>
<li>Mac平台，最低有效位是1</li>
</ul>
<p>runtime 中的实现，objc-internal.h 文件中：</p>
<pre><code class="language-objc">#if TARGET_OS_OSX &amp;&amp; __x86_64__
    // 64-bit Mac - tag bit is LSB
#   define OBJC_MSB_TAGGED_POINTERS 0
#else
    // Everything else - tag bit is MSB
#   define OBJC_MSB_TAGGED_POINTERS 1
#endif

#if OBJC_MSB_TAGGED_POINTERS
#   define _OBJC_TAG_MASK (1UL&lt;&lt;63)
#else
#   define _OBJC_TAG_MASK 1UL
#endif

static inline bool 
_objc_isTaggedPointer(const void * _Nullable ptr) 
{
    return ((uintptr_t)ptr &amp; _OBJC_TAG_MASK) == _OBJC_TAG_MASK;
}
</code></pre>
<h3 id="总结-2"><a class="header" href="#总结-2">总结</a></h3>
<p>苹果将Tagged Pointer引入，给 64 位系统带来了内存的节省和运行效率的提高。Tagged Pointer通过在其最后一个 bit 位设置一个特殊标记，用于将数据直接保存在指针本身中。<strong>因为Tagged Pointer并不是真正的对象，我们在使用时需要注意不要直接访问其 isa 变量</strong>。</p>
<h1 id="参考-5"><a class="header" href="#参考-5">参考</a></h1>
<ul>
<li><a href="https://juejin.cn/post/6844904101839372295">iOS底层原理：weak的实现原理</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ios-中哪些情况会导致循环引用"><a class="header" href="#ios-中哪些情况会导致循环引用">iOS 中哪些情况会导致循环引用?</a></h1>
<ul>
<li>block 中</li>
<li>delegate 使用 <code>strong</code> </li>
<li><code>NSTimer</code></li>
</ul>
<h2 id="block-中的循环引用"><a class="header" href="#block-中的循环引用">Block 中的循环引用</a></h2>
<p>由于block在copy时都会对block内部用到的对象进行强引用，比如下面的代码：</p>
<pre><code class="language-objc">
@property (nonatomic, copy) TestBlock testBlock;

self.testObject.testBlock = ^{
   [self doSomething]; 
};
</code></pre>
<p>由于将 block 作为 self 的属性，self 持有这个 block，同时在block内部访问量 self，在 ARC 下会将 block copy到堆上，由于block在copy时都会对block内部用到的对象进行强引用，所以 block 也持有了 self，就循环引用了。</p>
<p>结局办法：使用 <code>__weak</code></p>
<pre><code class="language-objc">
@property (nonatomic, copy) TestBlock testBlock;

 __weak typeof(self) weakSelf = self;

self.testObject.testBlock = ^{
   [weakSelf doSomething]; 
};
</code></pre>
<h2 id="delegate-使用-strong"><a class="header" href="#delegate-使用-strong">delegate 使用 <code>strong</code></a></h2>
<p>使用代理的时候，如果用 <code>strong</code> , 则该对象强引用 delegate，外界不能销毁 delegate 对象，会导致循环引用。</p>
<p>解决办法，使用 <code>weak</code></p>
<pre><code class="language-objc">@property (nonatomic, weak) id &lt;MyDelegate&gt; delegate;
</code></pre>
<h2 id="nstimer-中的循环引用"><a class="header" href="#nstimer-中的循环引用"><code>NSTimer</code> 中的循环引用</a></h2>
<p>由于 <code>self</code> 强引用了 <code>timer</code>，同时 <code>timer</code> 的 <code>target</code> 设置成 <code>self</code>，则 <code>timer</code> 也强引用了 <code>self</code>，所以循环引用造成 <code>dealloc</code> 方法根本不会走，<code>self</code> 和 <code>timer</code> 都不会被释放，造成内存泄漏。比如下面的代码：</p>
<pre><code class="language-objc">@interface ViewController ()

@property (nonatomic, strong) NSTimer *timer;

@end

@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];

    self.timer = [NSTimer scheduledTimerWithTimeInterval:1
                                                  target:self
                                                selector:@selector(timerAction)
                                                userInfo:nil
                                                 repeats:YES];
}

- (void)timerAction {
    NSLog(@&quot;timer log&quot;);
}

- (void)dealloc {
    [self.timer invalidate];
    self.timer = nil;
} 

@end
</code></pre>
<h3 id="解决办法"><a class="header" href="#解决办法">解决办法</a></h3>
<p>为什么 timer 循环应用中使用 weak 不能解决呢？<br />
weak 常用在解决的 Block 中的循环引用，对于 timer，将 self 当作参数传入赋值给 target，即使使用的是 weak，实际上访问的还是 self，所以无法解决。</p>
<p><strong>1.合适的时机释放 timer</strong></p>
<p>比如在 <code>viewDidDisappear:</code> 中手动释放 timer，但是不通用，并且很容易忘记。</p>
<pre><code class="language-objc">- (void)viewDidDisappear:(BOOL)animated {
    [super viewDidDisappear:animated];
    
    [self.timer invalidate];
    self.timer = nil;
}
</code></pre>
<p><strong>2.timer使用 block 方式添加 Target-Action</strong><br />
给 <code>NSTimer</code> 添加分类，通过 <code>block</code> 的方式获取 <code>action</code>，实际的 <code>target</code> 设置为 <code>self</code>，即 <code>NSTimer</code> 类。这样在使用 <code>timer</code> 时，由于 <code>target</code> 的改变，就不再有循环引用了。</p>
<p>其实在 iOS 10 之后，Apple 也提供了以 Block 的方式添加定时器任务的 API，原理是一致的：</p>
<pre><code class="language-objc">+ (NSTimer *)timerWithTimeInterval:(NSTimeInterval)interval repeats:(BOOL)repeats block:(void (^)(NSTimer *timer))block API_AVAILABLE(macosx(10.12), ios(10.0), watchos(3.0), tvos(10.0));
</code></pre>
<pre><code class="language-objc">@implementation NSTimer (BlcokTimer)

+ (NSTimer *)bl_scheduledTimerWithTimeInterval:(NSTimeInterval)interval block:(void (^)(void))block repeats:(BOOL)repeats {
    return [self scheduledTimerWithTimeInterval:interval
                                         target:self
                                       selector:@selector(bl_blockSelector:)
                                       userInfo:[block copy]
                                        repeats:repeats];
}

+ (void)bl_blockSelector:(NSTimer *)timer {
    
    void(^block)(void) = timer.userInfo;
    if (block) {
        block();
    }
}
@end

</code></pre>
<p>使用中还需要注意block可能引起的循环引用，所以使用weakSelf：</p>
<pre><code class="language-objc">__weak typeof(self) weakSelf = self;
self.timer = [NSTimer bl_scheduledTimerWithTimeInterval:1 block:^{
     [weakSelf doingSomeThing];
} repeats:YES];
</code></pre>
<p><strong>3.给 self 添加中间件 Proxy</strong><br />
考虑到循环引用的原因，该方案就是需要打破这些相互引用关系，因此添加一个中间件，弱引用self，同时 timer 引用了中间件，这样通过弱引用来解决了相互引用。
一种方案是直接使用 NSObject 作为一个中间类，更好的方案是使用 NSProxy 来实现，因为 NSProxy 相比于 NSObject 来说，在消息转发上效率更高。具体参见<a href="answer/03_memory/./answer/foundation/101_ans_ch_1_foundation_01.html#nsproxy-%E5%92%8C-nsobject-%E7%9A%84%E5%8C%BA%E5%88%AB">NSProxy 和 NSObject 的区别？</a></p>
<p><img src="answer/03_memory/./../../assets/img/station_018.png" alt="" /></p>
<ol>
<li>继承自 NSProxy ，实现消息转发的方法</li>
</ol>
<pre><code class="language-objc">
#import &lt;Foundation/Foundation.h&gt;

@interface MYProxy : NSProxy

@property (weak, nonatomic) id target;

+ (instancetype)proxyWithTarget:(id)target;

@end

#import &quot;MYProxy.h&quot;

@implementation MYProxy

+ (instancetype)proxyWithTarget:(id)target {
    // NSProxy对象不需要调用init，因为它本来就没有init方法
    MYProxy *proxy = [MYProxy alloc];
    proxy.target = target;
    return proxy;
}

- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel {
    return [self.target methodSignatureForSelector:sel];
}

- (void)forwardInvocation:(NSInvocation *)invocation {
    [invocation invokeWithTarget:self.target];
}

@end
</code></pre>
<ol start="2">
<li>使用 Timer 的地方传入中间件</li>
</ol>
<pre><code class="language-objc">#import &quot;ViewController.h&quot;
#import &quot;MYProxy.h&quot;

@interface ViewController ()

@property (strong, nonatomic) NSTimer *timer;

@end

@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];
    
    self.timer = [NSTimer scheduledTimerWithTimeInterval:1.0
                                                  target:[MYProxy proxyWithTarget:self]
                                                selector:@selector(timerTest)
                                                userInfo:nil
                                                 repeats:YES];
}

- (void)timerTest {
    NSLog(@&quot;%s&quot;, __func__);
}

- (void)dealloc {
    NSLog(@&quot;%s&quot;, __func__);
    [self.timer invalidate];
}

@end
</code></pre>
<p><strong>4. 采用 GCD 定时器</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="arc-1"><a class="header" href="#arc-1">ARC</a></h1>
<h2 id="arc-内存管理的原则"><a class="header" href="#arc-内存管理的原则">ARC 内存管理的原则</a></h2>
<ul>
<li>
<p>自己生成的对象，自己持有</p>
</li>
<li>
<p>非自己生成的对象，自己可以持有</p>
</li>
<li>
<p>自己持有的对象不再需要时，需要对其进行释放</p>
</li>
<li>
<p>非自己持有的对象无法释放</p>
</li>
</ul>
<h2 id="使用自动引用数arc应该遵循的原则"><a class="header" href="#使用自动引用数arc应该遵循的原则">使用自动引用数ARC应该遵循的原则?</a></h2>
<ul>
<li>
<p>不能使用 <code>retain、release、retainCount、autorelease。</code></p>
</li>
<li>
<p>不可以使用 <code>NSAllocateObject、NSDeallocateObject</code></p>
</li>
<li>
<p>必须遵守内存管理方法的命名规则。</p>
</li>
<li>
<p>不需要显示的调用 <code>dealloc</code></p>
</li>
<li>
<p>使用 <code>@autoreleasepool</code> 来代替 <code>NSAutoreleasePool</code>。</p>
</li>
<li>
<p>不可以使用区域 <code>NSZone</code>。</p>
</li>
<li>
<p>对象性变量不可以作为 C 语言的结构体成员。</p>
</li>
<li>
<p>显示转换 <code>id</code> 和 <code>void*</code>。</p>
</li>
</ul>
<h2 id="arc-的引用计数-retaincount-怎么存储的"><a class="header" href="#arc-的引用计数-retaincount-怎么存储的">ARC 的引用计数 <code>retainCount</code> 怎么存储的？</a></h2>
<p>分为优化前和优化后，即arm64 架构前后：</p>
<ul>
<li>
<p>在 arm64 架构之前，对象的 isa 是一个指针，存储着Class、Meta-Class对象的内存地址。对象的引用计数都存储在一个叫SideTable结构体的RefCountMap（引用计数表）散列表中。</p>
</li>
<li>
<p>在 arm64 架构之后，isa 是 nonpointer，是一个结构体，则它本身可以存储一些引用计数，它存储了两个引用计数相关的东西：extra_rc和has_sidetable_rc。</p>
<ul>
<li>
<p>extra_rc：里面存储的值是对象本身之外的引用计数的数量，这 19 位如果不够存储，has_sidetable_rc的值就会变为 1；</p>
</li>
<li>
<p>has_sidetable_rc：如果为 1，代表引用计数过大无法存储在isa中，那么超出的引用计数会存储SideTable的RefCountMap中。</p>
</li>
</ul>
</li>
</ul>
<h3 id="sidetable"><a class="header" href="#sidetable">SideTable</a></h3>
<p>SideTable存储在SideTables()中，SideTables()本质也是一个散列表，可以通过对象指针来获取它对应的（引用计数表或者弱引用表）在哪一个SideTable中。在非嵌入式系统下，SideTables()中有 64 个SideTable</p>
<p>所以，查找对象的引用计数表需要经过<strong>两次哈希查找</strong>：</p>
<ol>
<li>
<p>第一次根据当前对象的内存地址，经过哈希查找从SideTables()中取出它所在的SideTable；</p>
</li>
<li>
<p>第二次根据当前对象的内存地址，经过哈希查找从SideTable中的refcnts中取出它的引用计数表。</p>
</li>
</ol>
<pre><code class="language-c">inline uintptr_t 
objc_object::rootRetainCount()
{
    if (isTaggedPointer()) return (uintptr_t)this;

    sidetable_lock();
    isa_t bits = LoadExclusive(&amp;isa.bits);
    ClearExclusive(&amp;isa.bits);
    if (bits.nonpointer) { // 优化后 isa 是 nonpointer
        uintptr_t rc = 1 + bits.extra_rc; // extra_rc 存储引用计数
        if (bits.has_sidetable_rc) { // 引用计数过大，无法用 isa 储存，则 在 RefCountMap 中
            rc += sidetable_getExtraRC_nolock();
        }
        sidetable_unlock();
        return rc;
    }

    sidetable_unlock();
    return sidetable_retainCount();
}
</code></pre>
<h4 id="为什么不是一个sidetable而是使用多个sidetable组成sidetables结构"><a class="header" href="#为什么不是一个sidetable而是使用多个sidetable组成sidetables结构">为什么不是一个SideTable，而是使用多个SideTable组成SideTables()结构？</a></h4>
<p>如果只有一个SideTable，那我们在内存中分配的所有对象的引用计数或者弱引用都放在这个SideTable中，那我们对对象的引用计数进行操作时，为了多线程安全就要加锁，就存在效率问题。
系统为了解决这个问题，就引入 “分离锁” 技术方案，提高访问效率。把对象的引用计数表分拆多个部分，对每个部分分别加锁，那么当所属不同部分的对象进行引用操作的时候，在多线程下就可以并发操作。所以，使用多个SideTable组成SideTables()结构。</p>
<h2 id="arc-在编译时做了哪些工作"><a class="header" href="#arc-在编译时做了哪些工作">ARC 在编译时做了哪些工作？</a></h2>
<p>根据代码执行的上下文语境，在适当的位置插入 <code>retain</code>，<code>release</code></p>
<h2 id="arc-在运行时做了哪些工作"><a class="header" href="#arc-在运行时做了哪些工作">ARC 在运行时做了哪些工作？</a></h2>
<ul>
<li>
<p>主要是指 weak 关键字。weak 修饰的变量能够在引用计数为0 时被自动设置成 nil，显然是有运行时逻辑在工作的。</p>
</li>
<li>
<p>为了保证向后兼容性，ARC 在运行时检测到类函数中的 autorelease 后紧跟其后 retain，此时不直接调用对象的 autorelease 方法，而是改为调用 objc_autoreleaseReturnValue。 objc_autoreleaseReturnValue 会检视当前方法返回之后即将要执行的那段代码，若那段代码要在返回对象上执行 retain 操作，则设置全局数据结构中的一个标志位，而不执行 autorelease 操作，与之相似，如果方法返回了一个自动释放的对象，而调用方法的代码要保留此对象，那么此时不直接执行 retain ，而是改为执行 objc_retainAoutoreleasedReturnValue函数。此函数要检测刚才提到的标志位，若已经置位，则不执行 retain 操作，设置并检测标志位，要比调用 autorelease 和retain 更快。</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="autoreleasepool-1"><a class="header" href="#autoreleasepool-1">AutoreleasePool</a></h1>
<h2 id="简要说一下-autoreleasepool-的数据结构"><a class="header" href="#简要说一下-autoreleasepool-的数据结构">简要说一下 <code>@autoreleasepool</code> 的数据结构？</a></h2>
<p>当使用 <code>@autoreleasepool{}</code> 来使用一个 AutoreleasePool，随后编译器将其改写成下面的样子：</p>
<pre><code class="language-objc">void *context = objc_autoreleasePoolPush();

// {}中的代码

objc_autoreleasePoolPop(context);
</code></pre>
<p><code>objc_autoreleasePoolPush()</code> 和 <code>objc_autoreleasePoolPop()</code> 而这两个函数都是对 <code>AutoreleasePoolPage</code> 的简单封装，所以自动释放机制的核心就在于这个类:</p>
<ul>
<li>
<p><code>AutoreleasePoolPage</code> 是一个 C++ 实现的类 , AutoreleasePool 并没有单独的结构，而是由若干个 <code>AutoreleasePoolPage</code> 以<strong>双向链表</strong>的形式组合而成（每张链表用 <code>parent</code> 指针和 <code>child</code> 指针头尾相接）</p>
</li>
<li>
<p>AutoreleasePool 是按<strong>线程一一</strong>对应的（结构中的 <code>thread</code> 指针指向当前线程）</p>
</li>
<li>
<p><code>AutoreleasePoolPage</code> 每个对象会开辟4096字节内存（也就是虚拟内存一页的大小），除了上面的实例变量所占空间，剩下的空间全部用来储存 <code>autorelease</code> 对象的地址</p>
</li>
<li>
<p>每创建一个池子，会在首部创建一个 <strong>哨兵</strong> 对象(<code>POOL_BOUNDARY</code>), 作为标记，指向栈顶最新 push 进来的 <code>autorelease</code> 对象的下一个位置</p>
</li>
<li>
<p>一个 <code>AutoreleasePoolPage</code> 的空间被占满时，会新建一个新的 <code>AutoreleasePoolPage</code> 对象，池子的顶端的 <code>next</code> 指针连接链表，后来的 autorelease 对象在新的 page 加入</p>
</li>
<li>
<p>调用 pop 方法释放 pool 中的对象时，传入一个 <code>POOL_BOUNDARY</code> 的内存地址会从最后一个入栈的对象开始发送 <code>release</code> 消息，直到遇到这个 <code>POOL_BOUNDARY</code></p>
</li>
</ul>
<pre><code class="language-c++">class AutoreleasePoolPage  {
    magic_t const magic;
    id *next;
    pthread_t const thread; // 和线程一一对应
    AutoreleasePoolPage * const parent;
    AutoreleasePoolPage *child;
    uint32_t const depth;
    uint32_t hiwat;
}
</code></pre>
<p>下图中 ... 部分就是用来存放 <code>autorelease</code> 对象：
<img src="answer/03_memory/./../../assets/img/station_019.png" alt="" /></p>
<h2 id="autoreleasepool-的释放时机"><a class="header" href="#autoreleasepool-的释放时机"><code>@autoreleasepool</code> 的释放时机？</a></h2>
<h3 id="autoreleasepool-在主线程上的释放时机"><a class="header" href="#autoreleasepool-在主线程上的释放时机">autoreleasepool 在主线程上的释放时机</a></h3>
<p>App 启动后，苹果在主线程 RunLoop 里注册了两个 Observer，其回调都是 <code>_wrapRunLoopWithAutoreleasePoolHandler()</code>。</p>
<ul>
<li>
<p>第一个 Observer 监视的事件是 Entry(即将进入Loop)，其回调内会调用 <code>_objc_autoreleasePoolPush()</code> 创建自动释放池。其 order 是 -2147483647，<strong>优先级最高，保证创建释放池发生在其他所有回调之前</strong>。</p>
</li>
<li>
<p>第二个 Observer 监视了两个事件： </p>
<ul>
<li>BeforeWaiting(准备进入休眠) 时调用 <code>_objc_autoreleasePoolPop()</code> 和 <code>_objc_autoreleasePoolPush()</code> 释放旧的池并创建新池；</li>
<li>Exit(即将退出Loop) 时调用 <code>_objc_autoreleasePoolPop()</code> 来释放自动释放池。这个 Observer 的 order 是 2147483647，<strong>优先级最低，保证其释放池子发生在其他所有回调之后</strong>。</li>
</ul>
</li>
</ul>
<p>在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被 RunLoop 创建好的 AutoreleasePool 环绕着，所以不会出现内存泄漏，开发者也不必显示创建 Pool 了。</p>
<h3 id="autoreleasepool-在子线程上的释放时机"><a class="header" href="#autoreleasepool-在子线程上的释放时机">autoreleasepool 在子线程上的释放时机</a></h3>
<p>首先子线程默认不开启 RunLoop 。但是每一个线程都会维护自己的 Autoreleasepool 对象，所以子线程虽然默认没有开启 RunLoop，但是依然存在AutoreleasePool，在子线程退出的时候会去释放 <code>autorelease</code> 对象。
所以，一般情况下，子线程中即使我们不手动添加自动释放池，也不会产生内存泄漏。</p>
<h2 id="autoreleasepool-与线程nsrunloop-的关系"><a class="header" href="#autoreleasepool-与线程nsrunloop-的关系"><code>@autoreleasepool</code> 与线程、<code>NSRunLoop</code> 的关系?</a></h2>
<h3 id="runloop-和-线程-的关系"><a class="header" href="#runloop-和-线程-的关系">RunLoop 和 线程 的关系</a></h3>
<ol>
<li>
<p>RunLoop 与线程是一一对应关系，每个线程(包括主线程)都有一个对应的RunLoop对象；其对应关系保存在一个全局的 <code>Dictionary</code> 里, 线程是 key，runloop 是 value；</p>
</li>
<li>
<p>主线程的 RunLoop 默认由系统自动创建并启动；而其他线程在创建时并没有 RunLoop，若该线程一直不主动获取，就一直不会有 RunLoop；（懒加载）</p>
</li>
<li>
<p>苹果不提供直接创建 RunLoop 的方法；所谓其他线程 Runloop 的创建其实是发生在第一次获取的时候，系统判断当前线程没有 RunLoop 就会自动创建；
当前线程结束时，其对应的 Runloop 也被销毁；</p>
</li>
</ol>
<h3 id="autoreleasepool-和-runloop-的关系"><a class="header" href="#autoreleasepool-和-runloop-的关系"><code>@autoreleasepool</code> 和 RunLoop 的关系</a></h3>
<p>App 启动后，苹果在主线程 RunLoop 里注册了两个 Observer，其回调都是 <code>_wrapRunLoopWithAutoreleasePoolHandler()</code>。</p>
<ul>
<li>
<p>第一个 Observer 监视的事件是 Entry(即将进入Loop)，其回调内会调用 <code>_objc_autoreleasePoolPush()</code> 创建自动释放池。其 order 是 -2147483647，<strong>优先级最高，保证创建释放池发生在其他所有回调之前</strong>。</p>
</li>
<li>
<p>第二个 Observer 监视了两个事件： </p>
<ul>
<li>BeforeWaiting(准备进入休眠) 时调用 <code>_objc_autoreleasePoolPop()</code> 和 <code>_objc_autoreleasePoolPush()</code> 释放旧的池并创建新池；</li>
<li>Exit(即将退出Loop) 时调用 <code>_objc_autoreleasePoolPop()</code> 来释放自动释放池。这个 Observer 的 order 是 2147483647，<strong>优先级最低，保证其释放池子发生在其他所有回调之后</strong>。</li>
</ul>
</li>
</ul>
<p>在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被 RunLoop 创建好的 AutoreleasePool 环绕着，所以不会出现内存泄漏，开发者也不必显示创建 Pool 了。</p>
<h3 id="autoreleasepool-和线程的关系"><a class="header" href="#autoreleasepool-和线程的关系"><code>@autoreleasepool</code> 和线程的关系</a></h3>
<p>AutoreleasePool 是按线程一一对应的（结构中的 thread 指针指向当前线程）。新的自动释放池被创建的时候，它们会被添加到栈的顶部，而当池子销毁的时候，会从栈移除。对于当前线程来说，Autoreleased对象会被放到栈顶的自动释放池中。当一个线程线程停止，它会自动释放掉与其关联的所有自动释放池。</p>
<h2 id="什么场景需要手动添加-autoreleasepool-"><a class="header" href="#什么场景需要手动添加-autoreleasepool-">什么场景需要手动添加 <code>@autoreleasepool</code> ？</a></h2>
<p>Apple 官方文档<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmAutoreleasePools.html#//apple_ref/doc/uid/20000047">Advanced Memory Management Programming Guide</a>列举了三种需要手动添加 <code>@autoreleasepool</code> 的情况</p>
<ul>
<li>
<p>编写的不是基于UI框架的程序，例如命令行工具；</p>
</li>
<li>
<p>通过循环方式创建大量临时对象，比如循环创建很多个 image 临时对象</p>
<pre><code class="language-objc">for (int i = 0; i &lt; 1000000; i++) {
    UIImage *img = [[UIImage alloc] init];
    
    // doing something
}
</code></pre>
<p><code>img</code> 因为离开作用域所以会被加入最近一次创建的自动释放池中，而这个释放池就是主线程上的 RunLoop 管理的；因为for循环在当前线程没有执行完毕。Runloop也就没有完成当前这一次的迭代，所以导致大量对象被延时释放。
值得注意的是使用容器的block版本的枚举器时，内部会自动添加一个AutoreleasePool：</p>
<pre><code class="language-objc">[array enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) {
    // 这里被一个局部@autoreleasepool包围着
}];
</code></pre>
</li>
<li>
<p>使用非Cocoa程序创建的子线程；</p>
</li>
</ul>
<h2 id="autorelease-对象什么时候释放"><a class="header" href="#autorelease-对象什么时候释放"><code>autorelease</code> 对象什么时候释放？</a></h2>
<p>在没有手加 Autorelease Pool的情况下，autorelease 对象是在当前的runloop迭代结束时释放的，而它能够释放的原因是系统在每个runloop迭代中都加入了自动释放池Push和Pop</p>
<h2 id="访问-__weak-修饰的变量是否已经被注册在了-autoreleasepool-中为什么"><a class="header" href="#访问-__weak-修饰的变量是否已经被注册在了-autoreleasepool-中为什么">访问 <code>__weak</code> 修饰的变量，是否已经被注册在了 <code>@autoreleasePool</code> 中？为什么？</a></h2>
<p>答案是肯定的，<code>__weak</code> 修饰的变量属于弱引用，如果没有被注册到 <code>@autoreleasePool</code> 中，创建之后也就会随之销毁，为了延长它的生命周期，必须注册到 <code>@autoreleasePool</code> 中，以延缓释放。</p>
<h2 id="为什么已经有了-arc-但还是需要-autoreleasepool-的存在"><a class="header" href="#为什么已经有了-arc-但还是需要-autoreleasepool-的存在">为什么已经有了 ARC ,但还是需要 <code>@autoreleasepool</code> 的存在？</a></h2>
<p>避免内存峰值，及时释放不需要的内存空间。</p>
<h2 id="方法或函数返回一个对象时会对对象-autorelease-么为什么"><a class="header" href="#方法或函数返回一个对象时会对对象-autorelease-么为什么">方法或函数返回一个对象时，会对对象 <code>autorelease</code> 么？为什么？</a></h2>
<p>会 ，为了延长返回对象的生命周期，给其他使用者留足调用的时间。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="objective-c-对象"><a class="header" href="#objective-c-对象">Objective-C 对象</a></h1>
<ol>
<li>
<p>一个 NSObject 对象占用多少内存？</p>
</li>
<li>
<p>ObjC 中有几种类型的对象？</p>
</li>
<li>
<p>对象的 <code>isa</code> 指针指向哪里？</p>
</li>
<li>
<p>ObjC 的类信息存放在哪里？</p>
</li>
<li>
<p>Selector, Method 和 IMP 的区别与联系？</p>
</li>
<li>
<p>为什么需要在初始化方法中调用 <code>self = [super init]</code> ？</p>
</li>
<li>
<p>下面的代码输出什么？</p>
<pre><code class="language-objc">@implementation Son : Father
- (id)init {
	self = [super init];
	if (self) {
		NSLog(@&quot;%@&quot;, NSStringFromClass([self class]));
		NSLog(@&quot;%@&quot;, NSStringFromClass([super class]));
	}
	return self;
}
@end	
</code></pre>
</li>
</ol>
<h1 id="category"><a class="header" href="#category">Category</a></h1>
<ol>
<li>
<p>Category 的使用场合是什么？</p>
</li>
<li>
<p>Category 的实现原理 </p>
</li>
<li>
<p>Category 在编译过后，是在什么时机与原有的类合并到一起的? </p>
</li>
<li>
<p>Category 和 Class Extension 的区别是什么？</p>
</li>
<li>
<p>Category 中有 load 方法吗？load 方法是什么时候调用的？load 方法能继承吗？</p>
</li>
<li>
<p>load、initialize 方法的区别什么？它们在 category 中的调用的顺序？以及出现继承时他们之间的调用过程？</p>
</li>
<li>
<p>Category 能否添加成员变量？如果可以，如何给 Category 添加成员变量？</p>
</li>
<li>
<p>关联对象以什么形式进行存储？关联对象的生命周期如何管理？</p>
</li>
<li>
<p>关联对象是线程安全的么？</p>
</li>
<li>
<p>Apple 为什么不把关联对象实现的成员变量添加到类的结构中去，而是单独的提供一个关联对象 manager 来存储和管理？</p>
</li>
</ol>
<h1 id="runtime"><a class="header" href="#runtime">Runtime</a></h1>
<ol>
<li>
<p>如何理解Objective-C的动态性？/为什么说 Objective-C 是一门动态的语言？</p>
</li>
<li>
<p>在 Obj-C 中为什么叫发消息而不叫函数调用？</p>
</li>
<li>
<p>说一下 Runtime 的方法调用流程，即消息发送、方法解析、消息转发? </p>
</li>
<li>
<p>NSInvocation 和 NSMethodSignature 是什么？</p>
</li>
<li>
<p>类的方法缓存存储在哪？是先缓存还是先调用？</p>
</li>
<li>
<p>runtime 在项目中的应用？</p>
</li>
<li>
<p>如何运用 Runtime 字典转模型？进行模型的归解档？</p>
</li>
<li>
<p>说一下 Runtime 的方法缓存？存储的形式、数据结构以及查找的过程？</p>
</li>
<li>
<p>是否了解 Type Encoding? </p>
</li>
<li>
<p>Objective-C 如何实现多重继承？</p>
</li>
<li>
<p>说一下 Method Swizzling? 说一下在实际开发中你在什么场景下使用过?</p>
</li>
<li>
<p><code>@synthesize</code> 和 <code>@dynamic</code> 关键字？</p>
</li>
<li>
<p><code>_cmd</code> 关键字的作用？</p>
</li>
<li>
<p><code>isMemberOfClass</code> 和 <code>isKindOfClass</code> 的区别？</p>
</li>
</ol>
<h1 id="应用-2"><a class="header" href="#应用-2">应用</a></h1>
<ol>
<li>如何只hook某些个特定实例，对其他的不影响？</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nsobject-对象"><a class="header" href="#nsobject-对象">NSObject 对象</a></h1>
<h2 id="一个-nsobject-对象占用多少内存"><a class="header" href="#一个-nsobject-对象占用多少内存">一个 NSObject 对象占用多少内存?</a></h2>
<p>系统分配了16个字节给 NSObject对象（通过 <code>malloc_size</code> 函数获得）。但 NSObject 对象内部只使用了8个字节的空间，用于存放 <code>isa</code> 指针（64bit环境下，可以通过 <code>class_getInstanceSize</code> 函数获得）</p>
<pre><code class="language-objc">#import &lt;malloc/malloc.h&gt;
NSLog(@&quot;%zd&quot;, malloc_size((__bridge const void *)obj)); // 16
</code></pre>
<pre><code class="language-objc">#import &lt;objc/runtime.h&gt;
NSLog(@&quot;%zd&quot;, class_getInstanceSize([NSObject class])); // 8 
</code></pre>
<h3 id="自定义对象的内存布局"><a class="header" href="#自定义对象的内存布局">自定义对象的内存布局</a></h3>
<p>Objective-C 对象最小分配的内存为 16，所以自定义对象的内存一定是16的倍数。</p>
<p>1.比如只有两个 int 成员变量，由于分别占用4个字节，加上 isa 指针的8个字节，刚好够 NSObject 分配的 8 个字节，则这个Student占用16个字节。</p>
<pre><code class="language-objc">@interface Student : NSObject {
@public
    int _no;
    int _age;
}
@end
</code></pre>
<p>2.比如有三个 int 成员变量，分别占用4个字节，加上 isa 指针的8个字节，则为20个字节，由于16个字节不够，则分配32个字节。</p>
<pre><code class="language-objc">@interface Student : NSObject {
@public
    int _no;
    int _age;
    int _height;
}
@end
</code></pre>
<h2 id="objc-中有几种类型的对象"><a class="header" href="#objc-中有几种类型的对象">ObjC 中有几种类型的对象？</a></h2>
<ol>
<li>
<p>instance 对象 (实例对象)</p>
</li>
<li>
<p>class 对象 （类对象）</p>
</li>
<li>
<p>meta-class 对象 (元类对象)</p>
</li>
</ol>
<h3 id="instance-对象-实例对象"><a class="header" href="#instance-对象-实例对象">instance 对象 (实例对象)</a></h3>
<p><code>alloc</code> 出来的对象, 每次调用 <code>alloc</code> 方法都会产生新的 instance 对象，比如下面两句代码，产生了 <code>obj1</code> 和 <code>obj2</code> 两个不同的 NSObject 的 instance 对象，分占据着不同的内存。</p>
<pre><code class="language-objc">NSObject *obj1 = [[NSObject alloc] init];
NSObject *obj2 = [[NSObject alloc] init];
</code></pre>
<p>在 instance 对象的内存中存储的信息包括 <code>isa</code> 指针和其他成员变量（<strong>注意 instance 对象的内存中不存储方法</strong>）：</p>
<ul>
<li>isa 指针（也是成员变量）</li>
<li>其他成员变量</li>
</ul>
<h3 id="class-对象类对象"><a class="header" href="#class-对象类对象">class 对象（类对象）</a></h3>
<p>同一个类的类对象是唯一的。类对象永远存储只需要一份的东西（比如方法）。class 对象在内存中存储的信息主要包括：</p>
<ul>
<li><code>isa</code> 指针</li>
<li><code>superclass</code> 指针</li>
<li>类的属性信息（<code>@property</code>）、类的对象方法信息（instance method）</li>
<li>类的协议信息（<code>@protocol</code>）、类的成员变量信息（ivar）</li>
</ul>
<p>有多种获取 class 对象的方式：</p>
<ul>
<li>
<p>instance 对象 调用 class 方法（instance 方法）获取的就是 class 对象，如下代码，获取obj1 的 class 对象：</p>
<pre><code class="language-objc">NSObject *obj1 = [[NSObject alloc] init]; // obj1 为 instance 对象
Class objClass1 = [obj1 class]; // objClass1 为 class 对象
</code></pre>
</li>
<li>
<p>调用 <code>object_getClass</code> 函数 也可以获取 class 对象</p>
<pre><code class="language-objc">Class objClass2 = object_getClass(obj1);
</code></pre>
</li>
<li>
<p>Objective-C 类直接调用 class （class 方法）方法，也可以获取到 class 对象:</p>
<pre><code class="language-objc">Class objClass3 = [NSObject class];
</code></pre>
</li>
</ul>
<h3 id="meta-class-对象-元类对象"><a class="header" href="#meta-class-对象-元类对象">meta-class 对象 (元类对象)</a></h3>
<p>meta-class 是用来描述class的，每个类在内存中也只有一个meta-class 对象，其存储的信息主要包括：</p>
<ul>
<li><code>isa</code> 指针</li>
<li><code>superclass</code> 指针</li>
<li>类的类方法信息（class method）</li>
</ul>
<p>可以通过 runtime 的API获取 meta-class 对象：</p>
<pre><code class="language-objc">// 将类对象当做参数传入，获得元类对象
Class objectMetaClass = object_getClass([NSObject class]);
</code></pre>
<h2 id="对象的-isa-指针指向哪里"><a class="header" href="#对象的-isa-指针指向哪里">对象的 <code>isa</code> 指针指向哪里？</a></h2>
<p>ObjC 中给对象发送消息转换到底层都是走一个objc_msgSend方法，比如</p>
<p>1.instance 对象发送消息</p>
<pre><code class="language-objc">Person *person = [[Person alloc] init];
[person personInstanceMethod]; // instance对象调用instance方法

// 转换到底层为：
objc_msgSend(person, @selector(personInstanceMethod));
</code></pre>
<p>2.class 对象发送消息：</p>
<pre><code class="language-objc">[Person personClassMethod]; // class 对象调用 class 方法

// 转换到底层为：
objc_msgSend([Person class], @selector(personClassMethod))
</code></pre>
<p>但是 instance 对象中不存储方法，instance 方法存储在 class 对象中，而 class 对象中又不存储 class 方法，class方法存储在 meta-class 对象中，这三者实际上就是通过 <code>isa</code> 指针联系起来的：</p>
<ul>
<li>
<p>instance 对象的 <code>isa</code> 指针指向 class 对象</p>
<p>当调用 instance 方法时，通过 instance 对象的 isa 指针找到 class 对象，最后找到 instance 方法的实现进行方法调用</p>
</li>
<li>
<p>class 对象的 <code>isa</code> 指针指向 meta-class 对象</p>
<p>当调用 class 方法时，通过 class 对象的 <code>isa</code> 指针找到 meta-class 对象，最后在找到 class 方法的实现进行方法调用</p>
</li>
</ul>
<h2 id="objc-的类信息存放在哪里"><a class="header" href="#objc-的类信息存放在哪里">ObjC 的类信息存放在哪里？</a></h2>
<ul>
<li>
<p>对象方法、属性、成员变量、协议等存放在 Class 对象中。</p>
</li>
<li>
<p>类方法存放在 meta-class 对象中。</p>
</li>
</ul>
<h2 id="selector-method-和-imp-的区别与联系"><a class="header" href="#selector-method-和-imp-的区别与联系">Selector, Method 和 IMP 的区别与联系？</a></h2>
<ul>
<li>
<p>Selector 是选择子，类型为 <code>SEL</code> ，是 runtime 期间的标识符，<strong>实际上是一个C的字符串，在类加载的时候编译器会生成与方法相对应的选择子，然后注册到Runtime 的运行时系统中</strong>。</p>
</li>
<li>
<p>IMP 是函数指针，表示函数执行的入口，<code>typedef id (*IMP)(id, SEL, ...)</code>，第一个参数表示消息的接受者，第二个参数表示方法的选择子</p>
</li>
<li>
<p>Method 是一个结构体指针，包含了 <code>method_name</code>、<code>method_types</code> 和 <code>method_imp</code> ，分别存储方法名、方法的参数类型和返回值、指向方法实现的指针</p>
</li>
</ul>
<p>类拥有一个分发表，运行期间，利用runtime运行时分发消息，在表中的每一个实体代表一个方法，即method，名称是selector（本质上是字符串），对应的实现为imp</p>
<h2 id="为什么需要在初始化方法中调用-self--super-init-"><a class="header" href="#为什么需要在初始化方法中调用-self--super-init-">为什么需要在初始化方法中调用 <code>self = [super init]</code> ？</a></h2>
<ul>
<li>
<p><code>self</code> 和 <code>super</code>：<code>self</code> 是对象指针，指向当前消息接收者。super 是编译器指令，向 <code>super</code> 发送的消息被编译成 <code>objc_msgSendSuper</code>，但仍以 <code>self</code> 作为<code>reveiver</code>。
比如下面的代码中 Dog 继承自 Animal，在 Dog 的 init 中调用 <code>[super init]</code>，在 Animal 中的 init 方法中，self 实际上是 Dog，因为它是消息的接收者</p>
<pre><code class="language-objc">@interface Animal : NSObject
@property (nonatomic, copy) NSString *name;
@end

@implementation Animal

- (instancetype)init {
    self = [super init];
    if (self) {
        NSLog(@&quot;%@&quot;, self); // &lt;Dog: 0x6000035fc1e0&gt;
    }
    return self;
}

@end
</code></pre>
<pre><code class="language-objc">@interface Dog : Animal
@end
@implementation Dog

- (instancetype)init {
    self = [super init];
    if (self) {
        _name = @&quot;Dog Jack&quot;;
    }
    return self;
}
@end
</code></pre>
</li>
<li>
<p>调用 <code>[super init]</code>：是子类去调用父类的 <code>init</code> 方法，完成父类的初始化工作。并且需要注意的是，在父类初始化过程中的 self 也是子类。</p>
</li>
<li>
<p>执行 <code>self = [super init]</code>：如果父类初始化成功，接下来进行子类的初始化；如果父类初始化失败，则 <code>[super init]</code> 返回为 <code>nil</code> 并赋值给 <code>self</code> ，接下来 <code>if (self)</code> 中的代码将不会被执行，子类的 <code>init</code> 也返回为 <code>nil</code> 。这样可以<strong>防止父类初始化失败而返回一个不可用的对象</strong>。</p>
</li>
</ul>
<h2 id="下面的代码输出什么"><a class="header" href="#下面的代码输出什么">下面的代码输出什么？</a></h2>
<pre><code class="language-objc">@implementation Son : Father
- (id)init {
	self = [super init];
	if (self) {
		NSLog(@&quot;%@&quot;, NSStringFromClass([self class]));
		NSLog(@&quot;%@&quot;, NSStringFromClass([super class]));
	}
	return self;
}
@end	
</code></pre>
<p>答案：都是Son 
因为 <code>super</code> 为编译器标示符，向 <code>super</code> 发送的消息被编译成 <code>objc_msgSendSuper</code>，但仍以 <code>self</code> 作为<code>reveiver</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="category-1"><a class="header" href="#category-1">Category</a></h1>
<h2 id="category-的使用场合是什么"><a class="header" href="#category-的使用场合是什么">Category 的使用场合是什么？</a></h2>
<ul>
<li>
<p>可以把类的实现分开在几个不同的文件里面,这样做有几个显而易见的好处。</p>
<ol>
<li>可以减少单个文件的体积。</li>
<li>可以把不同的功能组织到不同的 category 里。</li>
<li>可以由多个开发者共同完成一个类。</li>
<li>可以按需加载想要的 category。</li>
</ol>
</li>
<li>
<p>声明私有方法。
比如在父类中，该方法是私有的，但是想在子类中调用该方法时，可以给这个子类添加一个分类，并在分类中声明该私有方法。</p>
</li>
<li>
<p>模拟多继承（另外可以模拟多继承的还有protocol）</p>
</li>
<li>
<p>把framework的私有方法公开。</p>
</li>
</ul>
<h2 id="category-的实现原理"><a class="header" href="#category-的实现原理">Category 的实现原理</a></h2>
<p>Category 编译之后的底层结构是 <code>struct category_t</code>，里面存储着分类的对象方法、类方法、属性、协议信息.
在程序运行的时候，runtime 会将 Category 的数据，合并到类信息中（类对象、元类对象中）</p>
<pre><code class="language-objc">struct category_t {
    const char *name;   // 分类的名称
    classref_t cls;     // 对应的类
    struct method_list_t *instanceMethods;  // instance 方法列表
    struct method_list_t *classMethods;     // class 方法列表
    struct protocol_list_t *protocols;      // 协议列表
    struct property_list_t *instanceProperties;     // instance 属性列表
    // Fields below this point are not always present on disk.
    struct property_list_t *_classProperties;   // class 属性列表

    method_list_t *methodsForMeta(bool isMeta) {
        if (isMeta) return classMethods;
        else return instanceMethods;
    }

    property_list_t *propertiesForMeta(bool isMeta, struct header_info *hi);
};
</code></pre>
<h2 id="category-在编译过后是在什么时机与原有的类合并到一起的"><a class="header" href="#category-在编译过后是在什么时机与原有的类合并到一起的">Category 在编译过后，是在什么时机与原有的类合并到一起的?</a></h2>
<ol>
<li>
<p>程序启动后，通过编译之后，Runtime 会进行初始化，调用 <code>_objc_init</code>。</p>
</li>
<li>
<p>然后会 <code>map_images</code>。</p>
</li>
<li>
<p>接下来调用 <code>map_images_nolock</code>。</p>
</li>
<li>
<p>再然后就是 <code>read_images</code>，这个方法会读取所有的类的相关信息。</p>
</li>
<li>
<p>最后是调用 <code>reMethodizeClass:</code>，这个方法是重新方法化的意思。</p>
</li>
<li>
<p>在 <code>reMethodizeClass:</code> 方法内部会调用 <code>attachCategories:</code> ，这个方法会传入 Class 和 Category ，会将方法列表，协议列表等与原有的类合并。最后加入到 <code>class_rw_t</code> 结构体中。</p>
</li>
</ol>
<h2 id="category-和-class-extension-的区别是什么"><a class="header" href="#category-和-class-extension-的区别是什么">Category 和 Class Extension 的区别是什么？</a></h2>
<ul>
<li>
<p>Class Extension 在编译的时候，它的数据就已经包含在类信息中.</p>
</li>
<li>
<p>Category 是在运行时，才会将数据合并到类信息中. 具体为：Category 编译之后的底层结构是 struct category_t，里面存储着分类的对象方法、类方法、属性、协议信息.在程序运行的时候，runtime 会将 Category 的数据，合并到类信息中（类对象、元类对象中）。</p>
</li>
<li>
<p>类拓展不能给系统的类添加方法。</p>
</li>
<li>
<p>类拓展只以声明的形式存在，一般存在 .m 文件中。</p>
</li>
</ul>
<h2 id="category-的-load-和-initialize"><a class="header" href="#category-的-load-和-initialize">Category 的 load 和 initialize</a></h2>
<h3 id="category-中有-load-方法吗load-方法是什么时候调用的load-方法能继承吗"><a class="header" href="#category-中有-load-方法吗load-方法是什么时候调用的load-方法能继承吗">Category 中有 load 方法吗？load 方法是什么时候调用的？load 方法能继承吗？</a></h3>
<ul>
<li>
<p>有load方法</p>
</li>
<li>
<p>load方法在 runtime 加载类、分类的时候调用</p>
</li>
<li>
<p>load 方法可以继承，但是一般情况下不会主动去调用load方法，都是让系统自动调用</p>
</li>
</ul>
<h3 id="loadinitialize-方法的区别什么它们在-category-中的调用的顺序以及出现继承时他们之间的调用过程"><a class="header" href="#loadinitialize-方法的区别什么它们在-category-中的调用的顺序以及出现继承时他们之间的调用过程">load、initialize 方法的区别什么？它们在 category 中的调用的顺序？以及出现继承时他们之间的调用过程？</a></h3>
<ol>
<li>
<p>调用方式</p>
<ul>
<li>
<p><code>load</code> 是根据函数地址直接调用</p>
</li>
<li>
<p><code>initialize</code> 是通过 <code>objc_msgSend</code> 调用</p>
</li>
</ul>
</li>
<li>
<p>调用时刻</p>
<ul>
<li>
<p><code>load</code> 是 runtime 加载类、分类的时候调用（只会调用1次）</p>
</li>
<li>
<p><code>initialize</code> 是类第一次接收到消息的时候调用，每一个类只会 <code>initialize</code> 一次（父类的 <code>initialize</code> 方法可能会被调用多次）</p>
</li>
</ul>
</li>
<li>
<p><code>load</code>、<code>initialize</code> 的调用顺序</p>
<ol>
<li><code>load</code>: 先调用类的 <code>load</code>
<ul>
<li>先编译的类，优先调用 <code>load</code></li>
<li>调用子类的 <code>load</code> 之前，会先调用父类的 <code>load</code></li>
<li>再调用分类的 <code>load</code>: 先编译的分类，优先调用 <code>load</code></li>
</ul>
</li>
<li><code>initialize</code>
<ul>
<li>先初始化父类</li>
<li>再初始化子类（可能最终调用的是父类的 <code>initialize</code> 方法）</li>
</ul>
</li>
</ol>
</li>
<li>
<p><code>load</code>、<code>initialize</code> 的覆盖</p>
<ul>
<li>
<p>如果在分类和本类中都实现了 <code>+load</code> 方法，则本类中的方法和分类中的方法都会被调用。</p>
</li>
<li>
<p>如果在分类和本类中都实现类 <code>+initialize</code> 方法, 则分类中的 <code>+initialize</code> 方法会覆盖本类中的 <code>+initialize</code> 方法</p>
</li>
</ul>
</li>
</ol>
<h2 id="category-能否添加成员变量如果可以如何给-category-添加成员变量"><a class="header" href="#category-能否添加成员变量如果可以如何给-category-添加成员变量">Category 能否添加成员变量？如果可以，如何给 Category 添加成员变量？</a></h2>
<p>分类中不能添加成员变量，分类的底层结构中也没有存储成员变量相关信息的地方。分类的底层结构：</p>
<pre><code class="language-objc">struct category_t {
    const char *name;   // 分类的名称
    classref_t cls;     // 对应的类
    struct method_list_t *instanceMethods;  // instance 方法列表
    struct method_list_t *classMethods;     // class 方法列表
    struct protocol_list_t *protocols;      // 协议列表
    struct property_list_t *instanceProperties;     // instance 属性列表
    // Fields below this point are not always present on disk.
    struct property_list_t *_classProperties;   // class 属性列表

    method_list_t *methodsForMeta(bool isMeta) {
        if (isMeta) return classMethods;
        else return instanceMethods;
    }

    property_list_t *propertiesForMeta(bool isMeta, struct header_info *hi);
};
</code></pre>
<p>即使在分类中声明了属性，也仅仅会生成 setter 方法和 getter 方法的声明。所以如果调用这个分类中的属性进行赋值等操作就会报错。而一个正常的属性包含以下三个内容</p>
<ul>
<li>&quot;_属性名&quot;格式的成员变量：比如<code>_height</code></li>
<li>setter 方法和 getter 方法的声明</li>
<li>setter 方法和 getter 方法的实现</li>
</ul>
<p>可以通过 AssociatedObject 关联对象给分类添加成员变量。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="关联对象"><a class="header" href="#关联对象">关联对象</a></h1>
<h2 id="关联对象给分类添加成员变量"><a class="header" href="#关联对象给分类添加成员变量">关联对象给分类添加成员变量</a></h2>
<p>关联对象的意思是：将传入的参数和对象进行关联。runtime提供了这三个API实现关联对象：</p>
<p>1.添加关联对象</p>
<pre><code class="language-objectivec">// object 需要关联的对象，这里是self（自己，就是Person对象）
// key 标识的key
// value 需要关联的值，这里是age
// policy 关联策略 和（assign、copy、retain等类似）这里是使用 OBJC_ASSOCIATION_ASSIGN
void objc_setc(id _Nonnull object, const void * _Nonnull key, id _Nullable value, objc_AssociationPolicy policy)
</code></pre>
<p>2.获取关联对象：通过对象和key获取</p>
<pre><code class="language-objectivec">id _Nullable objc_getAssociatedObject(id _Nonnull object, const void * _Nonnull key)
</code></pre>
<p>3.移除关联对象</p>
<pre><code class="language-objectivec">void objc_removeAssociatedObjects(id _Nonnull object)
</code></pre>
<p>比如给Person的分类Person(Test)添加age属性，其代码实现为：</p>
<pre><code class="language-objc">#import &lt;objc/runtime.h&gt;

static void *MyKey;

@implementation Person (Test)

- (void)setAge:(NSInteger)age {
    objc_setAssociatedObject(self, &amp;MyKey, [NSNumber numberWithInteger:age], OBJC_ASSOCIATION_ASSIGN);
}

- (NSInteger)age {
    return [objc_getAssociatedObject(self, &amp;MyKey) integerValue];
}

@end
</code></pre>
<h2 id="关联对象的底层原理"><a class="header" href="#关联对象的底层原理">关联对象的底层原理</a></h2>
<p>关联对象通过以下几个核心类实现：</p>
<ul>
<li>AssociationsManager：用来管理关联对象</li>
<li>AssociationsHashMap：key 是 object， value 是 ObjectAssociationMap</li>
<li>ObjectAssociationMap：key 是 关联对象的 key， value 是 ObjcAssociation</li>
<li>ObjcAssociation：存储 policy 和关联对象的值 value。</li>
</ul>
<p><img src="answer/04_runtime/./../../assets/img/station_014.png" alt="" /></p>
<ol>
<li>关联对象并不是存储在被关联的对象本身中，而是通过单独的manager中</li>
<li>关联对象的存储结构为：使用两级 map 存储，第一级的key是关联的对象，value是第二级的map，第二级的 key 是关联对象的key，value是封装的关联对象，包含了内存管理策略policy和关联对象的值 value等</li>
</ol>
<h3 id="关联对象的内存管理"><a class="header" href="#关联对象的内存管理">关联对象的内存管理</a></h3>
<p>对象的 <code>isa</code> 指针中有 <code>has_assoc</code> 的一个位域，用于标记是否有关联对象。如果该位是1，说明该对象有关联对象，在对象 <code>dealloc</code> 的时候会去 AssociationsManager 查找该对象的 AssociationsHashMap，并从内存中抹除。</p>
<p>注意，关联对象的策略中并没有 weak ，策略和修饰符的对应关系：</p>
<ul>
<li>OBJC_ASSOCIATION_ASSIGN：<code>assign</code></li>
<li>OBJC_ASSOCIATION_RETAIN_NONATOMIC：<code>strong</code> <code>nonatomic</code></li>
<li>OBJC_ASSOCIATION_COPY_NONATOMIC: <code>copy</code> <code>nonatomic</code></li>
<li>OBJC_ASSOCIATION_RETAIN:<code>strong</code> <code>atomic</code></li>
<li>OBJC_ASSOCIATION_COPY: <code>copy</code> <code>atomic</code></li>
</ul>
<p>为什么不需要 weak 呢？<br />
weak修饰的属性，当没有拥有对象之后就会被销毁，并且指针置位nil，那么在对象销毁之后，虽然在map中既然存在值object对应的AssociationsHashMap，但是因为object地址已经被置位nil，会造成坏地址访问而无法根据object对象的地址转化为disguised_object了。</p>
<h3 id="关联对象是否是线程安全的"><a class="header" href="#关联对象是否是线程安全的">关联对象是否是线程安全的？</a></h3>
<p>是线程安全的。AssociationsManager 通过持有一个自旋锁 <code>spinlock_t</code> 保证对 AssociationsHashMap 的操作是线程安全的。</p>
<pre><code class="language-objc">class AssociationsManager {
    static spinlock_t _lock;
    static AssociationsHashMap *_map;
public:
    AssociationsManager()   { _lock.lock(); }
    ~AssociationsManager()  { _lock.unlock(); }

    AssociationsHashMap &amp;associations() {
        if (_map == NULL)
            _map = new AssociationsHashMap();
        return *_map;
    }
};

spinlock_t AssociationsManager::_lock;
AssociationsHashMap *AssociationsManager::_map = NULL;
</code></pre>
<h3 id="apple-为什么不把关联对象实现的成员变量添加到类的结构中去而是单独的提供一个关联对象-manager-来存储和管理"><a class="header" href="#apple-为什么不把关联对象实现的成员变量添加到类的结构中去而是单独的提供一个关联对象-manager-来存储和管理">Apple 为什么不把关联对象实现的成员变量添加到类的结构中去，而是单独的提供一个关联对象 manager 来存储和管理？</a></h3>
<p>内存结构上考虑的，对象的内存结构已经固定了，这个时候再添加成员变量，会破坏内存结构。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="runtime-消息发送"><a class="header" href="#runtime-消息发送">Runtime 消息发送</a></h1>
<h2 id="在-obj-c-中为什么叫发消息而不叫函数调用"><a class="header" href="#在-obj-c-中为什么叫发消息而不叫函数调用">在 Obj-C 中为什么叫发消息而不叫函数调用？</a></h2>
<h2 id="runtime-的方法调用流程"><a class="header" href="#runtime-的方法调用流程">Runtime 的方法调用流程</a></h2>
<p>Objetive-C的消息发送，是通过objc_msgSend来实现的，具体执行过程，主要分三个阶段：</p>
<ol>
<li>
<p>消息发送；</p>
</li>
<li>
<p>动态方法解析</p>
</li>
<li>
<p>消息转发或重新签名</p>
</li>
</ol>
<h3 id="消息发送"><a class="header" href="#消息发送">消息发送</a></h3>
<p><img src="answer/04_runtime/./../../assets/img/station_012.png" alt="" /></p>
<h3 id="消息转发"><a class="header" href="#消息转发">消息转发</a></h3>
<p>在消息发送阶段会在对应的类的方法列表中搜索方法，如果找不到就会执行消息转发，消息转发的提供了三次机会：</p>
<ol>
<li><strong>动态方法解析</strong></li>
<li><strong>备用接收者</strong></li>
<li><strong>完整的消息转发</strong></li>
</ol>
<p><img src="answer/04_runtime/./../../assets/img/station_010.png" alt="" /></p>
<h4 id="动态方法解析"><a class="header" href="#动态方法解析">动态方法解析</a></h4>
<p>首先，ObjC 运行时会调用 <code>+resolveInstanceMethod:</code>或者 <code>+resolveClassMethod:</code>，让你有机会提供一个函数实现。如果你添加了函数并返回YES， 那运行时系统就会重新启动一次消息发送的过程。</p>
<p>实现一个动态方法解析的例子: 虽然 <code>ViewController</code> 中没有实现 <code>eat:</code> 方法，但是通过 <code>class_addMethod</code> 动态添加 <code>eatMethod</code> 函数，并执行<code>eatMethod</code>这个函数的 <code>IMP</code>:</p>
<pre><code class="language-objc">#import &quot;ViewController.h&quot;
#import &lt;objc/runtime.h&gt;

@interface ViewController ()

@end

@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];
    
    [self performSelector:@selector(eat:)];
}

+ (BOOL)resolveInstanceMethod:(SEL)sel {
    if (sel == @selector(eat:)) {
        class_addMethod([self class], sel, (IMP)eatMethod, &quot;v@:&quot;);
        return YES;
    }
    
    return [super resolveInstanceMethod:sel];
}

void eatMethod(id obj, SEL _cmd) {
    NSLog(@&quot;Eating!&quot;);
}

@end
</code></pre>
<h4 id="备用接收者"><a class="header" href="#备用接收者">备用接收者</a></h4>
<p>如果目标对象实现了 <code>-forwardingTargetForSelector:</code>，Runtime 这时就会调用这个方法，给你把这个消息转发给其他对象的机会。</p>
<p>实现一个备用接收者的例子如下：<br />
1.Person 类作为备用接收者，实现了 <code>eat</code> 方法：</p>
<pre><code class="language-objc">@interface Person : NSObject

@end

@implementation Person

- (void)eat {
    NSLog(@&quot;%@ - %@&quot;, [self class], NSStringFromSelector(_cmd));
}

@end
</code></pre>
<p>2.在 <code>ViewController</code> 中通过f <code>orwardingTargetForSelector</code> 把当前 <code>ViewController</code> 的方法转发给了 <code>Person</code> 去执行。</p>
<pre><code class="language-objc">#import &quot;ViewController.h&quot;
#import &lt;objc/runtime.h&gt;
#import &quot;Person.h&quot;

@interface ViewController ()

@end

@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];
    
    [self performSelector:@selector(eat)];
}

+ (BOOL)resolveInstanceMethod:(SEL)sel {
    return YES;
}

- (id)forwardingTargetForSelector:(SEL)aSelector {
    if (aSelector == @selector(eat)) {
        return [[Person alloc] init];
    }
    
    return [super forwardingTargetForSelector:aSelector];
}

@end
</code></pre>
<h4 id="完整的消息转发"><a class="header" href="#完整的消息转发">完整的消息转发</a></h4>
<p>如果在上一步还不能处理未知消息，则唯一能做的就是启用完整的消息转发机制了：</p>
<ol>
<li>首先它会发送 <code>-methodSignatureForSelector:</code> 消息获得函数的参数和返回值类型</li>
<li>如果 <code>-methodSignatureForSelector:</code> 返回nil ，Runtime 则会发出 <code>-doesNotRecognizeSelector:</code> 消息，程序这时也就挂掉了</li>
<li>如果返回了一个函数签名，Runtime 就会创建一个 <code>NSInvocation</code> 对象并发送 <code>-forwardInvocation:</code>消息给目标对象。</li>
</ol>
<pre><code class="language-objc">@interface Person : NSObject

@end

@implementation Person

- (void)eat {
    NSLog(@&quot;%@ - %@&quot;, [self class], NSStringFromSelector(_cmd));
}

@end
</code></pre>
<p>Runtime 生成一个 <code>NSInvocation</code> 对象，发送给了 forwardInvocation，在 <code>forwardInvocation</code> 方法里面让 <code>Person</code> 对象去执行 <code>eat</code> 方法 :</p>
<pre><code class="language-objc">#import &quot;ViewController.h&quot;
#import &lt;objc/runtime.h&gt;
#import &quot;Person.h&quot;

@interface ViewController ()

@end

@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];
    
    [self performSelector:@selector(eat)];
}

+ (BOOL)resolveInstanceMethod:(SEL)sel {
    return YES;
}

- (id)forwardingTargetForSelector:(SEL)aSelector {
    return nil;
}

- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector {
    if (aSelector == @selector(eat)) {
        // 生成一个 NSMethodSignature 对象，接着会调用 forwardInvocation 方法
        return [NSMethodSignature signatureWithObjCTypes:&quot;v@:&quot;];
    }
    
    return [super methodSignatureForSelector:aSelector];
}

- (void)forwardInvocation:(NSInvocation *)anInvocation {
    SEL selector = anInvocation.selector;
    
    Person *person = [[Person alloc] init];
    if ([person respondsToSelector:selector]) {
        [anInvocation invokeWithTarget:person];
    } else {
        [self doesNotRecognizeSelector:selector];
    }
}

@end
</code></pre>
<h2 id="nsmethodsignature-和-nsinvocation"><a class="header" href="#nsmethodsignature-和-nsinvocation">NSMethodSignature 和 NSInvocation</a></h2>
<p>在消息转发的时候会使用到 NSMethodSignature 和 NSInvocation 这两个类：</p>
<ul>
<li>NSMethodSignature：<strong>方法签名</strong>，一个对于方法返回值和参数的记录。</li>
<li>NSInvocation：<strong>把消息呈现为对象形式</strong>。可以存储消息的所有配置和直接调用给任意对象，这就是万物皆对象的一种实践了。这个东西就是苹果工程师提供的一个高层消息转发系统。他是一个命令对象，可以给任意OC对象发送消息，那么与之类似的还有一个performSelector。</li>
</ul>
<h3 id="nsmethodsignature"><a class="header" href="#nsmethodsignature">NSMethodSignature</a></h3>
<h3 id="nsinvocation"><a class="header" href="#nsinvocation">NSInvocation</a></h3>
<p>NSInvocation 和 performSelector 对比：</p>
<ul>
<li>performSelector：最多接收两个参数，如果参数多余两个 ，就需要组装成字典类型了</li>
<li>performSelector：参数类型限制为id，如果用普通配型Int Double NSInteger为参数的方法使用时会导致一些诡异的问题</li>
</ul>
<p>NSInvocation 使用的步骤：</p>
<ol>
<li>根据 <code>selector</code> 来初始化方法签名对象 <code>NSMethodSignature</code></li>
<li>根据方法签名对象来初始化 <code>NSInvocation</code> 对象，必须使用 <code>invocationWithMethodSignature:</code> 方法</li>
<li>设置默认的 <code>target</code> 和 <code>selector</code></li>
<li>设置方法签名对应的参数，从下标2开始，超出签名参数index就越界报错</li>
<li>调用 <code>NSInvocation</code> 对象的 <code>invoke</code> 方法</li>
<li>若有返回值，使用 <code>NSInvocation</code> 的 <code>getReturnValue</code> 来获取返回值，注意该方法仅仅就是把返回数据拷贝到提供的内存缓存区，并不会考虑这里的内存管理。</li>
</ol>
<h2 id="runtime-的应用"><a class="header" href="#runtime-的应用">Runtime 的应用</a></h2>
<p>常见的应用：</p>
<ul>
<li>实现多继承 Multiple Inheritance</li>
<li>方法交换 Method Swizzling，比如KVO 实现</li>
<li>AOP 面向切面编程</li>
<li>关联对象(Objective-C Associated Objects)给分类增加属性</li>
<li>遍历类的所有成员变量（修改 textfield 的占位文字颜色、字典转模型、自动归档解档）</li>
<li>利用消息转发机制解决方法找不到的异常问题</li>
<li>消息转发(热更新)解决Bug(JSPatch)</li>
</ul>
<h3 id="如何运用-runtime-字典转模型"><a class="header" href="#如何运用-runtime-字典转模型">如何运用 Runtime 字典转模型</a></h3>
<p>Runtime 遍历 ivar_list,结合 KVC 赋值。</p>
<h2 id="_cmd-关键字的作用"><a class="header" href="#_cmd-关键字的作用"><code>_cmd</code> 关键字的作用？</a></h2>
<p><code>_cmd</code> 在 Objective-C 的方法中表示当前方法的 selector，正如同 <code>self</code> 表示当前方法调用的对象实例一样。</p>
<h3 id="_cmd的使用"><a class="header" href="#_cmd的使用"><code>_cmd</code>的使用</a></h3>
<h4 id="1可以使用-_cmd-打印当前方法名"><a class="header" href="#1可以使用-_cmd-打印当前方法名">1.可以使用 <code>_cmd</code> 打印当前方法名:</a></h4>
<pre><code class="language-objc">- (void)viewDidLoad {
    [super viewDidLoad];
    
    NSLog(@&quot;%@ - %@&quot;, [self class], NSStringFromSelector(_cmd)); // ViewController - viewDidLoad
}
</code></pre>
<p>参考：<a href="https://www.jianshu.com/p/fdb1bc445266">ObjC中_cmd的用法</a></p>
<h2 id="synthesize-和-dynamic-关键字的作用"><a class="header" href="#synthesize-和-dynamic-关键字的作用"><code>@synthesize</code> 和 <code>@dynamic</code> 关键字的作用？</a></h2>
<ul>
<li>
<p><code>@property</code> 有两个对应的词，一个是 <code>@synthesize</code>，一个是 <code>@dynamic</code>。</p>
</li>
<li>
<p>如果 <code>@synthesize</code> 和 <code>@dynamic</code> 都没写，那么默认的就是 <code>@syntheszie var = _var</code></p>
</li>
<li>
<p><code>@synthesize</code> 的语义是如果你没有手动实现 <code>setter</code> 方法和 <code>getter</code> 方法，那么编译器会自动为你加上这两个方法，同时为属性生成下划线成员变量。</p>
</li>
<li>
<p><code>@dynamic</code> 告诉编译器：<strong>属性的 <code>setter</code> 与 <code>getter</code> 方法由用户自己实现，不自动生成</strong>。（当然对于 readonly 的属性只需提供 getter 即可）。
假如一个属性被声明为 @dynamic var，然后你没有提供 @setter方法和 @getter 方法，编译的时候没问题，但是当程序运行到 <code>instance.var = someVar</code>，由于缺 setter 方法会导致程序崩溃；或者当运行到<code> someVar = var</code> 时，由于缺 getter 方法同样会导致崩溃。编译时没问题，运行时才执行相应的方法，这就是所谓的<strong>动态绑定</strong>。</p>
</li>
</ul>
<h3 id="使用场景"><a class="header" href="#使用场景">使用场景</a></h3>
<h4 id="1同时重写属性-property-的-setter-和-getter-方法"><a class="header" href="#1同时重写属性-property-的-setter-和-getter-方法">1.同时重写属性 @property 的 setter 和 getter 方法</a></h4>
<p>使用 @property 指令，编译器会自动生成 setter 和 getter，单独重写 getter或setter，不会出现异常，<strong>但同时重写getter和setter，则会报错</strong>。</p>
<p>原因：<strong>同时重写 getter 和 setter 方法，系统就不会自动生成 <code>_propertyName</code> 变量，所以报错</strong>。</p>
<p>解决方案：添加 <code>@synthesize propertyName = _propertyName</code>;</p>
<pre><code class="language-objc">@interface ViewController ()

@property (nonatomic, copy) NSString *name;

@end

@implementation ViewController

@synthesize name = _name; 

- (void)viewDidLoad {
    [super viewDidLoad];

}

- (void)setName:(NSString *)name {
    _name = name;
}

- (NSString *)name {
    if (!_name || _name.length == 0) return @&quot;None Name&quot;;
    
    return _name;
}

@end
</code></pre>
<h2 id="ismemberofclass-和-iskindofclass-的区别"><a class="header" href="#ismemberofclass-和-iskindofclass-的区别"><code>isMemberOfClass</code> 和 <code>isKindOfClass</code> 的区别？</a></h2>
<ul>
<li>
<p>isMemberOfClass方法是判断当前instance/class对象的isa指向是不是class/meta-class对象类型；</p>
</li>
<li>
<p>isKindOfClass方法是判断当前instance/class对象的isa指向是不是class/meta-class对象或者它的子类类型。isKindOfClass的范围更大。</p>
</li>
</ul>
<h1 id="如何理解oc是一门动态语言"><a class="header" href="#如何理解oc是一门动态语言">如何理解OC是一门动态语言</a></h1>
<p>OC的动态特性可从三方面描述:</p>
<ul>
<li>
<p><strong>动态类型识别（Dynamic typing）</strong>:最终判定该类的实例类型是在运行期间</p>
</li>
<li>
<p><strong>动态绑定（Dynamic binding）</strong>：在运行时确定调用的方法</p>
</li>
<li>
<p><strong>动态加载（Dynamic loading）</strong>：在运行期间可添加模块（类、方法）</p>
</li>
</ul>
<h2 id="动态类型识别"><a class="header" href="#动态类型识别">动态类型识别</a></h2>
<ol>
<li>OC中有一个可以表示任何实例对象类型的关键字--id，将对象声明为id类型，可根据需要，赋予不同类型的实例对象。</li>
<li>父类指针同样也可以指向子类实例对象，编译期指针类型为父类，运行后可判断为具体的某个子类。</li>
<li>这段代码也可以很好的解释OC的动态类型识别：NSData *test = [[NSString alloc] init]; 在编译期test被认为NSData类型，运行后则为NSString类型，其值为空字符串(&quot;&quot;)。</li>
</ol>
<h2 id="动态绑定"><a class="header" href="#动态绑定">动态绑定</a></h2>
<p>消息发送。</p>
<h2 id="动态加载"><a class="header" href="#动态加载">动态加载</a></h2>
<ol>
<li>
<p>动态添加属性：分类中使用关联对象添加属性</p>
</li>
<li>
<p>动态添加方法：通过class_addMethod 添加方法</p>
</li>
<li>
<p>动态添加类：比如KVO</p>
</li>
</ol>
<h1 id="参考-6"><a class="header" href="#参考-6">参考</a></h1>
<ul>
<li><a href="https://juejin.cn/post/6844903586216804359">iOS Runtime详解</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="runloop"><a class="header" href="#runloop">Runloop</a></h1>
<ol>
<li>
<p>讲一下 Runloop 的 Mode? </p>
</li>
<li>
<p>讲一下 Observer ？</p>
</li>
<li>
<p>讲一下 Runloop 的内部实现逻辑? </p>
</li>
</ol>
<h1 id="runloop-和线程"><a class="header" href="#runloop-和线程">Runloop 和线程</a></h1>
<ol>
<li>
<p>Runloop 和线程的关系? </p>
</li>
<li>
<p>GCD 在 Runloop 中的使用？</p>
</li>
<li>
<p>如何使用 Runloop 实现一个常驻线程？这种线程一般有什么作用？</p>
</li>
<li>
<p>主线程 RunLoop 是什么时候初始化的? </p>
</li>
</ol>
<h1 id="runloop-和定时器"><a class="header" href="#runloop-和定时器">Runloop 和定时器</a></h1>
<ol>
<li>
<p>NSTimer 的本质？</p>
</li>
<li>
<p>为什么 NSTimer 有时候不好使? 怎么解决？</p>
</li>
<li>
<p><code>performSelector:afterDelay:</code> 这个方法在子线程中是否起作用？为什么？怎么解决？</p>
</li>
<li>
<p>CADisplayLink 是什么？</p>
</li>
<li>
<p>NSTimer 的循环引用? </p>
</li>
</ol>
<h1 id="runloop-应用"><a class="header" href="#runloop-应用">Runloop 应用</a></h1>
<ol>
<li>
<p>Runloop 有哪些应用？</p>
</li>
<li>
<p>AFNetworking 中如何运用 Runloop ? </p>
</li>
<li>
<p>利用 Runloop 解释一下页面的渲染的过程? </p>
</li>
<li>
<p>如何检测 App 运行过程中是否卡顿? </p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="runloop-的概念"><a class="header" href="#runloop-的概念">RunLoop 的概念</a></h1>
<p>RunLoop 实际上就是一个对象，这个对象管理了其需要处理的事件和消息，并提供了一个入口函数来执行事件循环的逻辑。线程执行了这个函数后，就会一直处于这个函数内部 <strong>接受消息-&gt;等待-&gt;处理</strong>的循环中，直到这个循环结束（比如传入 quit 的消息），函数返回。</p>
<p>OSX/iOS 系统中，提供了两个这样的对象：<code>NSRunLoop</code> 和 <code>CFRunLoopRef</code>:</p>
<ul>
<li>
<p><code>CFRunLoopRef</code> 是在 CoreFoundation 框架内的，它提供了纯 C 函数的 API，所有这些 API 都是线程安全的。</p>
</li>
<li>
<p><code>NSRunLoop</code> 是基于 <code>CFRunLoopRef</code> 的封装，提供了面向对象的 API，但是这些 API 不是线程安全的。</p>
</li>
</ul>
<h1 id="runloop-与线程的关系"><a class="header" href="#runloop-与线程的关系">RunLoop 与线程的关系</a></h1>
<ol>
<li>
<p>RunLoop 与线程是一一对应关系，每个线程(包括主线程)都有一个对应的RunLoop对象；其对应关系保存在一个全局的 <code>Dictionary</code> 里, 线程是 key，runloop 是 value；</p>
</li>
<li>
<p>主线程的 RunLoop 默认由系统自动创建并启动；而其他线程在创建时并没有 RunLoop，若该线程一直不主动获取，就一直不会有 RunLoop；（懒加载）</p>
</li>
<li>
<p>苹果不提供直接创建 RunLoop 的方法；所谓其他线程 Runloop 的创建其实是发生在第一次获取的时候，系统判断当前线程没有 RunLoop 就会自动创建；
当前线程结束时，其对应的 Runloop 也被销毁；</p>
</li>
</ol>
<h1 id="gcd-在-runloop-中的使用"><a class="header" href="#gcd-在-runloop-中的使用">GCD 在 Runloop 中的使用？</a></h1>
<p>GCD由 子线程 返回到 主线程,只有在这种情况下才会触发 RunLoop。会触发 RunLoop 的 Source 1 事件。</p>
<p>当调用 <code>dispatch_async(dispatch_get_main_queue(), block) </code>时，libDispatch 会向主线程的 RunLoop 发送消息，RunLoop 会被唤醒，并从消息中取得这个 block，并在回调 <code>__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__() </code>里执行这个 block。但这个逻辑仅限于 dispatch 到主线程，dispatch 到其他线程仍然是由 libDispatch 处理的。</p>
<p><img src="answer/05_runloop/./../../assets/img/station_022.png" alt="" /></p>
<h1 id="runloop-的-mode"><a class="header" href="#runloop-的-mode">RunLoop 的 mode</a></h1>
<p>Runloop 中一共有5种 mode，其中常用的有3个，其中一个是占位用的：</p>
<ol>
<li><code>kCFRunLoopDefaultMode</code>: App的默认 Mode，通常主线程是在这个 Mode 下运行的。</li>
<li><code>UITrackingRunLoopMode</code>: 界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响。</li>
<li><code>UIInitializationRunLoopMode</code>: 在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用。</li>
<li><code>GSEventReceiveRunLoopMode</code>: 接受系统事件的内部 Mode，通常用不到。</li>
<li><code>kCFRunLoopCommonModes</code>: 这是一个占位的 Mode，没有实际作用。</li>
</ol>
<p>一个 RunLoop 包含若干个 Mode，每个 Mode 又包含若干个 Source/Timer/Observer。每次调用 RunLoop 的主函数时，只能指定其中一个 Mode，这个Mode被称作 CurrentMode。如果需要切换 Mode，只能退出 Loop，再重新指定一个 Mode 进入。这样做主要是为了分隔开不同组的 Source/Timer/Observer，让其互不影响。</p>
<ul>
<li>
<p>CFRunLoopSourceRef 是事件产生的地方。Source有两个版本：Source0 和 Source1。</p>
<ul>
<li>Source0 只包含了一个回调（函数指针），它并不能主动触发事件。使用时，你需要先调用 CFRunLoopSourceSignal(source)，将这个 Source 标记为待处理，然后手动调用 CFRunLoopWakeUp(runloop) 来唤醒 RunLoop，让其处理这个事件。</li>
<li>Source1 包含了一个 mach_port 和一个回调（函数指针），被用于通过内核和其他线程相互发送消息。这种 Source 能主动唤醒 RunLoop 的线程。</li>
</ul>
</li>
<li>
<p>CFRunLoopTimerRef 是基于时间的触发器，它和 NSTimer 是toll-free bridged 的，可以混用。其包含一个时间长度和一个回调（函数指针）。当其加入到 RunLoop 时，RunLoop会注册对应的时间点，当时间点到时，RunLoop会被唤醒以执行那个回调。</p>
</li>
<li>
<p>CFRunLoopObserverRef 是观察者，每个 Observer 都包含了一个回调（函数指针），当 RunLoop 的状态发生变化时，观察者就能通过回调接受到这个变化。可以观测的时间点有以下几个：</p>
</li>
</ul>
<pre><code class="language-objc">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) {
    kCFRunLoopEntry         = (1UL &lt;&lt; 0), // 即将进入Loop
    kCFRunLoopBeforeTimers  = (1UL &lt;&lt; 1), // 即将处理 Timer
    kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), // 即将处理 Source
    kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), // 即将进入休眠
    kCFRunLoopAfterWaiting  = (1UL &lt;&lt; 6), // 刚从休眠中唤醒
    kCFRunLoopExit          = (1UL &lt;&lt; 7), // 即将退出Loop
};
</code></pre>
<p>上面的 Source/Timer/Observer 被统称为 mode item，一个 item 可以被同时加入多个 mode。但一个 item 被重复加入同一个 mode 时是不会有效果的。如果一个 mode 中一个 item 都没有，则 RunLoop 会直接退出，不进入循环。</p>
<h1 id="runloop-的-observer"><a class="header" href="#runloop-的-observer">RunLoop 的 Observer</a></h1>
<p>如上，每个 RunLoop 中包含若干个 Source/Timer/Observer，个 Observer 都包含了一个回调（函数指针），当 RunLoop 的状态发生变化时，观察者就能通过回调接受到这个变化。可以观测的时间点有以下几个：</p>
<pre><code class="language-objc">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) {
    kCFRunLoopEntry         = (1UL &lt;&lt; 0), // 即将进入Loop
    kCFRunLoopBeforeTimers  = (1UL &lt;&lt; 1), // 即将处理 Timer
    kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), // 即将处理 Source
    kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), // 即将进入休眠
    kCFRunLoopAfterWaiting  = (1UL &lt;&lt; 6), // 刚从休眠中唤醒
    kCFRunLoopExit          = (1UL &lt;&lt; 7), // 即将退出Loop
};
</code></pre>
<p>App 启动后，苹果在主线程 RunLoop 里注册了两个 Observer，其回调都是 <code>_wrapRunLoopWithAutoreleasePoolHandler()</code>。</p>
<ul>
<li>
<p>第一个 Observer 监视的事件是 Entry(即将进入Loop)，其回调内会调用 <code>_objc_autoreleasePoolPush()</code> 创建自动释放池。其 order 是 -2147483647，<strong>优先级最高，保证创建释放池发生在其他所有回调之前</strong>。</p>
</li>
<li>
<p>第二个 Observer 监视了两个事件： </p>
<ul>
<li>BeforeWaiting(准备进入休眠) 时调用 <code>_objc_autoreleasePoolPop()</code> 和 <code>_objc_autoreleasePoolPush()</code> 释放旧的池并创建新池；</li>
<li>Exit(即将退出Loop) 时调用 <code>_objc_autoreleasePoolPop()</code> 来释放自动释放池。这个 Observer 的 order 是 2147483647，<strong>优先级最低，保证其释放池子发生在其他所有回调之后</strong>。</li>
</ul>
</li>
</ul>
<p>在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这
些回调会被 RunLoop 创建好的 AutoreleasePool 环绕着，所以不会出现内存泄漏，开发者也不必显示创建 Pool 了。</p>
<h1 id="runloop-的内部逻辑"><a class="header" href="#runloop-的内部逻辑">RunLoop 的内部逻辑</a></h1>
<p>见下图：
<img src="answer/05_runloop/../../assets/img/station_004.png" alt="" /></p>
<h1 id="runloop-的应用"><a class="header" href="#runloop-的应用">RunLoop 的应用</a></h1>
<p>Apple 官方给出了4种需要使用 RunLoop 的场景：</p>
<ul>
<li>自定义输入源进行线程通信</li>
<li>在子线程上使用 Timer</li>
<li>在子线程上使用 <code>performSelector… </code></li>
<li>线程保活</li>
</ul>
<h2 id="runloop-在启动上的应用"><a class="header" href="#runloop-在启动上的应用">Runloop 在启动上的应用</a></h2>
<p>App 的 LifeCycle 方法是基于 Runloop 的 Source0 的，首帧渲染是基于 Runloop Block 的。Runloop 在启动上主要有几点应用：</p>
<ul>
<li>精准统计启动时间</li>
<li>找到一个时机，在启动结束去执行一些预热任务</li>
<li>利用 Runloop 打散耗时的启动预热任务</li>
</ul>
<h2 id="afn-中的线程保活"><a class="header" href="#afn-中的线程保活">AFN 中的线程保活</a></h2>
<p>在早起版本的 AFNetworking 中 <code>AFURLConnectionOperation</code> 这个类是基于 <code>NSURLConnection</code> 构建的，其希望能在后台线程接收 Delegate 回调。为此 AFNetworking 单独创建了一个线程，并在这个线程中启动了一个 RunLoop:</p>
<pre><code class="language-objc">+ (void)networkRequestThreadEntryPoint:(id)__unused object {
    @autoreleasepool {
        [[NSThread currentThread] setName:@&quot;AFNetworking&quot;];
        NSRunLoop *runLoop = [NSRunLoop currentRunLoop];
        [runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];
        [runLoop run];
    }
}
 
+ (NSThread *)networkRequestThread {
    static NSThread *_networkRequestThread = nil;
    static dispatch_once_t oncePredicate;
    dispatch_once(&amp;oncePredicate, ^{
        _networkRequestThread = [[NSThread alloc] initWithTarget:self selector:@selector(networkRequestThreadEntryPoint:) object:nil];
        [_networkRequestThread start];
    });
    return _networkRequestThread;
}
</code></pre>
<p>Runloop启动前必须要至少一个Timer/Observer/Source,所以AFNetworking在[runLoop run]
之前创建了NSMachPort添加进去了.通常情况下调用者需要持有这个NSMachPort并在外部线程通过这个port发送消息到loop内</p>
<pre><code class="language-objc">- (void)start {
    [self.lock lock];
    if ([self isCancelled]) {
        [self performSelector:@selector(cancelConnection) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]];
    } else if ([self isReady]) {
        self.state = AFOperationExecutingState;
        [self performSelector:@selector(operationDidStart) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]];
    }
    [self.lock unlock];
}
</code></pre>
<p>当需要这个后台线程执行任务时,AFNetworking通过调用[NSObject performSelector:onThread:..] 将这个任务扔到了后台线程的 RunLoop 中。</p>
<h2 id="卡顿监控"><a class="header" href="#卡顿监控">卡顿监控</a></h2>
<p><a href="answer/05_runloop/./../performance/112_ans_ch_12_performance_01.html">参考</a></p>
<h2 id="性能优化"><a class="header" href="#性能优化">性能优化</a></h2>
<p>当tableview的cell有多个ImageView，并且是大图的话，滑动的时候导致卡顿，原因是：<strong>Runloop会在一次循环中绘制屏幕上所有的点，如果加载的图片过大，过多，就会造成需要绘制很多的的点，导致一次循环的时间过长，从而导致UI卡顿。</strong></p>
<p>参考 <a href="https://juejin.cn/post/6889769418541252615#heading-12">RunLoop性能优化</a></p>
<h1 id="利用-runloop-解释一下页面的渲染的过程"><a class="header" href="#利用-runloop-解释一下页面的渲染的过程">利用 Runloop 解释一下页面的渲染的过程?</a></h1>
<p>当我们调用 [UIView setNeedsDisplay] 时，这时会调用当前 View.layer 的 [view.layer setNeedsDisplay]方法。</p>
<p>这等于给当前的 layer 打上了一个脏标记，而此时并没有直接进行绘制工作。而是会到当前的 Runloop 即将休眠，也就是 beforeWaiting 时才会进行绘制工作。</p>
<p>紧接着会调用 [CALayer display]，进入到真正绘制的工作。CALayer 层会判断自己的 delegate 有没有实现异步绘制的代理方法 displayer:，这个代理方法是异步绘制的入口，如果没有实现这个方法，那么会继续进行系统绘制的流程，然后绘制结束。</p>
<p>过程可以用下面这张图来解释：</p>
<p>CALayer 内部会创建一个 Backing Store，用来获取图形上下文。接下来会判断这个 layer 是否有 delegate。</p>
<p>如果有的话，会调用 [layer.delegate drawLayer:inContext:]，并且会返回给我们 [UIView DrawRect:] 的回调，让我们在系统绘制的基础之上再做一些事情。</p>
<p>如果没有 delegate，那么会调用 [CALayer drawInContext:]。</p>
<p>以上两个分支，最终 CALayer 都会将位图提交到 Backing Store，最后提交给 GPU。</p>
<p>至此绘制的过程结束。</p>
<h1 id="参考-7"><a class="header" href="#参考-7">参考</a></h1>
<ul>
<li><a href="https://blog.ibireme.com/2015/05/18/runloop/">深入理解RunLoop</a></li>
<li><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW1">Apple 官方文档</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="runloop-与-timer"><a class="header" href="#runloop-与-timer">Runloop 与 timer</a></h1>
<h2 id="nstimer-定时器"><a class="header" href="#nstimer-定时器">NSTimer 定时器</a></h2>
<h3 id="nstimer-的本质"><a class="header" href="#nstimer-的本质">NSTimer 的本质</a></h3>
<p>NSTimer 其实就是 CFRunLoopTimerRef，他们之间是 toll-free bridged 的。一个 NSTimer 注册到 RunLoop 后，RunLoop 会为其重复的时间点注册好事件。例如 10:00, 10:10, 10:20 这几个时间点。RunLoop为了节省资源，并不会在非常准确的时间点回调这个Timer。Timer 有个属性叫做 Tolerance (宽容度)，标示了当时间点到后，容许有多少最大误差。</p>
<p>如果某个时间点被错过了，例如执行了一个很长的任务，则那个时间点的回调也会跳过去，不会延后执行。就比如等公交，如果 10:10 时我忙着玩手机错过了那个点的公交，那我只能等 10:20 这一趟了。</p>
<h3 id="nstimer-定时器不准的原因"><a class="header" href="#nstimer-定时器不准的原因">NSTimer 定时器不准的原因</a></h3>
<ul>
<li>
<p>NSTimer 被添加在 mainRunloop 中,模式是 NSDefaultRunLoopMode, mainRunloop负责所有的主线程事件,例如UI界面的操作,负责的运算使当前Runloop持续的时间超过了定时器的间隔时间,那么下一次定时就被延后,这样就造成timer的阻塞</p>
</li>
<li>
<p>模式的切换,当创建的timer被加入到NSDefaultRunLoopMode时,此时如果有滑动UIScrollView的操作时,runloop的mode会切换为TrackingRunloopMode,这时tiemr会停止回调。</p>
</li>
</ul>
<h3 id="解决方案"><a class="header" href="#解决方案">解决方案</a></h3>
<p>1.<strong>Mode方式的改变,兼顾TrackingRunloopMode</strong></p>
<p>主线程的Runloop使用到的主要有两种模式, NSDefaultRunLoopMode与TrackingRunloopMode模式, 添加定时器到主线程的CommonMode中:</p>
<pre><code class="language-objc">[[NSRunLoop mainRunLoop]addTimer:timer forMode:NSRunLoopCommonModes];
</code></pre>
<p>2.<strong>在子线程中创建timer,在主线程执行UI相关的任务</strong><br />
在子线程中创建timer,在子线程中进行定时任务的操作,需要UI的操作时再切换到主线程进行操作。注意，<strong>子线程的Runloop需要手动开启</strong>。</p>
<p>1.子线程启动timer：</p>
<pre><code class="language-objc">__weak __typeof(self) weakSelf = self;
    dispatch_async(dispatch_get_global_queue(0, 0), ^{
        __strong __typeof(weakSelf) strongSelf = weakSelf;
        if (strongSelf) {
            strongSelf.countTimer = [NSTimer scheduledTimerWithTimeInterval:1 target:strongSelf selector:@selector(countDown) userInfo:nil repeats:YES];
            NSRunLoop *runloop = [NSRunLoop currentRunLoop];
            [runloop addTimer:strongSelf.countTimer forMode:NSDefaultRunLoopMode];
            [runloop run];
        }
    });
</code></pre>
<p>2.主线程更新UI:</p>
<pre><code class="language-objc">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(.1 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
        [self.jumpBTN setTitle:[NSString stringWithFormat:@&quot;跳过 %lds&quot;,(long)self.count] forState:UIControlStateNormal];
    });

</code></pre>
<p>3.<strong>GCD定时器: dispatch_source_create以及depatch_resume等方法</strong>。
使用 GCD 的定时器。GCD 的定时器是直接跟系统内核挂钩的，而且它不依赖于RunLoop，所以它非常的准时。</p>
<pre><code class="language-objc">dispatch_queue_t queue = dispatch_queue_create(&quot;myqueue&quot;, DISPATCH_QUEUE_SERIAL);

// 创建定时器
dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);

//设置时间（start:几s后开始执行； interval:时间间隔）
uint64_t start = 2.0;    //2s后开始执行
uint64_t interval = 1.0; //每隔1s执行
dispatch_source_set_timer(timer, dispatch_time(DISPATCH_TIME_NOW, start * NSEC_PER_SEC), interval * NSEC_PER_SEC, 0);

//设置回调
dispatch_source_set_event_handler(timer, ^{
   NSLog(@&quot;%@&quot;,[NSThread currentThread]);
});

//启动定时器
dispatch_resume(timer);
NSLog(@&quot;%@&quot;,[NSThread currentThread]);

self.timer = timer;
</code></pre>
<h2 id="performselector"><a class="header" href="#performselector">performSelector</a></h2>
<h3 id="performselector-的实现原理"><a class="header" href="#performselector-的实现原理"><code>performSelector</code> 的实现原理</a></h3>
<p><code>performSelector</code> 提供的 API 分为三类：</p>
<p>1.<code>performSelector: withObject:</code> ：立即执行，该方法内部是直接调用这个 selector，所以<strong>无论在哪个线程都不会受到影响</strong></p>
<pre><code class="language-objc">- (void)viewDidLoad {
    [super viewDidLoad];
    
    dispatch_queue_t queue = dispatch_get_global_queue(0, 0);
    NSLog(@&quot;1&quot;);
    dispatch_async(queue, ^{
        [self performSelector:@selector(test) withObject:nil];
    });
    NSLog(@&quot;3&quot;);
}

- (void)test {
    NSLog(@&quot;2&quot;);
}
</code></pre>
<p>结果：输出 1 3 2</p>
<p>2.<code>performSelector: withObject: afterDelay:</code> ：在当前线程延迟执行，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。由于子线程没有开启 Runloop ，所以在子线程会失效。</p>
<pre><code class="language-objc">- (void)viewDidLoad {
    [super viewDidLoad];
    
    dispatch_queue_t queue = dispatch_get_global_queue(0, 0);
    NSLog(@&quot;1&quot;);
    dispatch_async(queue, ^{
        [self performSelector:@selector(test) withObject:nil afterDelay:0];
    });
    NSLog(@&quot;3&quot;);
}

- (void)test {
    NSLog(@&quot;2&quot;);
}
</code></pre>
<p>结果：输出 1 3</p>
<p>3.<code>performSelector: onThread: withObject: waitUntilDone:</code>：在指定线程去执行，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效。</p>
<pre><code class="language-objc">- (void)viewDidLoad {
    [super viewDidLoad];
    
    dispatch_queue_t queue = dispatch_get_global_queue(0, 0);
    NSLog(@&quot;1&quot;);
    dispatch_async(queue, ^{
        [self performSelector:@selector(test) onThread:[NSThread mainThread] withObject:nil waitUntilDone:YES];
    });
    NSLog(@&quot;3&quot;);
}

- (void)test {
    NSLog(@&quot;2&quot;);
}
</code></pre>
<p>结果：输出 1 3 2</p>
<h3 id="performselectorafterdelay这个方法在子线程中是否起作用为什么怎么解决"><a class="header" href="#performselectorafterdelay这个方法在子线程中是否起作用为什么怎么解决"><code>performSelector:afterDelay:</code>这个方法在子线程中是否起作用？为什么？怎么解决？</a></h3>
<p>不起作用，子线程默认没有 Runloop，也就没有 Timer。</p>
<p>解决的办法是可以使用 GCD 来实现：dispatch_after</p>
<h2 id="cadisplaylink-的本质"><a class="header" href="#cadisplaylink-的本质">CADisplayLink 的本质</a></h2>
<p>CADisplayLink 是一个和屏幕刷新率一致的定时器（但实际实现原理更复杂，和 NSTimer 并不一样，其内部实际是操作了一个 Source）。如果在两次屏幕刷新之间执行了一个长任务，那其中就会有一帧被跳过去（和 NSTimer 相似），造成界面卡顿的感觉。在快速滑动TableView时，即使一帧的卡顿也会让用户有所察觉。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="进程和线程"><a class="header" href="#进程和线程">进程和线程</a></h1>
<ol>
<li>
<p>进程、线程，进程和线程的关系？</p>
</li>
<li>
<p>进程的通信方式? </p>
</li>
<li>
<p>多线程的实质（原理）？</p>
</li>
<li>
<p>多线程的优点和缺点？</p>
</li>
<li>
<p>并行和并发的理解？</p>
</li>
<li>
<p>同步与异步</p>
</li>
</ol>
<h1 id="ios-多线程"><a class="header" href="#ios-多线程">iOS 多线程</a></h1>
<ol>
<li>
<p>iOS 种有哪几种多线程方式？</p>
</li>
<li>
<p>NSThread 一般什么时候用？</p>
</li>
<li>
<p>GCD 相关知识 </p>
</li>
<li>
<p>GCD 有哪些队列，默认提供哪些队列？ </p>
</li>
<li>
<p>NSOperation 和 NSOperationQueue 相关知识 </p>
</li>
<li>
<p>NSOperationQueue如何实现串行队列？</p>
</li>
<li>
<p>GCD 与 NSOperationQueue 有哪些异同? </p>
</li>
<li>
<p>如何自定义 NSOperation？</p>
</li>
<li>
<p>线程和 RunLoop 的关系？</p>
</li>
<li>
<p>为什么 iOS 中要将 UI 操作放在主线程？</p>
</li>
<li>
<p>如何用 GCD 实现一个类似 NSOperation 的控制并发数量的模块? [</p>
</li>
<li>
<p>如何用 GCD 实现类似 NSOperation 的 cancel 功能？</p>
</li>
<li>
<p>如何用 GCD 实现类似 NSOperation 的依赖功能？</p>
</li>
</ol>
<h1 id="线程安全"><a class="header" href="#线程安全">线程安全</a></h1>
<ol>
<li>
<p>多线程技术在使用过程中有哪些注意事项？</p>
</li>
<li>
<p>如何确保线程安全？</p>
</li>
<li>
<p>如何实现线性编程？</p>
</li>
<li>
<p>iOS 种有哪些锁？性能如何？</p>
</li>
<li>
<p>OSSpinLock 存在的问题？</p>
</li>
<li>
<p>自旋锁和互斥锁的区别和使用场景？</p>
</li>
<li>
<p>@synchronized 的原理？</p>
</li>
<li>
<p>解释一下多线程中的死锁，有哪些场景？</p>
</li>
<li>
<p>子线程是否会出现死锁？ </p>
</li>
<li>
<p><code>dispatch_sync</code> 什么时候会产生死锁？</p>
</li>
<li>
<p><code>NSMutableArray</code>、和 <code>NSMutableDictionary</code> 是线程安全的吗？<code>NSCache</code> 呢？</p>
</li>
<li>
<p>atomic 和 nonatomic 的区别? </p>
</li>
<li>
<p><code>atomic</code> 修饰的属性是绝对安全的吗？为什么？</p>
</li>
<li>
<p><code>atomic</code> 的进行加锁的时候使用的是什么锁？</p>
</li>
<li>
<p>dispatch_once 原理? 为什么可以保证只执行一次？[</p>
</li>
</ol>
<h1 id="题目"><a class="header" href="#题目">题目</a></h1>
<ol>
<li>
<p>下列代码的输出。</p>
<pre><code class="language-objc">__block int a = 0;
while (a &lt; 5) {
    dispatch_async(dispatch_get_global_queue(0, 0), ^{
        a++;
    });
}
NSLog(@&quot;%d&quot;, a);
</code></pre>
</li>
<li>
<p>下面代码的输出 </p>
<pre><code class="language-objc">dispatch_queue_t serial_queue = dispatch_queue_create(&quot;com.xxx.test&quot;, DISPATCH_QUEUE_SERIAL);

dispatch_sync(serial_queue, ^{
   sleep(3);
   NSLog(@&quot;task 1 %@&quot;, NSThread.currentThread);
});

dispatch_sync(serial_queue, ^{
   NSLog(@&quot;task 2 %@&quot;, NSThread.currentThread);
});

dispatch_async(serial_queue, ^{
   NSLog(@&quot;task 3 %@&quot;, NSThread.currentThread);
});

dispatch_async(serial_queue, ^{
   NSLog(@&quot;task 4 %@&quot;, NSThread.currentThread);
});

NSLog(@&quot;test end&quot;);
</code></pre>
</li>
<li>
<p>下列代码的输出 </p>
<pre><code class="language-objc">dispatch_queue_t queue = dispatch_queue_create(&quot;Felix&quot;, DISPATCH_QUEUE_CONCURRENT);
NSMutableArray *marr = @[].mutableCopy;
for (int i = 0; i &lt; 1000; i++) {
    dispatch_async(queue, ^{
        [marr addObject:@(i)];
    });
}
NSLog(@&quot;%lu&quot;, marr.count);
</code></pre>
</li>
<li>
<p>下列代码的运行结果 </p>
<pre><code class="language-objc">- (void)viewDidLoad {
   [super viewDidLoad];
   NSLog(@&quot;1&quot;);
   dispatch_sync(dispatch_get_main_queue(), ^{
       NSLog(@&quot;2&quot;);
   });
   NSLog(@&quot;3&quot;);
}
</code></pre>
</li>
<li>
<p>下面代码的运行结果 </p>
<pre><code class="language-objc">dispatch_queue_t queue = dispatch_queue_create(&quot;com.xxx.xxx&quot;, DISPATCH_QUEUE_SERIAL);
NSLog(@&quot;之前: %@&quot;, [NSThread currentThread]);
dispatch_async(queue, ^{
    NSLog(@&quot;sync 之前： %@&quot;, [NSThread currentThread]);
    dispatch_sync(queue, ^{
        NSLog(@&quot;sync: %@&quot;, [NSThread currentThread]);
    });
    NSLog(@&quot;sync 之后： %@&quot;, [NSThread currentThread]);
});
</code></pre>
</li>
<li>
<p>下面代码的运行结果。把 0 换成 1 或者 2 后是什么结果？ </p>
<pre><code class="language-objc">dispatch_semaphore_t t1 = dispatch_semaphore_create(0);

dispatch_async(dispatch_get_global_queue(0, 0), ^{
    NSLog(@&quot;1&quot;);
    dispatch_semaphore_signal(t1);
});
dispatch_semaphore_wait(t1, DISPATCH_TIME_FOREVER);

dispatch_async(dispatch_get_global_queue(0, 0), ^{
    NSLog(@&quot;2&quot;);
	sleep(2);
    dispatch_semaphore_signal(t1);
});
dispatch_semaphore_wait(t1, DISPATCH_TIME_FOREVER);

dispatch_async(dispatch_get_global_queue(0, 0), ^{
    NSLog(@&quot;3&quot;);
    dispatch_semaphore_signal(t1);
});
</code></pre>
</li>
<li>
<p>下面代码的运行结果？将 <code>performSelector:</code> 换成 <code>performSelectorOnMainThread:</code> 呢？</p>
<pre><code class="language-objc">- (void)viewDidLoad {
	[super viewDidLoad];

	dispatch_async(dispatch_get_global_queue(0, 0), ^{
    	NSLog(@&quot;1&quot;);

    	[self performSelector:@selector(test) withObject:nil afterDelay:0];
    	
		NSLog(@&quot;3&quot;);
	});
}

- (void)test {
	NSLog(@&quot;2&quot;);
}
</code></pre>
</li>
<li>
<p>下面代码的运行结果？</p>
<pre><code class="language-objc">dispatch_async(dispatch_get_main_queue(), ^{
    NSLog(@&quot;1, thrad: %@&quot;, [NSThread currentThread]);
});

dispatch_async(dispatch_get_main_queue(), ^{
    NSLog(@&quot;2, thrad: %@&quot;, [NSThread currentThread]);
});

dispatch_async(dispatch_get_main_queue(), ^{
    NSLog(@&quot;3, thrad: %@&quot;, [NSThread currentThread]);
});
</code></pre>
</li>
<li>
<p>有一个 <code>generateContent</code> 比较耗时的方法，会生成特定的内容返回，现在需要调用这个方法：1. 如果方法立马返回，则立即返回这内容 2. 如果 3s 未返回，则返回为空。如何实现？</p>
</li>
<li>
<p>有A、B、C三个耗时任务需要异步执行，当这三个任务都执行完成后更新UI，如何实现？</p>
</li>
<li>
<p>有三个线程轮流执行，第一个线程打印A，第二个线程打印B，第三个线程打印C……循环10次。如何实现？</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="进程和线程-1"><a class="header" href="#进程和线程-1">进程和线程</a></h1>
<h2 id="进程线程进程和线程的关系"><a class="header" href="#进程线程进程和线程的关系">进程、线程，进程和线程的关系？</a></h2>
<p>1.进程
进程是处于运行过程中的程序，并且具有一定的独立功能，<strong>是系统进行资源分配和调度运行的基本单位</strong>。比如在电脑上运行的一个微信程序，就是一个进程。进程的三个状态：</p>
<ul>
<li>运行状态：获得CPU的进程，它所对应的程序正在处理机上运行</li>
<li>阻塞状态/等待状态：进程为了等待某种外部事件的发生（如等待输入输出操作的完成，等待另一个进程发来消息），暂时无法运行.</li>
<li>就绪状态：已具备运行所需的一切条件，只是由于别的进程占用处理机而暂时无法运行。</li>
</ul>
<p>2.线程：</p>
<ul>
<li>
<p>线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.<strong>线程自己基本上不拥有系统资源</strong>,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。</p>
</li>
<li>
<p>一个进程可以拥有多个线程。</p>
</li>
</ul>
<p>3.线程和进程的关系</p>
<ul>
<li>一个线程可以创建和撤销另一个线程。</li>
<li>同一个进程中的多个线程之间可以并发执行。</li>
<li>相对进程而言，线程是一个更加接近于执行体的概念，它可以与同进程中的其他线程共享数据，但拥有自己的栈空间，拥有独立的执行序列</li>
</ul>
<h2 id="进程的通信方式"><a class="header" href="#进程的通信方式">进程的通信方式</a></h2>
<p>参考 <a href="https://www.jianshu.com/p/c1015f5ffa74">进程间通信IPC (InterProcess Communication)</a>
每个进程各自有不同的用户地址空间，任何一个进程的全局变量在另一个进程中都看不到，所以<strong>进程之间要交换数据必须通过内核，在内核中开辟一块缓冲区，进程1把数据从用户空间拷到内核缓冲区，进程2再从内核缓冲区把数据读走，内核提供的这种机制称为进程间通信</strong>（IPC，InterProcess Communication），主要有以下方式：</p>
<ol>
<li>管道/匿名管道(pipe)</li>
<li>有名管道(FIFO)</li>
<li>信号（Signal）</li>
<li>消息（Message）队列</li>
<li>共享内存（share memory）</li>
<li>信号量（semaphore）</li>
<li>套接字（Socket）</li>
</ol>
<h3 id="1-管道匿名管道pipe"><a class="header" href="#1-管道匿名管道pipe">1. 管道/匿名管道(pipe)</a></h3>
<p>通信方式：</p>
<ul>
<li>管道是半双工的，数据只能向一个方向流动；需要双方通信时，需要建立起两个管道。</li>
<li>只能用于父子进程或者兄弟进程之间(具有亲缘关系的进程);</li>
<li>单独构成一种独立的文件系统：管道对于管道两端的进程而言，就是一个文件，但它不是普通的文件，它不属于某种文件系统，而是自立门户，单独构成一种文件系统，并且只存在与内存中。</li>
<li>数据的读出和写入：一个进程向管道中写的内容被管道另一端的进程读出。写入的内容每次都添加在管道缓冲区的末尾，并且每次都是从缓冲区的头部读出数据。</li>
</ul>
<p>管道的实质：</p>
<ul>
<li>管道的实质是一个内核缓冲区，进程以先进先出的方式从缓冲区存取数据，管道一端的进程顺序的将数据写入缓冲区，另一端的进程则顺序的读出数据。</li>
<li>该缓冲区可以看做是一个循环队列，读和写的位置都是自动增长的，不能随意改变，一个数据只能被读一次，读出来以后在缓冲区就不复存在了。</li>
<li>当缓冲区读空或者写满时，有一定的规则控制相应的读进程或者写进程进入等待队列，当空的缓冲区有新数据写入或者满的缓冲区有数据读出来时，就唤醒等待队列中的进程继续读写。</li>
</ul>
<p>管道的局限：</p>
<ul>
<li>只支持单向数据流；</li>
<li>只能用于具有亲缘关系的进程之间；</li>
<li>没有名字；</li>
<li>管道的缓冲区是有限的（管道制存在于内存中，在管道创建时，为缓冲区分配一个页面大小）；</li>
<li>管道所传送的是无格式字节流，这就要求管道的读出方和写入方必须事先约定好数据的格式，比如多少字节算作一个消息（或命令、或记录）等等；</li>
</ul>
<h3 id="2-有名管道fifo"><a class="header" href="#2-有名管道fifo">2. 有名管道(FIFO)</a></h3>
<p>通信方式：
有名管道不同于匿名管道之处在于它提供了一个路径名与之关联，以有名管道的文件形式存在于文件系统中，这样，即使与有名管道的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过有名管道相互通信，因此，通过有名管道不相关的进程也能交换数据。值的注意的是，有名管道严格遵循先进先出(first in first out),对匿名管道及有名管道的读总是从开始处返回数据，对它们的写则把数据添加到末尾。它们不支持诸如lseek()等文件定位操作。有名管道的名字存在于文件系统中，内容存放在内存中。</p>
<p>匿名管道和有名管道对比：</p>
<ul>
<li>管道是特殊类型的文件，在满足先入先出的原则条件下可以进行读写，但不能进行定位读写。</li>
<li>匿名管道是单向的，只能在有亲缘关系的进程间通信；有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。</li>
<li><strong>无名管道阻塞问题</strong>：无名管道无需显示打开，创建时直接返回文件描述符，在读写时需要确定对方的存在，否则将退出。如果当前进程向无名管道的一端写数据，必须确定另一端有某一进程。如果写入无名管道的数据超过其最大值，写操作将阻塞，如果管道中没有数据，读操作将阻塞，如果管道发现另一端断开，将自动退出。</li>
<li><strong>有名管道阻塞问题</strong>：有名管道在打开时需要确实对方的存在，否则将阻塞。即以读方式打开某管道，在此之前必须一个进程以写方式打开管道，否则阻塞。此外，可以以读写（O_RDWR）模式打开有名管道，即当前进程读，当前进程写，不会阻塞。</li>
</ul>
<h3 id="3-信号signal"><a class="header" href="#3-信号signal">3. 信号(Signal)</a></h3>
<p>通信机制：</p>
<ul>
<li>信号是Linux系统中用于进程间互相通信或者操作的一种机制，信号可以在任何时候发给某一进程，而无需知道该进程的状态。</li>
<li>如果该进程当前并未处于执行状态，则该信号就有内核保存起来，直到该进程恢复执行并传递给它为止。</li>
<li>如果一个信号被进程设置为阻塞，则该信号的传递被延迟，直到其阻塞被取消是才被传递给进程。</li>
</ul>
<p>信号来源： 
信号是软件层次上对中断机制的一种模拟，是一种异步通信方式，，信号可以在用户空间进程和内核之间直接交互，内核可以利用信号来通知用户空间的进程发生了哪些系统事件，信号事件主要有两个来源：</p>
<ul>
<li>硬件来源：用户按键输入Ctrl+C退出、硬件异常如无效的存储访问等。</li>
<li>软件终止：终止进程信号、其他进程调用kill函数、软件异常产生信号。</li>
</ul>
<p>信号生命周期和处理流：</p>
<ol>
<li>信号被某个进程产生，并设置此信号传递的对象（一般为对应进程的pid），然后传递给操作系统；</li>
<li>操作系统根据接收进程的设置（是否阻塞）而选择性的发送给接收者，如果接收者阻塞该信号（且该信号是可以阻塞的），操作系统将暂时保留该信号，而不传递，直到该进程解除了对此信号的阻塞（如果对应进程已经退出，则丢弃此信号），如果对应进程没有阻塞，操作系统将传递此信号。</li>
<li>目的进程接收到此信号后，将根据当前进程对此信号设置的预处理方式，暂时终止当前代码的执行，保护上下文（主要包括临时寄存器数据，当前程序位置以及当前CPU的状态）、转而执行中断服务程序，执行完成后再恢复到中断的位置。当然，对于抢占式内核，在中断返回时还将引发新的调度。</li>
</ol>
<h3 id="4-消息message队列"><a class="header" href="#4-消息message队列">4. 消息(Message)队列</a></h3>
<p>通信机制：</p>
<ul>
<li>消息队列是存放在内核中的消息链表，每个消息队列由消息队列标识符表示。</li>
<li>与管道（无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统）不同的是消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显示地删除一个消息队列时，该消息队列才会被真正的删除。</li>
<li>另外与管道不同的是，消息队列在某个进程往一个队列写入消息之前，并不需要另外某个进程在该队列上等待消息的到达。</li>
</ul>
<h3 id="5-共享内存share-memory"><a class="header" href="#5-共享内存share-memory">5. 共享内存(share memory)</a></h3>
<p>通信机制：</p>
<ul>
<li>使得多个进程可以可以直接读写同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。</li>
<li>为了在多个进程间交换信息，内核专门留出了一块内存区，可以由需要访问的进程将其映射到自己的私有地址空间。进程就可以直接读写这一块内存而不需要进行数据的拷贝，从而大大提高效率。</li>
<li>由于多个进程共享一段内存，因此需要依靠某种同步机制（如信号量）来达到进程间的同步及互斥。</li>
</ul>
<h3 id="6-信号量semaphore"><a class="header" href="#6-信号量semaphore">6. 信号量(semaphore)</a></h3>
<p>通信机制： 
信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。
为了获得共享资源，进程需要执行下列操作：</p>
<ul>
<li>创建一个信号量：这要求调用者指定初始值，对于二值信号量来说，它通常是1，也可是0。</li>
<li>等待一个信号量：该操作会测试这个信号量的值，如果小于0，就阻塞。也称为P操作。</li>
<li>挂出一个信号量：该操作将信号量的值加1，也称为V操作。</li>
</ul>
<h3 id="7-套接字socket"><a class="header" href="#7-套接字socket">7. 套接字(socket)</a></h3>
<p>套接字是一种通信机制，凭借这种机制，客户/服务器（即要进行通信的进程）系统的开发工作既可以在本地单机上进行，也可以跨网络进行。也就是说它可以让不在同一台计算机但通过网络连接计算机上的进程进行通信。</p>
<h2 id="多线程的实质原理"><a class="header" href="#多线程的实质原理">多线程的实质（原理）</a></h2>
<p>CPU在多条线程之间来回的快速切换，当CPU的速度足够快的时候，就造成了多个线程同时执行的假象。
但是如果线程非常多, CPU 会在多条线程之间不断的调度任务,就会造成性能低下，CPU会累死。</p>
<h2 id="多线程的优点和缺点"><a class="header" href="#多线程的优点和缺点">多线程的优点和缺点</a></h2>
<ul>
<li>
<p>优点：充分利用了计算机的多核特性，提升效率。</p>
</li>
<li>
<p>缺点：创建线程是需要花费资源的，线程的切换也是需要花费资源的。一条主线程占用1M，一条子线程占用 512Kb。</p>
</li>
</ul>
<h2 id="并行-和-并发"><a class="header" href="#并行-和-并发">并行 和 并发</a></h2>
<ul>
<li>
<p><strong>并发指的是一种现象</strong>，一种经常出现，无可避免的现象。它描述的是“多个任务同时发生，需要被处理”这一现象。它的侧重点在于“发生”。比如有很多人排队等待检票，这一现象就可以理解为并发。</p>
</li>
<li>
<p><strong>并行指的是一种技术</strong>，一个同时处理多个任务的技术。它描述了一种能够同时处理多个任务的能力，侧重点在于“运行”。比如景点开放了多个检票窗口，同一时间内能服务多个游客。这种情况可以理解为并行。并行的反义词就是串行，表示任务必须按顺序来，一个一个执行，前一个执行完了才能执行后一个。</p>
</li>
</ul>
<p>我们经常挂在嘴边的“多线程”，正是采用了并行技术，从而提高了执行效率。因为有多个线程，所以计算机的多个CPU可以同时工作，同时处理不同线程内的指令。</p>
<p>并发是一种现象，面对这一现象，我们首先创建多个线程，真正加快程序运行速度的，是并行技术。也就是让多个CPU同时工作。而多线程，是为了让多个CPU同时工作成为可能。</p>
<h2 id="同步与异步"><a class="header" href="#同步与异步">同步与异步</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ios-多线程-1"><a class="header" href="#ios-多线程-1">iOS 多线程</a></h1>
<h2 id="ios-种有哪几种多线程方式"><a class="header" href="#ios-种有哪几种多线程方式">iOS 种有哪几种多线程方式?</a></h2>
<p>在 iOS 中其实目前有 4 套多线程方案，他们分别是：</p>
<ul>
<li>pThread</li>
<li>NSThread：
<ul>
<li>苹果封装的完全面向对象的多线程方案。可以直接操控线程对象，比较直观方便。</li>
<li>缺点是：它的生命周期还是需要我们手动管理，所以使用比较少。</li>
<li>在一些简单的场合会使用 NSThread ,比如获取当前线程<code>[NSThread currentThread];</code></li>
<li>但是不好去处理都线程中一些高级概念。</li>
</ul>
</li>
<li>GCD
<ul>
<li>GCD是苹果为多核的并行运算提出的解决方案，所以会自动合理地利用更多的CPU内核（比如双核、四核），</li>
<li>最重要的是它会<strong>自动管理线程的生命周期</strong>（创建线程、调度任务、销毁线程），完全不需要我们管理，我们只需要告诉干什么就行。</li>
<li>同时它使用的也是 c语言，不过由于<strong>使用了 Block</strong>，使得使用起来更加方便，而且灵活。</li>
</ul>
</li>
<li>NSOperation和NSOperationQueue
<ul>
<li>NSOperation 是苹果公司对 GCD 的封装，完全面向对象，所以使用起来更好理解。</li>
<li>NSOperation 和 NSOperationQueue 分别对应 GCD 的 任务 和 队列 。</li>
</ul>
</li>
</ul>
<h2 id="gcd"><a class="header" href="#gcd">GCD</a></h2>
<p>在 GCD 中，加入了两个非常重要的概念： 任务 和 队列。</p>
<ul>
<li>
<p>任务：即操作，你想要干什么，说白了就是一段代码，在 GCD 中就是一个 Block，所以添加任务十分方便。任务有两种执行方式： 同步执行 和 异步执行，他们之间的区别是：会不会阻塞当前线程，直到 Block 中的任务执行完毕！</p>
<ul>
<li>
<p>同步执行：它会阻塞当前线程并等待 Block 中的任务执行完毕，然后当前线程才会继续往下运行。</p>
</li>
<li>
<p>异步执行：当前线程会直接往下执行，它不会阻塞当前线程。</p>
</li>
</ul>
</li>
<li>
<p>队列：用于存放任务。一共有两种队列， 串行队列 和 并行队列。</p>
<ul>
<li>
<p>串行队列：放到串行队列的任务，GCD 会 FIFO（先进先出）地取出来一个，执行一个，然后取下一个，这样一个一个的执行。</p>
</li>
<li>
<p>并行队列：并行队列 中的任务根据同步或异步有不同的执行方式。</p>
</li>
</ul>
</li>
</ul>
<table><thead><tr><th></th><th>同步执行</th><th>异步执行</th></tr></thead><tbody>
<tr><td>串行队列</td><td>当前线程，一个一个执行</td><td>其他线程，一个一个执行</td></tr>
<tr><td>并行队列</td><td>当前线程，一个一个执行</td><td>很多线程，一起执行</td></tr>
</tbody></table>
<h3 id="队列"><a class="header" href="#队列">队列</a></h3>
<ul>
<li>
<p>主队列：这是一个特殊的串行队列。<code>dispatch_get_main_queue()</code></p>
</li>
<li>
<p>全局并行队列：<code>dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)</code></p>
</li>
<li>
<p>自己创建的队列：自己可以创建串行队列, 也可以创建并行队列，在第二个参数中 DISPATCH_QUEUE_SERIAL 或 NULL,表示创建串行队列；传入 DISPATCH_QUEUE_CONCURRENT 表示创建并行队列。</p>
<pre><code class="language-objc">// 串行队列
dispatch_queue_t serial_queue = dispatch_queue_create(&quot;com.xxx.test&quot;, DISPATCH_QUEUE_SERIAL);
dispatch_queue_t serial_queue2 = dispatch_queue_create(&quot;com.xxx.test&quot;, NUlLL);

// 并行队列
dispatch_queue_t concurrent_queue = dispatch_queue_create(&quot;com.xxx.test&quot;, DISPATCH_QUEUE_CONCURRENT);
</code></pre>
</li>
</ul>
<h3 id="任务"><a class="header" href="#任务">任务</a></h3>
<ul>
<li>
<p>同步任务：<code>dispatch_sync</code>，会阻塞当前线程；</p>
</li>
<li>
<p>异步任务：<code>dispatch_async</code>, 不会阻塞当前线程。</p>
</li>
</ul>
<h3 id="队列组"><a class="header" href="#队列组">队列组</a></h3>
<p>队列组可以将很多队列添加到一个组里，这样做的好处是，当这个组里所有的任务都执行完了，队列组会通过一个方法通知我们。</p>
<pre><code class="language-objc">    // 创建 group 和 queue
    dispatch_group_t group = dispatch_group_create();
    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
    
    dispatch_group_async(group, queue, ^{
        for (int i = 0; i &lt; 3; i++) {
            NSLog(@&quot;group-0 - %d&quot;, i);
        }
    });
    
    dispatch_group_async(group, queue, ^{
        for (int i = 0; i &lt; 10; i++) {
            NSLog(@&quot;group-1 - %d&quot;, i);
        }
    });
    
    dispatch_group_async(group, queue, ^{
        for (int i = 0; i &lt; 5; i++) {
            NSLog(@&quot;group-2 - %d&quot;, i);
        }
    });
    
    // 执行完成后通知
    dispatch_group_notify(group, queue, ^{
        NSLog(@&quot;finished: %@&quot;, [NSThread currentThread]);
    });
</code></pre>
<p>通常 <code>dispatch_group_t</code> 需要和 <code>dispatch_group_enter</code>、<code>dispatch_group_leave</code> 配合使用。</p>
<h3 id="dispatch_barrier"><a class="header" href="#dispatch_barrier">dispatch_barrier</a></h3>
<ul>
<li>
<p><code>dispatch_barrier_async</code>：这个方法重点是你传入的 queue：</p>
<ul>
<li>
<p>当传入的 queue 是通过 DISPATCH_QUEUE_CONCURRENT 参数自己创建的 queue 时，这个方法会阻塞这个 queue（<strong>注意是阻塞 queue ，而不是阻塞当前线程</strong>），一直等到这个 queue 中排在它前面的任务都执行完成后才会开始执行自己，自己执行完毕后，再会取消阻塞，使这个 queue 中排在它后面的任务继续执行。</p>
</li>
<li>
<p>如果你传入的是其他的 queue, 那么它就和 dispatch_async 一样了。</p>
</li>
</ul>
</li>
<li>
<p><code>dispatch_barrier_sync</code>：</p>
<ul>
<li>
<p>传入自定义的并发队列（DISPATCH_QUEUE_CONCURRENT），它和上一个方法一样的阻塞 queue，<strong>不同的是这个方法还会阻塞当前线程</strong>。</p>
</li>
<li>
<p>传入的是其他的 queue, 那么它就和 dispatch_sync 一样了</p>
</li>
</ul>
</li>
</ul>
<h2 id="nsoperation-和-nsoperationqueue"><a class="header" href="#nsoperation-和-nsoperationqueue">NSOperation 和 NSOperationQueue</a></h2>
<p>NSOperation 和 NSOperationQueue 分别对应 GCD 的 任务 和 队列 。操作步骤也很好理解：将要执行的任务封装到一个 NSOperation 对象中，将此任务添加到一个 NSOperationQueue 对象中。然后系统就会自动在执行任务。</p>
<p>NSOperation 只是一个抽象类，所以不能封装任务。但它有 2 个子类用于封装任务。分别是：NSInvocationOperation 和 NSBlockOperation 。创建一个 Operation 后，需要调用 start 方法来启动任务，它会 默认在当前队列同步执行。当然你也可以在中途取消一个任务，只需要调用其 cancel 方法即可。</p>
<pre><code class="language-objc">    NSOperationQueue *queue = [[NSOperationQueue alloc] init];
    
    NSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^{
        NSLog(@&quot;current: %@&quot;, [NSThread currentThread]);
    }];
    
    for (int i = 0; i &lt; 5; i++) {
        [operation addExecutionBlock:^{
            NSLog(@&quot;i: %d&quot;, i);
            NSLog(@&quot;current: %@&quot;, [NSThread currentThread]);
        }];
    }
    
    [queue addOperation:operation];
</code></pre>
<p>自定义 NSOperation ，继承 NSOperation 类，并实现其 main() 方法，因为在调用 start() 方法的时候，内部会调用 main() 方法完成相关逻辑。</p>
<h3 id="nsoperationqueue-实现串行队列"><a class="header" href="#nsoperationqueue-实现串行队列">NSOperationQueue 实现串行队列</a></h3>
<p>将最大并发数设置为 1 即可</p>
<pre><code class="language-objc">queue.maxConcurrentOperationCount = 1;
</code></pre>
<h3 id="nsoperation-设置依赖"><a class="header" href="#nsoperation-设置依赖">NSOperation 设置依赖</a></h3>
<p>NSOperation 有一个非常实用的功能，那就是添加依赖。比如有 3 个任务：A: 从服务器上下载一张图片，B：给这张图片加个水印，C：把图片返回给服务器。这时就可以用到依赖了:</p>
<pre><code class="language-objc">- (void)operationTest {
    // 不能添加相互依赖，会死锁，比如 A依赖B，B依赖A。
    //1.任务一：下载图片
    NSBlockOperation *operation1 = [NSBlockOperation blockOperationWithBlock:^{
        NSLog(@&quot;下载图片 - %@&quot;, [NSThread currentThread]);
        [NSThread sleepForTimeInterval:1.0];
    }];
    
    //2.任务二：打水印
    NSBlockOperation *operation2 = [NSBlockOperation blockOperationWithBlock:^{
        NSLog(@&quot;打水印   - %@&quot;, [NSThread currentThread]);
        [NSThread sleepForTimeInterval:1.0];
    }];
    
    //3.任务三：上传图片
    NSBlockOperation *operation3 = [NSBlockOperation blockOperationWithBlock:^{
        NSLog(@&quot;上传图片 - %@&quot;, [NSThread currentThread]);
        [NSThread sleepForTimeInterval:1.0];
    }];
    
    //4.设置依赖
    [operation2 addDependency:operation1];      //任务二依赖任务一
    [operation3 addDependency:operation2];      //任务三依赖任务二
    
    //5.创建队列并加入任务
    NSOperationQueue *queue = [[NSOperationQueue alloc] init];
    [queue addOperations:@[operation3, operation2, operation1] waitUntilFinished:NO];
}
</code></pre>
<h2 id="gcd-与-nsoperationqueue-有哪些异同"><a class="header" href="#gcd-与-nsoperationqueue-有哪些异同">GCD 与 NSOperationQueue 有哪些异同</a></h2>
<ul>
<li>
<p>面向对象：</p>
<ul>
<li>
<p>GCD 不是面向对象的，是 C 函数构成的 API，通过队列执行 block 构成的任务，是一个轻量级的数据结构</p>
</li>
<li>
<p>NSOperationQueue 是 Objc 的对象，可以直接操作线程对象，提供了更多的选择</p>
</li>
</ul>
</li>
<li>
<p>提供的功能：苹果封装后，NSOperationQueue 提供了如下几个都是 GCD 中没有的功能：</p>
<ul>
<li>
<p>cancel：NSOperation 提供了 cancel 方法，可以取消一个操作的执行。但是注意这里的取消只是针对未执行的任务设置 finished ＝ YES，如果这个操作已经在执行了，那么我们只能等其操作完成。当我们调用 cancel 方法的时候，他只是将 isCancelled 设置为 YES。</p>
</li>
<li>
<p>设置依赖：NSOperation 有一个非常实用的功能，那就是添加依赖。比如有 3 个任务：A、B、C，B 依赖于 A 执行，C 依赖于 B 执行，则可以通过依赖实现。</p>
</li>
<li>
<p>最大并发数：NSOperationQueue 提供了设置最大并发数的 API，很方便。</p>
</li>
</ul>
</li>
<li>
<p>可拓展性：由于NSOperationQueue 是 Objc 的对象，我们能够对NSOperation进行继承，在这之上添加成员变量与成员方法，提高整个代码的复用度，这比简单地将block任务排入执行队列更有自由度，能够在其之上添加更多自定制的功能。</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="线程同步"><a class="header" href="#线程同步">线程同步</a></h1>
<h2 id="多线程使用过程中的注意事项"><a class="header" href="#多线程使用过程中的注意事项">多线程使用过程中的注意事项？</a></h2>
<ul>
<li>
<p>避免开辟过多的线程和太多线程间的来回切换，创建线程是需要花费资源的，线程的切换也是需要花费资源的。一条主线程占用1M，一条子线程占用 512Kb。</p>
</li>
<li>
<p>避免出现多线程抢占资源问题，出现死锁场景</p>
</li>
</ul>
<h2 id="如何确保线程安全"><a class="header" href="#如何确保线程安全">如何确保线程安全？</a></h2>
<ul>
<li>采用串行队列</li>
<li>使用信号量</li>
<li>使用加锁方案</li>
</ul>
<h2 id="如何实现线性编程"><a class="header" href="#如何实现线性编程">如何实现线性编程？</a></h2>
<ul>
<li>
<p>信号量 <code>dispatch_semaphore_t</code>:</p>
</li>
<li>
<p>栅栏 <code>dispatch_barrier</code></p>
</li>
<li>
<p>dispatch_group</p>
</li>
</ul>
<h2 id="ios-中有哪些锁性能如何"><a class="header" href="#ios-中有哪些锁性能如何">iOS 中有哪些锁？性能如何？</a></h2>
<h3 id="锁的分类"><a class="header" href="#锁的分类">锁的分类</a></h3>
<ul>
<li>
<p>自旋锁：<strong>线程反复检查锁变量是否可用</strong>。由于线程在这一过程中保持执行，因此是一种忙等待。一旦获取了自旋锁，线程会一直保持该锁，直至释放自旋锁。</p>
<ul>
<li>优点：自旋锁避免了进程上下文的调度开销，因此对于线程只会阻塞很短时间的场合是有效的。</li>
<li>缺点：单核CPU不适于使用自旋锁，这里的单核CPU指的是单核单线程的CPU，因为，在同一时间只有一个线程是处在运行状态，假设运行线程A发现无法获取锁，只能等待解锁，但因为A自身不挂起，所以那个持有锁的线程B没有办法进入运行状态，只能等到操作系统分给A的时间片用完，才能有机会被调度。这种情况下使用自旋锁的代价很高。</li>
<li>适用场景：适用于耗时短的操作。</li>
</ul>
</li>
<li>
<p>互斥锁：<strong>多线程编程中，防止两条线程同时对同一公共资源（比如全局变量）进行读写的机制。</strong></p>
<ul>
<li>原理：当需要加锁的资源已经被别的线程占据时，等待锁的线程会进行休眠，等待执行完成释放后再进行唤醒，线程唤醒会带来一定的开销。</li>
<li>缺点：性能差一些。</li>
<li>适用：适用于耗时长的操作。</li>
</ul>
</li>
<li>
<p>读写锁：<strong>多读单写</strong></p>
<ul>
<li>原理：读写锁通常用互斥锁、条件变量、信号量实现。</li>
</ul>
</li>
<li>
<p>信号量：进行线程调度。</p>
</li>
</ul>
<h3 id="ios中的各种锁和性能"><a class="header" href="#ios中的各种锁和性能">iOS中的各种锁和性能</a></h3>
<p>iOS 中有多达到13种锁，其性能 OSSpinLock 自旋锁和 dispatch_semaphore 信号量最高，<code>@synchronized</code> 最低：</p>
<ul>
<li>OSSpinLock 自旋锁</li>
<li>dispatch_semaphore信号量</li>
<li>os_unfair_lock 互斥锁</li>
<li>pthread_mutex 递归锁</li>
<li>pthread_mutex 条件锁</li>
<li>dispatch_queue(DISPATCH_QUEUE_SERIAL)</li>
<li>NSLock</li>
<li>NSRecursiveLock</li>
<li>NSCondition</li>
<li>NSConditionLock</li>
<li>@synchronized 对 mutex 递归锁的封装，然后进行加锁、解锁操作</li>
<li>dispatch_barrier_async 栅栏</li>
<li>dispatch_group 调度组</li>
</ul>
<h3 id="osspinlock自旋锁-存在的问题"><a class="header" href="#osspinlock自旋锁-存在的问题">OSSpinLock自旋锁 存在的问题</a></h3>
<p>OSSpinLock 不再安全，主要原因发生在低优先级线程拿到锁时，高优先级线程进入忙等(busy-wait)状态，消耗大量 CPU 时间，从而导致低优先级线程拿不到 CPU 时间，也就无法完成任务并释放锁。这种问题被称为<strong>优先级反转</strong>。</p>
<p>为什么忙等会导致低优先级线程拿不到时间片？这还得从操作系统的线程调度说起。</p>
<p>现代操作系统在管理普通线程时，通常采用时间片轮转算法(Round Robin，简称 RR)。每个线程会被分配一段时间片(quantum)，通常在 10-100 毫秒左右。当线程用完属于自己的时间片以后，就会被操作系统挂起，放入等待队列中，直到下一次被分配时间片。</p>
<h3 id="自旋锁和互斥锁分别的适用场景"><a class="header" href="#自旋锁和互斥锁分别的适用场景">自旋锁和互斥锁分别的适用场景？</a></h3>
<ul>
<li>
<p>自旋锁：</p>
<ul>
<li>预计线程等待锁的时间很短</li>
<li>加锁的代码（临界区）经常被调用，但竞争情况很少发生</li>
<li>CPU资源不紧张</li>
<li>多核处理器</li>
</ul>
</li>
<li>
<p>互斥锁：</p>
<ul>
<li>预计线程等待锁的时间较长</li>
<li>单核处理器</li>
<li>临界区有IO操作</li>
<li>临界区代码复杂或者循环量大</li>
<li>临界区竞争非常激烈</li>
</ul>
</li>
</ul>
<h3 id="synchronized-原理"><a class="header" href="#synchronized-原理">@synchronized 原理</a></h3>
<pre><code class="language-objc">@synchronized(self) {
    // task 
}
</code></pre>
<p>这其实是一个 OC 层面的锁， 主要是通过牺牲性能换来语法上的简洁与可读。</p>
<p><code>@synchronized</code> 后面需要紧跟一个 ObjC 对象，它实际上是把这个对象当做锁来使用。这是通过一个哈希表map来实现的，在底层使用了一个互斥锁的数组，通过对对象去哈希值（采用的是对象obj作为key）来得到对应的互斥锁。</p>
<p>优点就是使用方便，不关心成对出现。缺点就是性能开销大，查找线程锁太耗时。</p>
<h2 id="死锁"><a class="header" href="#死锁">死锁</a></h2>
<p>死锁是由于多个线程（进程）在执行过程中，因为争夺资源而造成的互相等待现象，你可以理解为卡主了。产生死锁的必要条件有四个：</p>
<ul>
<li>互斥条件 ： 指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。</li>
<li>请求和保持条件 ： 指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。</li>
<li>不可剥夺条件 ： 指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。</li>
<li>环路等待条件 ： 指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。</li>
</ul>
<p>总结来说就是 <strong>同步任务 + 串行队列</strong> 就会出现队列阻塞，产生死锁现象。常见的有：</p>
<ul>
<li>
<p>最常见的就是 同步函数 + 主队列 的组合，本质是队列阻塞，比如在主线程中使用 <code>dispatch_sync</code> ：</p>
<pre><code class="language-objc">- (void)viewDidLoad {
    [super viewDidLoad];
    NSLog(@&quot;1&quot;);
    dispatch_sync(dispatch_get_main_queue(), ^{
        NSLog(@&quot;2&quot;);
    });
    NSLog(@&quot;3&quot;);
}

</code></pre>
</li>
<li>
<p>另外，子线程在串行队列中进行同步操作,也会死锁：</p>
<pre><code class="language-objc">dispatch_queue_t queue = dispatch_queue_create(&quot;com.xxx.xxx&quot;, DISPATCH_QUEUE_SERIAL);
dispatch_async(queue, ^{
    dispatch_sync(queue, ^{
        NSLog(@&quot;sync: %@&quot;, [NSThread currentThread]); // 出现死锁：同步任务 + 串行队列
    });
});
</code></pre>
</li>
</ul>
<h2 id="atomic-和-nonatomic-的区别"><a class="header" href="#atomic-和-nonatomic-的区别"><code>atomic</code> 和 <code>nonatomic</code> 的区别?</a></h2>
<p><code>atomic</code> 与 <code>nonatomic</code> 的主要区别就是系统自动生成的 getter/setter 方法不一样:</p>
<ul>
<li>
<p><code>atomic</code> 系统自动生成的 getter/setter 方法会进行加锁操作</p>
</li>
<li>
<p><code>nonatomic</code> 系统自动生成的 getter/setter 方法不会进行加锁操作，但更快，推荐使用 <code>nonatomic</code></p>
</li>
</ul>
<h2 id="atomic-修饰的属性是绝对安全的吗"><a class="header" href="#atomic-修饰的属性是绝对安全的吗"><code>atomic</code> 修饰的属性是绝对安全的吗？</a></h2>
<p>atomic是原子的，表示属性的 setter、getter 方法是原子的，对其进行了加锁、解锁操作。但是对象的其它方法就没有，如果多线程调用其它方法进行读写，这个时候就容易崩溃了。</p>
<p>比如 NSMutableArray 采用 atomic，对其 setter/getter 进行了加解锁的操作，但是 addObject: 却没有，当多条线程进行 add 的时候就会crash：</p>
<pre><code class="language-objc">- (void)viewDidLoad {
    [super viewDidLoad];
    
    self.numbers = [NSMutableArray array];
    dispatch_queue_t gloabl_queue = dispatch_get_global_queue(0, 0);
    dispatch_async(gloabl_queue, ^{
        for (int i = 0; i &lt; 100; i ++) {
            [self.numbers addObject:[NSNumber numberWithInt:i]];
        }
        NSLog(@&quot;count: %d&quot;, [self.numbers count]);
    });
}
</code></pre>
<p>实际上应当对 addObject: 进行加锁：</p>
<pre><code class="language-objc">- (void)viewDidLoad {
    [super viewDidLoad];
    
    self.numbers = [NSMutableArray array];
    
    self.lock = [[NSLock alloc] init];
    
    dispatch_queue_t gloabl_queue = dispatch_get_global_queue(0, 0);
    dispatch_async(gloabl_queue, ^{
        for (int i = 0; i &lt; 100; i ++) {
            [self.lock lock];
            [self.numbers addObject:[NSNumber numberWithInt:i]];
            [self.lock unlock];
        }
        NSLog(@&quot;count: %d&quot;, [self.numbers count]); // count: 100
    });
}
</code></pre>
<h2 id="atomic-的进行加锁的时候使用的是什么锁"><a class="header" href="#atomic-的进行加锁的时候使用的是什么锁"><code>atomic</code> 的进行加锁的时候使用的是什么锁？</a></h2>
<p>从 runtime 的源码 objc4的objc-accessors.mm 来看，采用的是 spinlock_t 自旋锁：</p>
<pre><code class="language-objc">id objc_getProperty(id self, SEL _cmd, ptrdiff_t offset, BOOL atomic) {
    if (offset == 0) {
        return object_getClass(self);
    }

    // Retain release world
    id *slot = (id*) ((char*)self + offset);
    if (!atomic) return *slot;
        
    // Atomic retain release world
    spinlock_t&amp; slotlock = PropertyLocks[slot];
    slotlock.lock();
    id value = objc_retain(*slot);
    slotlock.unlock();
    
    // for performance, we (safely) issue the autorelease OUTSIDE of the spinlock.
    return objc_autoreleaseReturnValue(value);
}
</code></pre>
<pre><code class="language-objc">static inline void reallySetProperty(id self, SEL _cmd, id newValue, ptrdiff_t offset, bool atomic, bool copy, bool mutableCopy)
{
    if (offset == 0) {
        object_setClass(self, newValue);
        return;
    }

    id oldValue;
    id *slot = (id*) ((char*)self + offset);

    if (copy) {
        newValue = [newValue copyWithZone:nil];
    } else if (mutableCopy) {
        newValue = [newValue mutableCopyWithZone:nil];
    } else {
        if (*slot == newValue) return;
        newValue = objc_retain(newValue);
    }

    if (!atomic) {
        oldValue = *slot;
        *slot = newValue;
    } else {
        spinlock_t&amp; slotlock = PropertyLocks[slot];
        slotlock.lock();
        oldValue = *slot;
        *slot = newValue;        
        slotlock.unlock();
    }

    objc_release(oldValue);
}
</code></pre>
<h2 id="nsmutablearray和-nsmutabledictionary-是线程安全的吗nscache-呢"><a class="header" href="#nsmutablearray和-nsmutabledictionary-是线程安全的吗nscache-呢"><code>NSMutableArray</code>、和 <code>NSMutableDictionary</code> 是线程安全的吗？<code>NSCache</code> 呢？</a></h2>
<ul>
<li>
<p><code>NSCache</code> 是线程安全的</p>
</li>
<li>
<p><code>NSMutableArray</code>、和 <code>NSMutableDictionary</code> 不是线程安全的。</p>
</li>
</ul>
<p>1.如果多个线程同时操作同一个array会出现crash</p>
<pre><code class="language-objc">    NSMutableArray *testArray = [NSMutableArray array];
    for (int i = 0; i &lt; 100; i++) {
        dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
            NSString *str = [NSString stringWithFormat:@&quot;第%d个元素&quot;, i];
            [testArray addObject:str];
        });
    }
</code></pre>
<p>2.读操作不涉及array的修改，多个线程同时读数据没有问题</p>
<pre><code class="language-objc">    NSMutableArray *testArray = [NSMutableArray array];
    for (int i = 0; i &lt; 100; i++) {
        NSString *str = [NSString stringWithFormat:@&quot;第%d个元素&quot;, i];
        [testArray addObject:str];
    }
    
    for (int i = 0; i &lt; testArray.count; i++) {
        dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
            NSString *str = [testArray objectAtIndex:i];
            NSLog(@&quot;%@&quot;, str);
        });
    }
</code></pre>
<p>3.线程A对array进行读操作，线程B对array进行写操作，也会crash</p>
<h3 id="如何实现一个线程安全的-nsmutablearray"><a class="header" href="#如何实现一个线程安全的-nsmutablearray">如何实现一个线程安全的 NSMutableArray</a></h3>
<ul>
<li>方案1: 对读写操作都加锁，效率低，因为读操作数据是安全的，可以并行。</li>
<li>方案2: 读写锁实现多读单写。</li>
</ul>
<h4 id="并发队列gcd栅栏块barrier"><a class="header" href="#并发队列gcd栅栏块barrier">并发队列+GCD栅栏块（barrier）</a></h4>
<p>使用并发队列+GCD栅栏块（barrier）实现多读单写高效线程安全的NSMutableArray</p>
<p>要实现多读单写，即：</p>
<ul>
<li>
<p>读操作和读操作并发</p>
</li>
<li>
<p>读操作和写操作互斥</p>
</li>
<li>
<p>读操作和读操作互斥</p>
</li>
<li>
<p>读操作：使用<code>dispatch_sync</code>操作并发队列 </p>
</li>
<li>
<p>写操作：使用<code>dispatch_barrier_async</code>操作并发队列：在A进行读处理的时候，B也可以额进行读取，但是不能进行写</p>
</li>
</ul>
<pre><code class="language-objc">@interface SafetyMutableArray ()

@property (nonatomic, strong) dispatch_queue_t readWriteQueue;
@property (nonatomic, strong) NSMutableArray *array;

@end

@implementation SafetyMutableArray

- (instancetype)init {
    self = [super init];
    if (self) {
        _array = [NSMutableArray array];
        _readWriteQueue = dispatch_queue_create(&quot;SaftyMutableArray.queue&quot;, DISPATCH_QUEUE_CONCURRENT);
    }
    return self;
}

#pragma mark - 读操作

- (NSUInteger)count{
    __block NSUInteger count;
    dispatch_sync(self.readWriteQueue, ^{
        count = self.array.count;
    });
    return count;
}

- (id)objectAtIndex:(NSUInteger)index {
    __block id obj = nil;
    dispatch_sync(self.readWriteQueue, ^{
        obj = [self.array objectAtIndex:index];
    });
    return obj;
}

- (nullable id)firstObject {
    __block id obj = nil;
    dispatch_sync(self.readWriteQueue, ^{
        obj= [self.array firstObject];
    });
    return obj;
}

- (nullable id)lastObject {
    __block id obj = nil;
    dispatch_sync(self.readWriteQueue, ^{
        obj = [self.array lastObject];
    });
    return obj;
}

#pragma mark - 写操作

- (void)addObject:(id)anObject {
    dispatch_barrier_async(self.readWriteQueue, ^{
        [self.array addObject:anObject];
    });
}

- (void)insertObject:(id)anObject atIndex:(NSUInteger)index {
    dispatch_barrier_async(self.readWriteQueue, ^{
        [self.array insertObject:anObject atIndex:index];
    });
}

- (void)removeAllObjects {
    dispatch_barrier_async(self.readWriteQueue, ^{
        [self.array removeAllObjects];
    });
}
                           
- (void)removeLastObject {
    dispatch_barrier_async(self.readWriteQueue, ^{
        [self.array removeLastObject];
    });
}

- (void)removeObjectAtIndex:(NSUInteger)index {
    dispatch_barrier_async(self.readWriteQueue, ^{
        [self.array removeObjectAtIndex:index];
    });
}

- (void)replaceObjectAtIndex:(NSUInteger)index withObject:(id)anObject {
    dispatch_barrier_async(self.readWriteQueue, ^{
        [self.array replaceObjectAtIndex:index withObject:anObject];
    });
}
</code></pre>
<h4 id="pthread_rwlock-读写锁"><a class="header" href="#pthread_rwlock-读写锁">pthread_rwlock 读写锁</a></h4>
<p>Apple 提供了读写锁，可以直接使用：</p>
<pre><code class="language-objc">- (id)objectAtIndex:(NSUInteger)index {
    pthread_rwlock_rdlock(&amp;_lock);
    id obj = nil;
    obj = [self.array objectAtIndex:index];
    pthread_rwlock_unlock(&amp;_lock);
    return obj;
}

- (void)addObject:(id)obj {
    pthread_rwlock_wrlock(&amp;_lock);
    [self.array addObject:obj];
    pthread_rwlock_unlock(&amp;_lock);
}
</code></pre>
<h1 id="dispatch_once-原理"><a class="header" href="#dispatch_once-原理">dispatch_once 原理</a></h1>
<p>dispatch_once 能保证任务只会被执行一次，即使同时多线程调用也是线程安全的。常用于创建单例、swizzeld method等功能。</p>
<h2 id="为什么可以保证只执行一次"><a class="header" href="#为什么可以保证只执行一次">为什么可以保证只执行一次？</a></h2>
<p><code>dispatch_once</code> 封装并执行了 <code>dispatch_once_f</code> 函数，其内部使用原子性操作block执行完成标记位，同时用信号量确保只有一个线程执行block，等block执行完再唤醒所有等待中的线程。</p>
<h2 id="dispatch_once_f-实现原理"><a class="header" href="#dispatch_once_f-实现原理">dispatch_once_f 实现原理？</a></h2>
<p>dispatch_once_f 的源码:</p>
<pre><code class="language-c">// Block 数据结构
struct Block_layout {
    // 指向表明该block类型的类
    void *isa;
    // 按bit位表示一些 block 的附加信息，比如判断 block 类型、判断 block 引用计数、判断 block 是否需要执行辅助函数等
    int flags;
    // 保留变量
    int reserved;
    // 函数指针，指向具体的 block 实现的函数调用地址
    void (*invoke)(void *, ...);
    struct Block_descriptor *descriptor;
    /* Imported variables. */
};

// 宏定义
// 触发 block 的实现
#define _dispatch_Block_invoke(bb) \
        ((dispatch_function_t)((struct Block_layout *)bb)-&gt;invoke)

// 入口方法
void dispatch_once(dispatch_once_t *val, dispatch_block_t block) {
    dispatch_once_f(val, block, _dispatch_Block_invoke(block));
}

#define DISPATCH_ONCE_DONE ((struct _dispatch_once_waiter_s *)~0l)

struct _dispatch_once_waiter_s {
    //链表下一个节点
    volatile struct _dispatch_once_waiter_s *volatile dow_next;
    // 信号量
    _dispatch_thread_semaphore_t dow_sema;
};

void dispatch_once_f(dispatch_once_t *val, void *ctxt, dispatch_function_t func) {
  	// volatileg 关键字编辑的变量 vval
    // 告诉编译器此指针指向的值随时可能被其他线程改变
    // 从而使得编译器不对此指针进行代码编译优化
    struct _dispatch_once_waiter_s * volatile *vval =
            (struct _dispatch_once_waiter_s**)val;
    struct _dispatch_once_waiter_s dow = { NULL, 0 };
    struct _dispatch_once_waiter_s *tail, *tmp;
  	// 声明信号变量
    _dispatch_thread_semaphore_t sema;

    if (dispatch_atomic_cmpxchg(vval, NULL, &amp;dow, acquire)) {
        _dispatch_client_callout(ctxt, func);

        dispatch_atomic_maximally_synchronizing_barrier();
        // above assumed to contain release barrier
        tmp = dispatch_atomic_xchg(vval, DISPATCH_ONCE_DONE, relaxed);
        tail = &amp;dow;
        while (tail != tmp) {
            while (!tmp-&gt;dow_next) {
                dispatch_hardware_pause();
            }
            sema = tmp-&gt;dow_sema;
            tmp = (struct _dispatch_once_waiter_s*)tmp-&gt;dow_next;
            _dispatch_thread_semaphore_signal(sema);
        }
    } else {
        dow.dow_sema = _dispatch_get_thread_semaphore();
        tmp = *vval;
        for (;;) {
            if (tmp == DISPATCH_ONCE_DONE) {
                break;
            }
            if (dispatch_atomic_cmpxchgvw(vval, tmp, &amp;dow, &amp;tmp, release)) {
                dow.dow_next = tmp;
                _dispatch_thread_semaphore_wait(dow.dow_sema);
                break;
            }
        }
        _dispatch_put_thread_semaphore(dow.dow_sema);
    }
}
</code></pre>
<p>其内部定义了多个 _dispatch_once_waiter_s 结构体和一个 _dispatch_thread_semaphore_t 信号量，通过原子性操作 dispatch_atomic_cmpxchg 来判断标记值 vval 是否为 NULL (首次调用 dispatch_once 时，因为外部传入的 dispatch_once_t 变量值为 nil，所以 vval 会为NULL) ，如果为 NULL，则调用 _dispatch_client_callout 来执行回调，然后在回调执行完成之后，将 vval 的值更新成 DISPATCH_ONCE_DONE (表示任务已完成)，最后，对链表的节点进行遍历，并调用 _dispatch_thread_semaphore_signal 来唤醒等待中的信号量。</p>
<p>因为dispatch_atomic_cmpxchg是原子性操作，所以只有一个线程进入到该逻辑分支中，其他线程会进入另一个分支。</p>
<p>如果不为 NULL 或其他线程同时也调用 dispatch_once 时，会判断回调是否 已标记完成 ，如果已完成则跳出循环；否则就是更新链表并调用 _dispatch_thread_semaphore_wait 阻塞线程，等待回调被标记完成后，再唤醒当前等待的线程。</p>
<h2 id="dispatch_once-中的原子性操作是怎样的"><a class="header" href="#dispatch_once-中的原子性操作是怎样的">dispatch_once 中的原子性操作是怎样的？</a></h2>
<p>原子性操作是 dispatch_atomic_cmpxchg(vval, NULL, &amp;dow, acquire) ，会将 $dow 赋值给 vval ，如果 vval 的初始值为NULL，返回 YES ,否则返回 NO 。以及dispatch_atomic_xchg(vval, DISPATCH_ONCE_DONE) 将 vval 修改为指定状态 DISPATCH_ONCE_DONE。</p>
<h1 id="参考-8"><a class="header" href="#参考-8">参考</a></h1>
<ul>
<li><a href="http://shevakuilin.com/interview-dispatch-once/">dispatch_once</a></li>
<li><a href="https://xiaozhuanlan.com/topic/7916538240">深入浅出 GCD 之 dispatch_once</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="多线程题目"><a class="header" href="#多线程题目">多线程题目</a></h1>
<h2 id="1下列代码的输出"><a class="header" href="#1下列代码的输出">1.下列代码的输出</a></h2>
<pre><code class="language-objc">__block int a = 0;
while (a &lt; 5) {
	dispatch_async(dispatch_get_global_queue(0, 0), ^{
        a++;
	});
}
NSLog(@&quot;%d&quot;, a);
</code></pre>
<p>答案：&gt;= 5的值。</p>
<p>原因：dispatch_async 异步任务，执行完成的时间不确定。</p>
<h2 id="2下面代码的输出"><a class="header" href="#2下面代码的输出">2.下面代码的输出</a></h2>
<pre><code class="language-objc">dispatch_queue_t serial_queue = dispatch_queue_create(&quot;com.xxx.test&quot;, DISPATCH_QUEUE_SERIAL);

dispatch_sync(serial_queue, ^{
    sleep(3);
    NSLog(@&quot;task 1 %@&quot;, NSThread.currentThread);
});

dispatch_sync(serial_queue, ^{
    NSLog(@&quot;task 2 %@&quot;, NSThread.currentThread);
});

dispatch_async(serial_queue, ^{
    NSLog(@&quot;task 3 %@&quot;, NSThread.currentThread);
});

dispatch_async(serial_queue, ^{
    NSLog(@&quot;task 4 %@&quot;, NSThread.currentThread);
});

NSLog(@&quot;test end&quot;);
</code></pre>
<p>答案：task 1 -&gt; task 2 -&gt; test end -&gt; task 3 和 4 的顺序不确定。</p>
<p>原因：<code>dispatch_sync</code> 是同步，会阻塞当前线程，由于 DISPATCH_QUEUE_SERIAL 是串行队列，所以task 1 和 2 会串行按顺序执行，而 <code>dispatch_async</code>是异步任务，不会阻塞当前线程，会在其它线程一个一个执行，则顺序不一定，取决于任务耗时。</p>
<h2 id="3下列代码的输出"><a class="header" href="#3下列代码的输出">3.下列代码的输出</a></h2>
<pre><code class="language-objc">dispatch_queue_t queue = dispatch_queue_create(&quot;com.xxx.test&quot;, DISPATCH_QUEUE_CONCURRENT);
NSMutableArray *marr = [NSMutableArray array];
for (int i = 0; i &lt; 1000; i++) {
    dispatch_async(queue, ^{
        [marr addObject:@(i)];
    });
}
NSLog(@&quot;%lu&quot;, marr.count);
</code></pre>
<p>答案：会 crash<br />
原因：<code>dispatch_async</code> 异步任务 + DISPATCH_QUEUE_CONCURRENT 并行队列，会开辟多个线程执行，调用 marr 的 <code>addObject:</code> 方法，多个线程抢占同一个资源，会 crash。</p>
<h2 id="4下列代码的运行结果"><a class="header" href="#4下列代码的运行结果">4.下列代码的运行结果</a></h2>
<pre><code class="language-objc">- (void)viewDidLoad {
   [super viewDidLoad];
   NSLog(@&quot;1&quot;);
   dispatch_sync(dispatch_get_main_queue(), ^{
       NSLog(@&quot;2&quot;);
   });
   NSLog(@&quot;3&quot;);
}
</code></pre>
<p>答案：输出 1 后发生死锁，主线程卡死。<br />
原因：同步任务会阻塞当前线程，然后把 Block 中的任务放到指定的队列中执行，只有等到 Block 中的任务完成后才会让当前线程继续往下运行。那么这里的步骤就是：打印完第一句后，dispatch_sync 立即阻塞当前的主线程，然后把 Block 中的任务放到 main_queue 中，将 main_queue 中的任务会被取出来放到主线程中执行，但主线程这个时候已经被阻塞了，所以 Block 中的任务就不能完成，它不完成，dispatch_sync 就会一直阻塞主线程，这就是死锁现象。导致主线程一直卡死。</p>
<h2 id="5下面代码的运行结果"><a class="header" href="#5下面代码的运行结果">5.下面代码的运行结果</a></h2>
<pre><code class="language-objc">dispatch_queue_t queue = dispatch_get_global_queue(0, 0);
dispatch_async(queue, ^{
    NSLog(@&quot;1&quot;);
    dispatch_sync(queue, ^{
        NSLog(@&quot;2&quot;);
    });
    NSLog(@&quot;3&quot;);
});
NSLog(@&quot;4&quot;);
</code></pre>
<h2 id="6下面代码的运行结果"><a class="header" href="#6下面代码的运行结果">6.下面代码的运行结果</a></h2>
<pre><code class="language-objc">dispatch_queue_t queue = dispatch_queue_create(&quot;com.xxx.xxx&quot;, DISPATCH_QUEUE_SERIAL);
dispatch_async(queue, ^{
    NSLog(@&quot;1&quot;);
    dispatch_sync(queue, ^{
        NSLog(@&quot;2&quot;);
    });
    NSLog(@&quot;3&quot;);
});
NSLog(@&quot;4&quot;);
</code></pre>
<p>答案：会打印 “之前”、“之后” 和 “sync 之前”，然后死锁。<br />
原因：DISPATCH_QUEUE_SERIAL 创建了串行队列。由于 <code>dispatch_async</code> 是异步任务，则不阻塞当前线程，“之前”、“之后”会被执行。同时其中的“sync 之前”也会被执行。然后 <code>dispatch_sync</code> 是同步执行，于是它所在的线程会被阻塞，一直等到 sync 里的任务执行完才会继续往下。于是 sync 就把自己 Block 中的任务放到 queue 中，但是 queue 是一个串行队列，一次执行一个任务，所以 sync 的 block 必须等到前一个任务执行完毕，可万万没想到的是 queue 正在执行的任务就是被 sync 阻塞了的那个。于是又发生了死锁。所以 sync 所在的线程被卡死了。剩下的两句代码自然不会打印。</p>
<h2 id="7下面代码的运行结果把-0-换成-1-或者-2-后是什么结果"><a class="header" href="#7下面代码的运行结果把-0-换成-1-或者-2-后是什么结果">7.下面代码的运行结果。把 0 换成 1 或者 2 后是什么结果？</a></h2>
<pre><code class="language-objc">dispatch_semaphore_t t1 = dispatch_semaphore_create(0);

dispatch_async(dispatch_get_global_queue(0, 0), ^{
    NSLog(@&quot;1&quot;);
    dispatch_semaphore_signal(t1);
});
dispatch_semaphore_wait(t1, DISPATCH_TIME_FOREVER);

dispatch_async(dispatch_get_global_queue(0, 0), ^{
    NSLog(@&quot;2&quot;);
    sleep(2);
    dispatch_semaphore_signal(t1);
});
dispatch_semaphore_wait(t1, DISPATCH_TIME_FOREVER);

dispatch_async(dispatch_get_global_queue(0, 0), ^{
    NSLog(@&quot;3&quot;);
    dispatch_semaphore_signal(t1);
});
</code></pre>
<p>答案：1 -&gt; 2 -&gt; 3 顺序打印
原因：将最大并发数量设置为 0 后，就成了串行队列，按顺序执行。</p>
<p>将 0 修改为 1 和 2 后，顺序就不一定了，因为多个异步任务可以同时执行。</p>
<h2 id="8下面代码的运行结果-将-performselector-换成-performselectoronmainthread-呢"><a class="header" href="#8下面代码的运行结果-将-performselector-换成-performselectoronmainthread-呢">8.下面代码的运行结果? 将 <code>performSelector:</code> 换成 <code>performSelectorOnMainThread:</code> 呢？</a></h2>
<pre><code class="language-objc">- (void)viewDidLoad {
    [super viewDidLoad];
    
    dispatch_async(dispatch_get_global_queue(0, 0), ^{
        NSLog(@&quot;1&quot;);
        
        [self performSelector:@selector(test) withObject:nil afterDelay:0];
        
        NSLog(@&quot;3&quot;);
    });
}
</code></pre>
<p>答案：输出 1 3，不会输出 2<br />
原因：<code>performSelecter:</code> 在子线程是不起作用的，因为子线程默认没有 Runloop，也就没有 Timer。而 <code>performSelecter:</code> 的原理是内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。结局办法是采用 GCD timer。<a href="answer/06_thread/./answer/runloop/105_ans_ch_4_runloop_03.html">参考</a></p>
<p>将 <code>performSelector:</code> 换成 <code>performSelectorOnMainThread:</code>的结果：</p>
<pre><code class="language-objc">- (void)viewDidLoad {
    [super viewDidLoad];
    
    dispatch_async(dispatch_get_global_queue(0, 0), ^{
        NSLog(@&quot;1&quot;);
        
        [self performSelectorOnMainThread:@selector(test) withObject:nil waitUntilDone:YES];
        
        NSLog(@&quot;3&quot;);
    });
}

- (void)test {
    NSLog(@&quot;2&quot;);
}
</code></pre>
<p>答案：输出 1 2 3<br />
原因：该方法回强制回主线程，设置 waitUntilDone 参数为 YES，则表示等待主线程任务执行完成之后再回来执行。如果设置为 NO，则输出 1 3 2。</p>
<h2 id="9下面代码的运行结果"><a class="header" href="#9下面代码的运行结果">9.下面代码的运行结果？</a></h2>
<pre><code class="language-objc">dispatch_async(dispatch_get_main_queue(), ^{
    NSLog(@&quot;1, thrad: %@&quot;, [NSThread currentThread]);
});

dispatch_async(dispatch_get_main_queue(), ^{
    NSLog(@&quot;2, thrad: %@&quot;, [NSThread currentThread]);
});

dispatch_async(dispatch_get_main_queue(), ^{
    NSLog(@&quot;3, thrad: %@&quot;, [NSThread currentThread]);
});
</code></pre>
<p>答案：1 2 3 并且线程都是主线程。<br />
原因：主队列是串行队列，放在串行队列中的任务不会开辟新的线程执行。</p>
<h2 id="10-有一个-generatecontent-比较耗时的方法会生成特定的内容返回现在需要调用这个方法1-如果方法立马返回则立即返回这内容-2-如果-3s-未返回则返回为空如何实现"><a class="header" href="#10-有一个-generatecontent-比较耗时的方法会生成特定的内容返回现在需要调用这个方法1-如果方法立马返回则立即返回这内容-2-如果-3s-未返回则返回为空如何实现">10. 有一个 <code>generateContent</code> 比较耗时的方法，会生成特定的内容返回，现在需要调用这个方法：1. 如果方法立马返回，则立即返回这内容 2. 如果 3s 未返回，则返回为空。如何实现？</a></h2>
<p>可以使用信号量 <code>dispatch_semaphore_t</code> 和 <code>dispatch_queue_t</code> 实现：</p>
<h3 id="信号量-dispatch_semaphore_t实现"><a class="header" href="#信号量-dispatch_semaphore_t实现">信号量 <code>dispatch_semaphore_t</code>实现</a></h3>
<p><code>dispatch_async</code> 异步调用 <code>generateContent</code> 方法，方法执行完成后进行信号量 singal ，信号量 <code>dispatch_semaphore_t</code> wait 时候可以设置超时时间为 3s即可:</p>
<pre><code class="language-objc">- (NSString *)getSomeContent {
    __block NSString *str;
    dispatch_semaphore_t sempahore = dispatch_semaphore_create(0);
    dispatch_queue_t queue = dispatch_get_global_queue(0, 0);
    dispatch_async(queue, ^{ // 异步调用
        str = [self generateContent]; // 可能的耗时操作
        dispatch_semaphore_signal(sempahore);
    });
    
    dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, 3 * NSEC_PER_SEC); // 设置 3s 超时
    dispatch_semaphore_wait(sempahore, time);
    
    return str;
}

- (NSString *)generateContent {
    sleep(5); // 模拟耗时操作
    return @&quot;generateContent Test&quot;;
}
</code></pre>
<h3 id="dispatch_queue_t-实现"><a class="header" href="#dispatch_queue_t-实现"><code>dispatch_queue_t</code> 实现</a></h3>
<p>使用 <code>dispatch_group_enter</code> 和 <code>dispatch_group_leave</code> 和实现， <code>dispatch_queue_t</code> 设置 wait 超时时间即可：</p>
<pre><code class="language-objc">- (NSString *)getSomeContent {
    __block NSString *str;
    dispatch_group_t group = dispatch_group_create();
    dispatch_group_enter(group);
    
    dispatch_queue_t queue = dispatch_get_global_queue(0, 0);
    dispatch_async(queue, ^{ // 异步调用
        str = [self generateContent]; // 可能的耗时操作
        dispatch_group_leave(group);
    });
    
    dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, 3 * NSEC_PER_SEC); // 设置 3s 超时
    dispatch_group_wait(group, time);
    return str;
}
</code></pre>
<h2 id="11-有abc三个耗时任务需要异步执行当这三个任务都执行完成后更新ui如何实现"><a class="header" href="#11-有abc三个耗时任务需要异步执行当这三个任务都执行完成后更新ui如何实现">11. 有A、B、C三个耗时任务需要异步执行，当这三个任务都执行完成后更新UI，如何实现？</a></h2>
<h3 id="方法一使用-dispatch_group-结合-enter-和-leave"><a class="header" href="#方法一使用-dispatch_group-结合-enter-和-leave">方法一、使用 <code>dispatch_group</code> 结合 enter 和 leave</a></h3>
<p>如果仅仅是使用 <code>dispatch_group</code>，会出现这种情况：如果这三个任务里面又有异步任务，那么会先执行notifiy，比如：</p>
<pre><code class="language-objc">- (void)gcdGroupTest {
    // 创建 group 和 queue
    dispatch_group_t group = dispatch_group_create();
    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
    
    dispatch_group_async(group, queue, ^{
        dispatch_async(queue, ^{ // 里面有异步任务
            for (int i = 0; i &lt; 15; i++) {
                NSLog(@&quot;group-0 - %d， 当前线程: %@&quot;, i, [NSThread currentThread]);
            }
        });
    });
    
    dispatch_group_async(group, queue, ^{
        dispatch_async(queue, ^{
            for (int i = 0; i &lt; 10; i++) {
                NSLog(@&quot;group-1 - %d， 当前线程: %@&quot;, i, [NSThread currentThread]);
            }
        });
    });
    
    dispatch_group_async(group, queue, ^{
        dispatch_async(queue, ^{
            for (int i = 0; i &lt; 5; i++) {
                NSLog(@&quot;group-2 - %d， 当前线程: %@&quot;, i, [NSThread currentThread]);
            }
        });
    });
    
    // 执行完成后通知
    dispatch_group_notify(group, queue, ^{
        NSLog(@&quot;finished: %@&quot;, [NSThread currentThread]);
    });
}
</code></pre>
<p>使用 enter 标记一个 block 被加入到了队列组group中，此时group中的任务的引用计数会加1，任务执行完成后进行 level，标记队列组里的一个 block 已经执行完成，队列组中的任务的引用计数会减1，当队列组里的任务的引用计数等于0时，会调用dispatch_group_notify函数。</p>
<pre><code class="language-objc">- (void)gcdGroupTest {
    // 创建 group 和 queue
    dispatch_group_t group = dispatch_group_create();
    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
    
    dispatch_group_enter(group); // enter
    dispatch_group_async(group, queue, ^{
        dispatch_async(queue, ^{ // 异步任务
            for (int i = 0; i &lt; 15; i++) {
                NSLog(@&quot;group-0 - %d， 当前线程: %@&quot;, i, [NSThread currentThread]);
            }
            dispatch_group_leave(group);// leave
        });
    });
    
    dispatch_group_enter(group);
    dispatch_group_async(group, queue, ^{
        dispatch_async(queue, ^{
            for (int i = 0; i &lt; 10; i++) {
                NSLog(@&quot;group-1 - %d， 当前线程: %@&quot;, i, [NSThread currentThread]);
            }
            dispatch_group_leave(group);
        });
    });
    
    dispatch_group_enter(group);
    dispatch_group_async(group, queue, ^{
        dispatch_async(queue, ^{
            for (int i = 0; i &lt; 5; i++) {
                NSLog(@&quot;group-2 - %d， 当前线程: %@&quot;, i, [NSThread currentThread]);
            }
            dispatch_group_leave(group);
        });
    });
    
    // 执行完成后通知
    dispatch_group_notify(group, queue, ^{
        NSLog(@&quot;finished: %@&quot;, [NSThread currentThread]);
    });
}
</code></pre>
<h3 id="方法二使用-dispatch_group-结合信号量-wait-和-signal"><a class="header" href="#方法二使用-dispatch_group-结合信号量-wait-和-signal">方法二、使用 <code>dispatch_group</code> 结合信号量 wait 和 signal</a></h3>
<ol>
<li>
<p>将每个请求包装成一个任务异步提交到任务组里，每个任务在一开始创建一个信号量，value值为0，任务最后在网络请求完成前进行信号量的等待，如果网络请求完成，则调用 signal 对信号值加1，则线程不再进行信号量的等待，继续往下执行。</p>
</li>
<li>
<p>当所有请求都完成时，会在dispatch_group_notify里的回调进行相应的处理。</p>
</li>
</ol>
<pre><code class="language-objc">- (void)gcdGroupTest {
    // 创建 group 和 queue
    dispatch_group_t group = dispatch_group_create();
    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
    
    // 创建信号量
    dispatch_semaphore_t sempahore = dispatch_semaphore_create(0);
    
    dispatch_group_async(group, queue, ^{
        dispatch_async(queue, ^{ // 异步任务
            for (int i = 0; i &lt; 15; i++) {
                NSLog(@&quot;group-0 - %d， 当前线程: %@&quot;, i, [NSThread currentThread]);
            }
            
            // 完成迭代后, 增加信号量
            dispatch_semaphore_signal(sempahore);
        });
        
        // 在迭代完成之前, 信号量等待
        dispatch_semaphore_wait(sempahore, DISPATCH_TIME_FOREVER);
    });
    
    
    dispatch_group_async(group, queue, ^{
        dispatch_async(queue, ^{
            for (int i = 0; i &lt; 10; i++) {
                NSLog(@&quot;group-1 - %d， 当前线程: %@&quot;, i, [NSThread currentThread]);
            }
            dispatch_semaphore_signal(sempahore);
        });
        dispatch_semaphore_wait(sempahore, DISPATCH_TIME_FOREVER);
    });
    
    
    dispatch_group_async(group, queue, ^{
        dispatch_async(queue, ^{
            for (int i = 0; i &lt; 5; i++) {
                NSLog(@&quot;group-2 - %d， 当前线程: %@&quot;, i, [NSThread currentThread]);
            }
            dispatch_semaphore_signal(sempahore);
        });
        dispatch_semaphore_wait(sempahore, DISPATCH_TIME_FOREVER);
    });
    
    // 执行完成后通知
    dispatch_group_notify(group, queue, ^{
        NSLog(@&quot;finished: %@&quot;, [NSThread currentThread]);
    });
}
</code></pre>
<p>或者每个任务一个信号量也是OK的；</p>
<pre><code class="language-objc">- (void)gcdGroupTest {
    // 创建 group 和 queue
    dispatch_group_t group = dispatch_group_create();
    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
    
    // 创建信号量
    dispatch_semaphore_t sempahore = dispatch_semaphore_create(0);
    
    dispatch_group_async(group, queue, ^{
        dispatch_async(queue, ^{ // 异步任务
            for (int i = 0; i &lt; 15; i++) {
                NSLog(@&quot;group-0 - %d， 当前线程: %@&quot;, i, [NSThread currentThread]);
            }
            
            // 完成迭代后, 增加信号量
            dispatch_semaphore_signal(sempahore);
        });
        
        // 在迭代完成之前, 信号量等待
        dispatch_semaphore_wait(sempahore, DISPATCH_TIME_FOREVER);
    });
    
    dispatch_semaphore_t sempahore2 = dispatch_semaphore_create(0);
    
    dispatch_group_async(group, queue, ^{
        dispatch_async(queue, ^{
            for (int i = 0; i &lt; 10; i++) {
                NSLog(@&quot;group-1 - %d， 当前线程: %@&quot;, i, [NSThread currentThread]);
            }
            dispatch_semaphore_signal(sempahore2);
        });
        dispatch_semaphore_wait(sempahore2, DISPATCH_TIME_FOREVER);
    });
    
    dispatch_semaphore_t sempahore3 = dispatch_semaphore_create(0);
    dispatch_group_async(group, queue, ^{
        dispatch_async(queue, ^{
            for (int i = 0; i &lt; 5; i++) {
                NSLog(@&quot;group-2 - %d， 当前线程: %@&quot;, i, [NSThread currentThread]);
            }
            dispatch_semaphore_signal(sempahore3);
        });
        dispatch_semaphore_wait(sempahore3, DISPATCH_TIME_FOREVER);
    });
    
    // 执行完成后通知
    dispatch_group_notify(group, queue, ^{
        NSLog(@&quot;finished: %@&quot;, [NSThread currentThread]);
    });
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="最大并发数量"><a class="header" href="#最大并发数量">最大并发数量</a></h1>
<h2 id="nsoperation"><a class="header" href="#nsoperation">NSOperation</a></h2>
<pre><code class="language-objc">NSOperationQueue *queue = [[NSOperationQueue alloc]init];
queue.maxConcurrentOperationCount = 3;
</code></pre>
<h2 id="gcd-实现最大并发数"><a class="header" href="#gcd-实现最大并发数">GCD 实现最大并发数</a></h2>
<h3 id="1-使用信号量-dispatch_semaphore_t控制最大并发数"><a class="header" href="#1-使用信号量-dispatch_semaphore_t控制最大并发数">1. 使用信号量 <code>dispatch_semaphore_t</code>控制最大并发数</a></h3>
<p>比如，下面的代码控制最大并发数为3:</p>
<pre><code class="language-objc">- (void)maxConcurrent {
    dispatch_semaphore_t semaphore = dispatch_semaphore_create(3); 
    
    for (int i = 0; i &lt; 10; i++) {
        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);
        NSLog(@&quot;开始执行第 %d 条任务&quot;, i);
        dispatch_async(dispatch_get_global_queue(0, 0), ^{
            [self networkTaskCompletedBlock:^{
                NSLog(@&quot;第 %d 条任务在 %@ 线程执行完成!&quot;, i, [NSThread currentThread]);
                dispatch_semaphore_signal(semaphore);
            }];
        });
    }
}

- (void)networkTaskCompletedBlock:(void (^)(void))completedBlock {
    sleep(2);
    if (completedBlock) {
        completedBlock();
    }
}
</code></pre>
<p>对应的输出为：</p>
<pre><code class="language-c">开始执行第 0 条任务
开始执行第 1 条任务
开始执行第 2 条任务
第 0 条任务在 &lt;NSThread: 0x600000360380&gt;{number = 7, name = (null)} 线程执行完成!
第 1 条任务在 &lt;NSThread: 0x600000321080&gt;{number = 6, name = (null)} 线程执行完成!
第 2 条任务在 &lt;NSThread: 0x600000361a80&gt;{number = 5, name = (null)} 线程执行完成!
开始执行第 3 条任务
开始执行第 4 条任务
开始执行第 5 条任务
第 4 条任务在 &lt;NSThread: 0x600000321080&gt;{number = 6, name = (null)} 线程执行完成!
第 3 条任务在 &lt;NSThread: 0x600000361a80&gt;{number = 5, name = (null)} 线程执行完成!
开始执行第 6 条任务
第 5 条任务在 &lt;NSThread: 0x600000360380&gt;{number = 7, name = (null)} 线程执行完成!
开始执行第 7 条任务
开始执行第 8 条任务
第 8 条任务在 &lt;NSThread: 0x600000321080&gt;{number = 6, name = (null)} 线程执行完成!
第 7 条任务在 &lt;NSThread: 0x600000360380&gt;{number = 7, name = (null)} 线程执行完成!
第 6 条任务在 &lt;NSThread: 0x600000361a80&gt;{number = 5, name = (null)} 线程执行完成!
开始执行第 9 条任务
第 9 条任务在 &lt;NSThread: 0x600000360380&gt;{number = 7, name = (null)} 线程执行完成!
</code></pre>
<p>从输出中可以看到，最多有三个任务同时执行。</p>
<h1 id="设置依赖"><a class="header" href="#设置依赖">设置依赖</a></h1>
<p>NSOperation 有一个非常实用的功能，那就是添加依赖。比如有 3 个任务：</p>
<ul>
<li>A: 从服务器上下载一张图片</li>
<li>B：给这张图片加个水印，</li>
<li>C：把图片返回给服务器。</li>
</ul>
<p>这时就可以用到依赖了:</p>
<h2 id="nsoperation-设置依赖-1"><a class="header" href="#nsoperation-设置依赖-1">NSOperation 设置依赖</a></h2>
<pre><code class="language-objc">- (void)operationTest {
    // 不能添加相互依赖，会死锁，比如 A依赖B，B依赖A。
    //1.任务一：下载图片
    NSBlockOperation *operation1 = [NSBlockOperation blockOperationWithBlock:^{
        NSLog(@&quot;下载图片 - %@&quot;, [NSThread currentThread]);
        [NSThread sleepForTimeInterval:1.0];
    }];
    
    //2.任务二：打水印
    NSBlockOperation *operation2 = [NSBlockOperation blockOperationWithBlock:^{
        NSLog(@&quot;打水印   - %@&quot;, [NSThread currentThread]);
        [NSThread sleepForTimeInterval:1.0];
    }];
    
    //3.任务三：上传图片
    NSBlockOperation *operation3 = [NSBlockOperation blockOperationWithBlock:^{
        NSLog(@&quot;上传图片 - %@&quot;, [NSThread currentThread]);
        [NSThread sleepForTimeInterval:1.0];
    }];
    
    //4.设置依赖
    [operation2 addDependency:operation1];      //任务二依赖任务一
    [operation3 addDependency:operation2];      //任务三依赖任务二
    
    //5.创建队列并加入任务
    NSOperationQueue *queue = [[NSOperationQueue alloc] init];
    [queue addOperations:@[operation3, operation2, operation1] waitUntilFinished:NO];
}
</code></pre>
<h2 id="gcd-实现-nsoperation-的依赖"><a class="header" href="#gcd-实现-nsoperation-的依赖">GCD 实现 NSOperation 的依赖</a></h2>
<p>GCD 没有提供设置依赖相关的API，但是可以通过 group 来实现，group 中的任务在执行完之后会 notifiy：</p>
<pre><code class="language-objc">- (void)gcdGroupTest {
    dispatch_group_t group = dispatch_group_create();
    dispatch_queue_t queue = dispatch_get_global_queue(0, 0);
    
    dispatch_group_async(group, queue, ^{
        NSLog(@&quot;下载图片 - %@&quot;, [NSThread currentThread]);
        [NSThread sleepForTimeInterval:1.0];w
    });
    
    dispatch_group_notify(group, queue, ^{
        
        dispatch_group_async(group, queue, ^{
            NSLog(@&quot;打水印   - %@&quot;, [NSThread currentThread]);
            [NSThread sleepForTimeInterval:1.0];
        });
        
        dispatch_group_notify(group, queue, ^{
            NSLog(@&quot;上传图片 - %@&quot;, [NSThread currentThread]);
            [NSThread sleepForTimeInterval:1.0];
        });
    });
}
</code></pre>
<h1 id="cancel"><a class="header" href="#cancel">cancel</a></h1>
<h2 id="nsoperation-的-cancel"><a class="header" href="#nsoperation-的-cancel">NSOperation 的 cancel</a></h2>
<p>NSOperation 提供了 cancel 方法，可以取消一个操作的执行。但是<strong>注意这里的取消只是针对未执行的任务设置 finished ＝ YES，如果这个操作已经在执行了，那么我们只能等其操作完成。当我们调用 cancel 方法的时候，他只是将 isCancelled 设置为 YES</strong>。</p>
<pre><code class="language-objc">- (void)cancel;
</code></pre>
<h2 id="gcd-实现类似-nsoperation-的-cancel-功能"><a class="header" href="#gcd-实现类似-nsoperation-的-cancel-功能">GCD 实现类似 NSOperation 的 cancel 功能</a></h2>
<h3 id="1-dispatch_block_cancel"><a class="header" href="#1-dispatch_block_cancel">1. <code>dispatch_block_cancel</code></a></h3>
<p>iOS8之后可以调用 <code>dispatch_block_cancel</code> 来取</p>
<pre><code class="language-objc">- (void)gcdBlockCancel{
    dispatch_queue_t queue = dispatch_queue_create(&quot;com.gcd.xxx&quot;, DISPATCH_QUEUE_CONCURRENT);
    
    dispatch_block_t block1 = dispatch_block_create(0, ^{
        sleep(5);
        NSLog(@&quot;block1 %@&quot;, [NSThread currentThread]);
    });
    
    dispatch_block_t block2 = dispatch_block_create(0, ^{
        NSLog(@&quot;block2 %@&quot;, [NSThread currentThread]);
    });
    
    dispatch_block_t block3 = dispatch_block_create(0, ^{
        NSLog(@&quot;block3 %@&quot;, [NSThread currentThread]);
    });
    
    dispatch_async(queue, block1);
    dispatch_async(queue, block2);
    dispatch_async(queue, block3);
    dispatch_block_cancel(block3); // 取消任务3
}
</code></pre>
<h3 id="2-定义外部变量用于标记-block-是否需要取消"><a class="header" href="#2-定义外部变量用于标记-block-是否需要取消">2. 定义外部变量，用于标记 block 是否需要取消</a></h3>
<p>模拟 NSOperation，在执行 block 前先检查 isCancelled = YES ？在block中及时的检测标记变量，当发现需要取消时，终止后续操作（如直接返回return）。</p>
<pre><code class="language-objc">- (void)gcdCancel{
    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
    
    __block BOOL isCancel = NO;
    
    dispatch_async(queue, ^{
        NSLog(@&quot;任务001 %@&quot;,[NSThread currentThread]);
    });
    
    dispatch_async(queue, ^{
        NSLog(@&quot;任务002 %@&quot;,[NSThread currentThread]);
    });
    
    dispatch_async(queue, ^{
        NSLog(@&quot;任务003 %@&quot;,[NSThread currentThread]);
        isCancel = YES;
    });
    
    dispatch_async(queue, ^{
        // 模拟：线程等待3秒，确保任务003完成 isCancel＝YES
        sleep(3);
        if(isCancel){
            NSLog(@&quot;任务004已被取消 %@&quot;,[NSThread currentThread]);
        }else{
            NSLog(@&quot;任务004 %@&quot;,[NSThread currentThread]);
        }
    });
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><ol>
<li>
<p>什么是 block？ block 和 函数指针 的区别? </p>
</li>
<li>
<p>block 有几种类型？每种类型调用 copy 的结果分别是怎样的？</p>
</li>
<li>
<p>栈 block 存在什么问题？</p>
</li>
<li>
<p>block 如何捕获自动变量？</p>
</li>
<li>
<p>如何捕获对象？</p>
</li>
<li>
<p><code>__block</code> 的作用？</p>
</li>
<li>
<p>block 结构里的 <code>forwarding</code> 指针的作用？</p>
</li>
<li>
<p>为什么 block 属性使用 copy 关键字？</p>
</li>
<li>
<p>block 的循环引用？</p>
</li>
<li>
<p>为什么 Masonry 中的 self 不会循环引用? </p>
</li>
<li>
<p>weakSelf 能解决循环引用问题，为什么还需要 strongSelf？</p>
</li>
<li>
<p>使用 strongSelf 后为什么不会造成循环引用？</p>
</li>
<li>
<p>Block 内部使用 self -&gt; _xxx 是否会出现循环引用？</p>
</li>
</ol>
<h1 id="block-循环引用判断题目"><a class="header" href="#block-循环引用判断题目">Block 循环引用判断题目</a></h1>
<ol>
<li>
<p>下面的代码存在循环引用吗？如果有如何解决？</p>
<pre><code class="language-objc">#import &lt;Foundation/Foundation.h&gt;

typedef void(^Study)();
@interface Student : NSObject
@property (copy , nonatomic) NSString *name;
@property (copy , nonatomic) Study study;

@end

#import &quot;ViewController.h&quot;
#import &quot;Student.h&quot;

@interface ViewController ()
@end

@implementation ViewController

- (void)viewDidLoad {
     [super viewDidLoad];

     Student *student = [[Student alloc]init];
     student.name = @&quot;Hello World&quot;;

     student.study = ^{
         NSLog(@&quot;my name is = %@&quot;,student.name);
     };
 }
</code></pre>
</li>
<li>
<p>下面的代码存在循环引用吗？如果有如何解决？</p>
<pre><code class="language-objc"> #import &lt;Foundation/Foundation.h&gt;

 typedef void(^Study)(NSString *name);
 @interface Student : NSObject
 @property (copy , nonatomic) NSString *name;
 @property (copy , nonatomic) Study study;

 @end

 #import &quot;ViewController.h&quot;
 #import &quot;Student.h&quot;

 @interface ViewController ()
 @end

 @implementation ViewController

 - (void)viewDidLoad {
     [super viewDidLoad];

     Student *student = [[Student alloc]init];
     student.name = @&quot;Hello World&quot;;

     student.study = ^(NSString *name){
          NSLog(@&quot;name is = %@&quot;, name);
     };
 }
</code></pre>
</li>
<li>
<p>下面的代码存在循环引用吗？如果有如何解决？</p>
<pre><code class="language-objc"> #import &lt;Foundation/Foundation.h&gt;
 #import &quot;Student.h&quot;

 @interface Teacher : NSObject
 @property (copy , nonatomic) NSString *name;
 @property (strong, nonatomic) Student *stu;
 @end

 #import &quot;ViewController.h&quot;
 #import &quot;Student.h&quot;
 #import &quot;Teacher.h&quot;

 @interface ViewController ()
 @end

 @implementation ViewController

 - (void)viewDidLoad {
     [super viewDidLoad];
 
     Student *student = [[Student alloc]init];
     Teacher *teacher = [[Teacher alloc]init];
 
     teacher.name = @&quot;i'm teacher&quot;;
     teacher.stu = student;
 
     student.name = @&quot;halfrost&quot;;

     student.study = ^{
         NSLog(@&quot;my name is = %@&quot;,teacher.name);
     };
 
     student.study();
 }

</code></pre>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="block"><a class="header" href="#block">Block</a></h1>
<h2 id="什么是-block"><a class="header" href="#什么是-block">什么是 block？</a></h2>
<p>Block 被称为带有自动变量（局部变量）的匿名函数，也是一个ObjC对象。底层是基于C的封装。</p>
<h2 id="block-和-函数指针-的区别"><a class="header" href="#block-和-函数指针-的区别">block 和 函数指针 的区别?</a></h2>
<ul>
<li>
<p>函数指针仅仅是一个地址，不具备函数原型信息，没有类型限制，比如一个指向变量的指针同样可以指向一个函数，但是 block 作为函数对象，是有部分函数信息的，类型限制更明确。</p>
</li>
<li>
<p>block 方式便于实现真正的 “函数式” 编程，让函数成为基本的运算元，往更远的方向说，真正的函数式语言可以去掉寄存器(请参考冯诺依曼机器基本架构)，提高程序的执行效率，近段时间的语言都支持 lambda 语法，包括JS、 C++ 、 Python 、 Ruby等，可见各个编程语言为改进冯诺依曼架构做出的努力和准备。</p>
</li>
<li>
<p>提高程序的健壮性， 定义函数的代码会位于程序的代码段，如果函数内部出现内存溢出，就会直接导致 crash，因为代码段是不可写的；block 作为函数对象在运行时生成，位于栈内，即使出现内存溢出，一般也不会直接导致 crash。</p>
</li>
</ul>
<h2 id="block-有几种类型每种类型调用-copy-的结果分别是怎样的"><a class="header" href="#block-有几种类型每种类型调用-copy-的结果分别是怎样的">block 有几种类型？每种类型调用 copy 的结果分别是怎样的？</a></h2>
<p>block 有 3 种类型：栈块、堆块、全局块，最终都是继承自 NSBlock 类型。</p>
<ul>
<li>
<p><code>_NSConcreteGlobalBlock</code>：作为全局变量的 Block, 保存在数据段区（.data 区）。定义在全局区，或者没有访问自动局部变量的block为全局block。</p>
<pre><code class="language-objc">#include &lt;stdio.h&gt;

void (^blk)(void) = ^{
    printf(&quot;Gloabl Block\n&quot;);
};

int main() {
    return 0;
}
</code></pre>
</li>
<li>
<p><code>_NSConcreteStackBlock</code>：栈上的 Block，保存在栈区。定义 block 的时候，其所占的内存区域是分配在栈中的。block 只在定义它的那个范围内有效。<strong>在ARC下会自动将栈 block copy 到堆</strong>。避免 栈 block 所属的作用域结束后 block 就被废弃。比如如下情况：</p>
<ul>
<li>block 作为函数返回值时</li>
<li>将 block 赋值给 <code>__strong</code> 指针时</li>
<li>block 作为 Cocoa API 中方法名含有 usingBlock 的方法参数时</li>
<li>block 作为 GCD API 的方法参数时</li>
</ul>
</li>
<li>
<p><code>_NSConcreteMallocBlock</code>：堆上的 Block，保存在堆区。给栈block发送 copy 消息后，就会将栈block copy 到堆区。堆块可以在定义它的那个范围之外使用。堆块是带引用计数的对象。由于ARC下会自动将栈 block copy 到堆上，所以不需要我们手动发送 copy 消息。</p>
</li>
</ul>
<p>每一种类型的 block 调用 copy 后的结果：</p>
<ul>
<li>
<p><code>_NSConcreteGlobalBlock</code>：<strong>什么也不做</strong></p>
</li>
<li>
<p><code>_NSConcreteStackBlock</code>：<strong>从栈复制到堆</strong></p>
</li>
<li>
<p><code>_NSConcreteMallocBlock</code>：<strong>引用计数增加</strong></p>
</li>
</ul>
<h2 id="栈-block-存在什么问题"><a class="header" href="#栈-block-存在什么问题">栈 block 存在什么问题？</a></h2>
<p>在 MRC 下不会自动将栈 block copy 到堆上，比如下面的代码，定义在 if 及 else 中的两个块都分配在栈内存中，当出了 if 及 else 的范围，栈块可能就会被销毁。如果编译器覆写了该块的内存，那么调用该块就会导致程序崩溃。或者数据可能会变成垃圾数据，尽管将来该块还能正常调用，但是它捕获的变量的值已经错乱了。</p>
<pre><code class="language-objc">void (^block)(void);
if ( /* some condition */ ) {
    block = ^{
        NSLog(@&quot;Block A&quot;);
    };
} else {
    block = ^{
        NSLog(@&quot;Block B&quot;);
    };
}
block();
</code></pre>
<h2 id="block-如何捕获自动变量"><a class="header" href="#block-如何捕获自动变量">block 如何捕获自动变量？</a></h2>
<p>1.<strong>局部变量是 auto 自动变量的情况是值传递</strong>，block内部会有个变量存储auto变量的值;Block在执行语法时，Block中所使用的自动变量值被保存到Block的结构体实例（即Block自身）中。</p>
<pre><code class="language-objc">int mul = 7;
int (^blk)(int) = ^(int num) {
    return mul * num;
};

// change mul
mul = 10;

int res = blk(3);
NSLog(@&quot;res:%d&quot;, res); // res:21 not 30
</code></pre>
<p>2.<strong>局部变量是 static 静态类型的情况是指针传递</strong>，block 内部会存储静态变量的指针;</p>
<pre><code class="language-objc">static int mul = 7;
int (^blk)(int) = ^(int num) {
    return mul * num;
};

// change mul
mul = 10;

int res = blk(3);
NSLog(@&quot;res:%d&quot;, res); // res:21 not 30
</code></pre>
<p>3.<strong>全局变量直接访问</strong></p>
<p><img src="answer/07_block/./../../assets/img/station_020.png" alt="" /></p>
<h2 id="block-捕获对象类型的-auto-变量"><a class="header" href="#block-捕获对象类型的-auto-变量">block 捕获对象类型的 auto 变量</a></h2>
<p>当 block 内部访问了对象类型的 auto 变量时，有两种情况：</p>
<ul>
<li>
<p>如果 block 是在栈上，将不会对 auto 变量产生强引用</p>
</li>
<li>
<p>如果 block 被拷贝到堆上：会调用 block 内部的 <code>copy</code> <code>函数，copy</code> 函数内部会调用 <code>_Block_object_assign</code> 函数，<code>_Block_object_assign</code> 函数会根据auto 变量的修饰符（<code>__strong</code>、<code>__weak</code>、<code>__unsafe_unretained</code>）做出相应的操作，形成强引用（retain）或者弱引用</p>
</li>
<li>
<p>如果 block 从堆上移除: 会调用 block 内部的 <code>dispose</code> 函数, <code>dispose</code> 函数内部会调用 <code>_Block_object_dispose</code> 函数, <code>_Block_object_dispose</code> 函数会自动释放引用的 auto 变量（release）</p>
</li>
</ul>
<h2 id="__block"><a class="header" href="#__block"><code>__block</code></a></h2>
<h3 id="__block-的作用"><a class="header" href="#__block-的作用"><code>__block</code> 的作用？</a></h3>
<p>换个问法：<code>__block </code>修饰的变量是怎么做到可以在不同block内进行修改？</p>
<p>Block能捕获自动变量值，但是却不能对其进行修改。如果要对值进行修改，需要使用 <code>__block</code>修饰变量。 <code>__block</code> 可以用于解决block内部无法修改auto变量值的问题，需要注意的是 <code>__block</code> 不能修饰全局变量、静态变量（static）。<strong>使用 <code>__block</code> 修饰变量后，编译器会将 <code>__block</code> 变量包装成一个对象</strong>。然后通过 <code>forwarding</code> 指针拿到这个变量进行修改。</p>
<h3 id="block-结构里的-forwarding-指针的作用"><a class="header" href="#block-结构里的-forwarding-指针的作用">block 结构里的 <code>forwarding</code> 指针的作用？</a></h3>
<p>将 <code>__block</code> 变量从栈复制到堆后，改变指向，从而指向真实且唯一的存储实际变量的结构体。
对于堆上的 block 的访问，就是通过 <code>forwarding</code> 实现的：block 变量用结构体成员变量 <code>forwarding</code> 实现无论 block 变量配置在栈还是在堆上都能正确的访问 block 变量。当 block 变量配置在堆上时，只要栈上的结构体成员变量 <code>forwarding</code> 指向堆上的结构体实例，那么不管是从栈上还是从堆上的 <code>__block</code> 变量都能正确访问。</p>
<p><img src="answer/07_block/./../../assets/img/station_021.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="block循环引用"><a class="header" href="#block循环引用">Block循环引用</a></h1>
<p>当Block从栈复制到堆上时，Block会持有捕获的对象，这样就容易产生循环引用。比如在self中引用了Block，Block优捕获了self，就会引起循环引用，编译器通常能检测出这种循环引用:</p>
<pre><code class="language-objc">@interface TestObject : NSObject
@property(nonatomic, copy) void (^blk)(void);
@end

@implementation TestObject
- (instancetype)init {
    self = [super init];
    if (self) {
        self.blk = ^{
            NSLog(@&quot;%@&quot;, self); // warning:Capturing 'self' strongly in this block is likely to lead to a retain cycle
        };
    }
    return self;
}
</code></pre>
<p>如果捕获到的是当前对象的成员变量对象，同样也会造成对self的引用，比如下面的代码，Block使用了self对象的的成员变量name，实际上就是捕获了self，对于编译器来说name只不过时对象用结构体的成员变量：</p>
<pre><code class="language-objc">@interface TestObject : NSObject
@property(nonatomic, copy) void (^blk)(void);
@property(nonatomic, copy) NSString *name;
@end

@implementation TestObject
- (instancetype)init {
    self = [super init];
    if (self) {
        self.blk = ^{
            NSLog(@&quot;%@&quot;, self.name);
        };
    }
    return self;
}
@end
</code></pre>
<p>解决循环引用的方法有两种：</p>
<p><strong>1.使用__weak来声明self</strong>:使用 <code>__weak</code> 修饰符修饰对象之后，在Block中对对象就是弱引用：</p>
<pre><code class="language-objc">- (instancetype)init {
    self = [super init];
    if (self) {
        __weak typeof(self) weakSelf = self;
        self.blk = ^{
            NSLog(@&quot;%@&quot;, weakSelf.name);
        };
    }
    return self;
}
</code></pre>
<p><strong>2.使用临时变量来避免引用self</strong></p>
<pre><code class="language-objc">- (instancetype)init {
    self = [super init];
    if (self) {
        id tmp = self.name;
        self.blk = ^{
            NSLog(@&quot;%@&quot;, tmp);
        };
    }
    return self;
}
</code></pre>
<h2 id="循环引用相关题目"><a class="header" href="#循环引用相关题目">循环引用相关题目</a></h2>
<h3 id="代码分析"><a class="header" href="#代码分析">代码分析</a></h3>
<h4 id="1下面的代码存在循环引用吗如果有如何解决"><a class="header" href="#1下面的代码存在循环引用吗如果有如何解决">1.下面的代码存在循环引用吗？如果有如何解决？</a></h4>
<pre><code class="language-objc">#import &lt;Foundation/Foundation.h&gt;

typedef void(^Study)();
@interface Student : NSObject
@property (copy , nonatomic) NSString *name;
@property (copy , nonatomic) Study study;

@end

#import &quot;ViewController.h&quot;
#import &quot;Student.h&quot;

@interface ViewController ()
@end

@implementation ViewController

- (void)viewDidLoad {
     [super viewDidLoad];

     Student *student = [[Student alloc]init];
     student.name = @&quot;Hello World&quot;;

     student.study = ^{
         NSLog(@&quot;my name is = %@&quot;,student.name);
     };
}
@end
</code></pre>
<ul>
<li>答案：存在循环引用。</li>
<li>原因：student 的 study 的 Block 里面强引用了 student 自身。 <code>_NSConcreteMallocBlock</code> 捕获了外部的对象 student，会在内部持有它。-retainCount 值会加一。</li>
<li>解决办法：
<ul>
<li>方法1:直接对 student 使用 <code>__block</code> ，并将内部的 student 设置为 nil ，不会打破循环引用：
<pre><code class="language-objc">#import &quot;ViewController.h&quot;
#import &quot;Student.h&quot;

@interface ViewController ()
@end

@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];

    Student *student = [[Student alloc]init];

    __block Student *stu = student;
    student.name = @&quot;Hello World&quot;;
    student.study = ^{
        NSLog(@&quot;my name is = %@&quot;,stu.name);
        stu = nil;
    };
}
</code></pre>
</li>
</ul>
原因：由于没有执行 study 这个 block，现在 student 持有该 block，block 持有 __block 变量，__block 变量又持有 student 对象。3者形成了环，导致了循环引用了。
<ul>
<li>方法2: 对 student 使用 <code>__block</code>，并执行 block，破坏掉其中一个引用
<pre><code class="language-objc">#import &quot;ViewController.h&quot;
#import &quot;Student.h&quot;

@interface ViewController ()
@end

@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];

    Student *student = [[Student alloc]init];

    __block Student *stu = student;
    student.name = @&quot;Hello World&quot;;
    student.study = ^{
        NSLog(@&quot;my name is = %@&quot;,stu.name);
        stu = nil;
    };

    // 执行这个 block
    student.study();
}
</code></pre>
<ul>
<li>方法3: 使用 <code>__weak</code> ，对 student 使用 <code>__weak</code>，则 block 就不会强引用 student</li>
</ul>
<pre><code class="language-objc">#import &quot;ViewController.h&quot;
#import &quot;Student.h&quot;

@interface ViewController ()
@end

@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];

    Student *student = [[Student alloc]init];
    student.name = @&quot;Hello World&quot;;

    __weak typeof(student) weakStu = student;

    student.study = ^{
        NSLog(@&quot;my name is = %@&quot;,weakStu.name);
    };

    student.study();
}

@end
</code></pre>
</li>
</ul>
</li>
</ul>
<h4 id="2-下面的代码存在循环引用吗如果有如何解决"><a class="header" href="#2-下面的代码存在循环引用吗如果有如何解决">2. 下面的代码存在循环引用吗？如果有如何解决？</a></h4>
<pre><code class="language-objc">#import &lt;Foundation/Foundation.h&gt;

typedef void(^Study)(NSString *name);
@interface Student : NSObject
@property (copy , nonatomic) NSString *name;
@property (copy , nonatomic) Study study;

@end

#import &quot;ViewController.h&quot;
#import &quot;Student.h&quot;

@interface ViewController ()
@end

@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];

    Student *student = [[Student alloc]init];
    student.name = @&quot;Hello World&quot;;

    student.study = ^(NSString *name){
         NSLog(@&quot;name is = %@&quot;, name);
    };
}

@end
</code></pre>
<ul>
<li>答案：没有循环引用</li>
<li>原因：student 是作为形参传递进 block 的，block 并不会捕获形参到 block 内部进行持有。所以肯定不会造成循环引用。</li>
</ul>
<h4 id="3下面的代码存在循环引用吗如果有如何解决"><a class="header" href="#3下面的代码存在循环引用吗如果有如何解决">3.下面的代码存在循环引用吗？如果有如何解决？</a></h4>
<pre><code class="language-objc">#import &lt;Foundation/Foundation.h&gt;
#import &quot;Student.h&quot;

@interface Teacher : NSObject
@property (copy , nonatomic) NSString *name;
@property (strong, nonatomic) Student *stu;
@end

#import &quot;ViewController.h&quot;
#import &quot;Student.h&quot;
#import &quot;Teacher.h&quot;

@interface ViewController ()
@end

@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];
    
    Student *student = [[Student alloc]init];
    Teacher *teacher = [[Teacher alloc]init];
    
    teacher.name = @&quot;i'm teacher&quot;;
    teacher.stu = student;
    
    student.name = @&quot;halfrost&quot;;
   
    student.study = ^{
        NSLog(@&quot;my name is = %@&quot;,teacher.name);
    };
    
    student.study();
}
</code></pre>
<ul>
<li>答案：<strong>有循环引用</strong></li>
<li>原因：student 强引用了 block，block 强引用了 teacher，teacher 又强引用了 student，形成了环，导致两者都无法释放。</li>
</ul>
<h3 id="为什么-ios-的-masonry-中的-self-会循环引用"><a class="header" href="#为什么-ios-的-masonry-中的-self-会循环引用">为什么 iOS 的 Masonry 中的 self 会循环引用?</a></h3>
<pre><code class="language-objc">UIButton *testButton = [[UIButton alloc] init];
[self.view addSubview:testButton];
testButton.backgroundColor = [UIColor redColor];
[testButton mas_makeConstraints:^(MASConstraintMaker *make) {
    make.width.equalTo(@100);
    make.height.equalTo(@100);
    make.left.equalTo(self.view.mas_left);
    make.top.equalTo(self.view.mas_top);
}];
[testButton bk_addEventHandler:^(id sender) {
    [self dismissViewControllerAnimated:YES completion:nil];
} forControlEvents:UIControlEventTouchUpInside];
</code></pre>
<p>Masonry 源码：</p>
<pre><code class="language-objc">- (NSArray *)mas_makeConstraints:(void(^)(MASConstraintMaker *))block {
    self.translatesAutoresizingMaskIntoConstraints = NO;
    MASConstraintMaker *constraintMaker = [[MASConstraintMaker alloc] initWithView:self];
    block(constraintMaker);
    return [constraintMaker install];
}
</code></pre>
<p>关于 Masonry ，<strong>它内部根本没有捕获变量 self，进入 block 的是testButton，所以执行完毕后，block 会被销毁，没有形成环</strong>。所以，没有引起循环依赖。</p>
<h3 id="weakself-能解决循环引用问题为什么还需要-strongself"><a class="header" href="#weakself-能解决循环引用问题为什么还需要-strongself">weakSelf 能解决循环引用问题，为什么还需要 strongSelf？</a></h3>
<p>目的：<strong>因为 weakSelf 之后，无法控制什么时候会被释放，为了保证在 block 内不会被释放，需要添加 <code>__strong</code>。</strong></p>
<p>比如在block中延迟执行其它任务：</p>
<pre><code class="language-objc">@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];
    
    Student *student = [[Student alloc] init];
    student.name = @&quot;Jack&quot;;
    __weak typeof(student) weakStu = student;
    student.study = ^{
        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
            NSLog(@&quot;stu name is: %@&quot;, weakStu.name);
        });
    };
    student.study(); // stu name is: (null)
}

@end
</code></pre>
<p><strong>上面的输出中 name 为 null</strong>。原因分析： 
在 <code>dispatch_after</code> 这个函数里面，在 study() 的 block 结束之后，student 被自动释放了。又由于 <code>dispatch_after</code> 里面捕获的 __weak 的student，根据__weak的实现原理，在原对象释放之后，__weak 对象就会变成 null，防止野指针。所以就输出 null 了。</p>
<p>解决办法：</p>
<pre><code class="language-objc">@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];
    
    Student *student = [[Student alloc] init];
    student.name = @&quot;Jack&quot;;
    __weak typeof(student) weakStu = student;
    student.study = ^{
        __strong typeof(weakStu)strongStu = weakStu; 
        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
            NSLog(@&quot;stu name is: %@&quot;, weakStu.name);
        });
    };
    student.study(); // stu name is: Jack
}

@end
</code></pre>
<h3 id="strongself-的原理为什么不会导致循环引用"><a class="header" href="#strongself-的原理为什么不会导致循环引用">strongSelf 的原理？为什么不会导致循环引用？</a></h3>
<p>strongSelf 是 Block 内部对 weak 变量强引用的，保证 Block 执行过程中实例不被释放。如果 Block 没有执行，相当于没有给它进行强引用，也就没有影响。</p>
<p>strongSelf 是一个自动变量当 block 执行完毕就会释放自动变量 strongSelf 不会对 self 进行一直进行强引用。</p>
<h1 id="参考-9"><a class="header" href="#参考-9">参考</a></h1>
<ul>
<li><a href="https://liumenghua.github.io/2019/04/19/%E6%8E%A2%E7%B4%A2iOS%E4%B8%ADBlock%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/#Block%E6%8D%95%E8%8E%B7%E5%AF%B9%E8%B1%A1">探索iOS中Block的实现原理</a></li>
<li><a href="https://halfrost.com/ios_block_retain_circle/#toc-0">深入研究 Block 用 weakSelf、strongSelf、@weakify、@strongify 解决循环引用</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kvo"><a class="header" href="#kvo">KVO</a></h1>
<ol>
<li>
<p>iOS 用什么方式实现对一个对象的 KVO？（KVO 的本质是什么？）</p>
</li>
<li>
<p>KVO 使用了哪些存储结构？observers 存储在哪里？</p>
</li>
<li>
<p>如何手动触发 KVO？</p>
</li>
<li>
<p>直接修改成员变量会触发 KVO 吗？</p>
</li>
<li>
<p>KVO的优缺点? </p>
</li>
<li>
<p>KVO如何防护? </p>
</li>
</ol>
<h1 id="kvc"><a class="header" href="#kvc">KVC</a></h1>
<ol>
<li>
<p>KVC 的取值和设值原理？</p>
</li>
<li>
<p>KVC 设值会触发 KVO 吗？</p>
</li>
</ol>
<h1 id="通知"><a class="header" href="#通知">通知</a></h1>
<ol>
<li>
<p>实现原理（结构设计、通知如何存储的、name&amp;observer&amp;SEL之间的关系等）</p>
</li>
<li>
<p>通知的发送是同步还是异步的？</p>
</li>
<li>
<p>如何异步发送通知？</p>
</li>
<li>
<p>如何保证通知接收的线程在主线程？</p>
</li>
<li>
<p>NSNotificationQueue 和 Runloop 的关系？</p>
</li>
<li>
<p>页面销毁时不移除通知会崩溃吗？</p>
</li>
<li>
<p>多次添加同一个通知会是什么结果？多次移除通知呢？</p>
</li>
<li>
<p>下面的方式能接收到通知吗？为什么? </p>
<pre><code class="language-objc">// 发送通知
[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(handleNotification:) name:@&quot;TestNotification&quot; object:@1];

// 接收通知
[NSNotificationCenter.defaultCenter postNotificationName:@&quot;TestNotification&quot; object:nil];
</code></pre>
</li>
</ol>
<h1 id="delegate"><a class="header" href="#delegate">Delegate</a></h1>
<ol>
<li>
<p>delegate 通常使用什么关键字修饰？为什么？</p>
</li>
<li>
<p>delegate 和 Block 的区别？哪个效率更高一些？</p>
</li>
</ol>
<h1 id="比较"><a class="header" href="#比较">比较</a></h1>
<ol>
<li>KVO、Delegate、Notification 异同？如何选择？</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kvo-1"><a class="header" href="#kvo-1">KVO</a></h1>
<h2 id="kvo-的本质"><a class="header" href="#kvo-的本质">KVO 的本质</a></h2>
<ol>
<li>
<p>利用 runtime 的 API 动态生成一个名为 <code>NSKVONotifying_XXX</code> 的子类，并且让 instance 对象的 <code>isa</code> 指针指向这个全新的子类。</p>
</li>
<li>
<p>当修改 <code>instance</code> 对象的属性时，就会调用 Foundation 的 <code>_NSSetXXXValueAndNotify</code> 函数，该函数又会调用如下方法： </p>
<ol>
<li><code>willChangeValueForKey</code></li>
<li>父类原来的 <code>setter</code> 方法</li>
<li><code>didChangeValueForKey:</code></li>
</ol>
</li>
<li>
<p><code>didChangeValueForKey:</code>方法内部会触发监听器（Oberser）的监听方法 <code>observeValueForKeyPath:ofObject:change:context:</code></p>
</li>
</ol>
<h2 id="kvo-的存储结构"><a class="header" href="#kvo-的存储结构">KVO 的存储结构</a></h2>
<p>两个NSMapTable</p>
<h2 id="kvo-的优缺点"><a class="header" href="#kvo-的优缺点">KVO 的优缺点</a></h2>
<p>优点：</p>
<ul>
<li>使用简单，可以使用 KVO 来检测对象属性的变化、快速做出响应，这能够为我们在开发强交互、响应式应用以及实现视图和模型的双向绑定时提供大量的帮助。</li>
</ul>
<p>缺点：</p>
<ul>
<li>string 类型的 key</li>
<li>无法指定响应 KVO 的 selector</li>
<li>KVO 消息是隐式的</li>
<li>context 很鸡肋</li>
</ul>
<p>Facebook 提供了一个开源的框架 facebook/KVOController，一句话添加 KVO 并监听属性修改，使用 Block 或者 selecter 的形式观察对象</p>
<pre><code class="language-objc">self.person = [[Person alloc] init];
[self.KVOController observe:self.person
                    keyPath:@&quot;age&quot;
                    options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld
                      block:^(id  _Nullable observer, id  _Nonnull object, NSDictionary&lt;NSString    *,id&gt; * _Nonnull change) {
                          NSLog(@&quot;%@&quot;, change);
                      }];
</code></pre>
<h2 id="kvo-的防护"><a class="header" href="#kvo-的防护">KVO 的防护</a></h2>
<p>有两类需要防护的原因：</p>
<ol>
<li>
<p>不匹配的移除和添加关系：</p>
<ul>
<li>移除了未注册的观察者，导致崩溃。</li>
<li>重复移除多次，移除次数多于添加次数，导致崩溃。</li>
<li>重复添加多次，虽然不会崩溃，但是发生改变时，也同时会被观察多次。</li>
</ul>
</li>
<li>
<p>观察者和被观察者释放的时候没有及时断开观察者关系。</p>
<ul>
<li>添加或者移除时 keypath == nil，导致崩溃。</li>
<li>添加了观察者，但未实现 <code>observeValueForKeyPath:ofObject:change:context:</code> 方法，导致崩溃。</li>
</ul>
</li>
</ol>
<p>防护方案：在观察者和被观察者之间建立代理对象，维护KVO相关信息，对添加移除操作做防护，hook dealloc方法，做连接断开处理。参考<a href="https://juejin.cn/post/6844903927469588488">iOS 开发：『Crash 防护系统』（二）KVO 防护</a></p>
<h2 id="kvo-的相关题目"><a class="header" href="#kvo-的相关题目">KVO 的相关题目</a></h2>
<h3 id="1-如何手动触发-kvo"><a class="header" href="#1-如何手动触发-kvo">1. 如何手动触发 KVO？</a></h3>
<p>手动调用 <code>willChangeValueForKey:</code> 和 <code>didChangeValueForKey:</code> 方法</p>
<h3 id="2-直接修改成员变量会触发-kvo-吗"><a class="header" href="#2-直接修改成员变量会触发-kvo-吗">2. 直接修改成员变量会触发 KVO 吗？</a></h3>
<p>不会触发 KVO。
必须使用属性才会触发 KVO。根据 KVO 的本质，必须要调用 <code>setter</code> 方法才能够触发 KVO。 比如直接调用成员变量 <code>self-&gt;_name</code>，是不会触发KVO 的。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kvodelegatenotification-对比"><a class="header" href="#kvodelegatenotification-对比">KVO、Delegate、Notification 对比</a></h1>
<table><thead><tr><th>名称</th><th>设计模式</th><th>对应关系</th><th>适用场景</th><th>优缺点</th></tr></thead><tbody>
<tr><td>KVO</td><td>观察者模式</td><td>一对多</td><td>使用监听属性的变化</td><td>能够提供观察的属性的最新值以及先前值</td></tr>
<tr><td>通知</td><td>观察者模式</td><td>一对多</td><td>适合一对多场景</td><td>耦合度低</td></tr>
<tr><td>代理</td><td>代理模式</td><td>一对一</td><td>适合一对一场景</td><td>耦合度高</td></tr>
</tbody></table>
<h1 id="delegate-和-block-的区别哪个效率更高一些"><a class="header" href="#delegate-和-block-的区别哪个效率更高一些">delegate 和 Block 的区别？哪个效率更高一些？</a></h1>
<p>Delegate 的效率更高一些，原因：</p>
<ul>
<li>delegate 通过方法调用，方法调用有缓存，查找较快</li>
<li>Block 是封装的一个对象，并且需要进行 copy 等操作，开销更多。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="notification"><a class="header" href="#notification">Notification</a></h1>
<h2 id="通知底层原理"><a class="header" href="#通知底层原理">通知底层原理</a></h2>
<p>通知的存储结构：</p>
<pre><code class="language-c">// 根容器，NSNotificationCenter 持有
typedef struct NCTbl {
  Observation		*wildcard;	/* 链表结构，保存既没有name也没有object的通知 */
  GSIMapTable		nameless;	/* 存储没有name但是有object的通知	*/
  GSIMapTable		named;		/* 存储带有name的通知，不管有没有object	*/
    ...
} NCTable;

// Observation 存储观察者和响应结构体，基本的存储单元
typedef	struct	Obs {
  id		observer;	/* 观察者，接收通知的对象	*/
  SEL		selector;	/* 响应方法		*/
  struct Obs	*next;		/* Next item in linked list.	*/
  ...
} Observation;
</code></pre>
<ol>
<li>通知在设计结构上实际上是用了 name 和 object 两个维度来记录和查找通知，内存使用一个链表存储没有name和object的通知，使用 一个 MapTable 存储有name 但是没有 object 的通知，使用另一个 MapTable 存储有 name 的通知。 </li>
<li>当发送通知的时候，是通过 name 和 object 查到到所有的 observer 对象，放到一个数组中，在通过 performSelector 逐一调用 selector 去执行通知方法，所以是同步的。</li>
</ol>
<h3 id="添加通知的详细过程"><a class="header" href="#添加通知的详细过程">添加通知的详细过程</a></h3>
<ol>
<li>
<p>创建一个 Observation 对象，持有观察者和 SEL</p>
</li>
<li>
<p>判断是否有 name，如果有，则以 name 作为 key, 从 named 字典中获取对应的 MapTable，然后以 object 为key，从 MapTable 中取出对应的值，这个值就是 Observation 类型的链表，然后把刚开始创建的 Observation 对象存储进去</p>
</li>
<li>
<p>如果没有 name，但有 object，则以 object 为 key，从 nameless 字典中取出对应的 value，value 是个链表结构，然后把创建的 Observation 类型的对象存储到链表中</p>
</li>
<li>
<p>如果 name 和 object 都没有，则存储到 wildcard 链表中</p>
</li>
</ol>
<h3 id="发送通知的详细过程"><a class="header" href="#发送通知的详细过程">发送通知的详细过程</a></h3>
<ol>
<li>
<p>通过 name 和 object 查找到所有的 Observation 对象(保存了observer 和 SEL)，放到数组中</p>
</li>
<li>
<p>通过 <code>performSelector：</code>逐一调用 SEL，这是个同步操作</p>
</li>
<li>
<p>释放 Notification 对象</p>
</li>
</ol>
<h2 id="通知和线程"><a class="header" href="#通知和线程">通知和线程</a></h2>
<h3 id="通知的发送是同步还是异步的"><a class="header" href="#通知的发送是同步还是异步的">通知的发送是同步还是异步的？</a></h3>
<p><strong>同步的</strong>：<br />
通知在设计结构上实际上是用了 name 和 object 两个维度来记录和查找通知，当发送通知的时候，是通过 name 和 object 查到到所有的observer对象，放到一个数组中，在通过 performSelector 逐一调用 selector 去执行通知方法，所以是同步的。</p>
<h3 id="如何异步发送通知"><a class="header" href="#如何异步发送通知">如何异步发送通知？</a></h3>
<p><strong>使用 NSNotificationQueue</strong>
NSNotificationQueue 和 Runloop 的关系：<br />
依赖runloop，所以如果在其他子线程使用 NSNotificationQueue，需要开启 Runloop 最终还是通过 NSNotificationCenter 进行发送通知，所以这个角度讲它还是同步的。所谓异步，<strong>指的是非实时发送而是在合适的时机发送，并没有开启异步线程</strong>。</p>
<p>NSPostingStyle 发送通知的方式，三个值：</p>
<ul>
<li>NSPostWhenIdle，在空闲时发送， 当本线程的runloop空闲时即发送通知到通知中心</li>
<li>NSPostASAP，ASAP即as soon as possible，就是说尽可能快。当前通知或者timer的回调执行完毕时发送通知到通知中心。</li>
<li>NSPostNow， 多个相同的通知合并之后马上发送。</li>
</ul>
<p>coalesceMask 多个通知的合并方式，三个值：</p>
<ul>
<li>NSNotificationNoCoalescing，不管是否重复，不合并。</li>
<li>NSNotificationCoalescingOnName， 按照通知的名字，如果名字重复，则移除重复的。</li>
<li>NSNotificationCoalescingOnSender，按照发送方，如果多个通知的发送方是一样的，则只保留一个。</li>
</ul>
<pre><code class="language-objc">    [[NSNotificationCenter defaultCenter] addObserver:self
                                             selector:@selector(handleNotificationAction:)
                                                 name:@&quot;MyTestNotification&quot;
                                               object:nil];
    
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        NSNotificationQueue *queue = [NSNotificationQueue defaultQueue];
        NSNotification *notification = [NSNotification notificationWithName:@&quot;MyTestNotification&quot; object:nil];

        [NSTimer scheduledTimerWithTimeInterval:2 repeats:YES block:^(NSTimer * _Nonnull timer) {
            // 该log 会在通知发送后打印
            NSLog(@&quot;%@ %@&quot;,NSThread.currentThread,NSRunLoop.currentRunLoop.currentMode);
        }];
        
        // 尽快发送
        [queue enqueueNotification:notification postingStyle:NSPostASAP];
        
        // 子线程需要手动开启runloop
        [[NSRunLoop currentRunLoop] run];
    });
</code></pre>
<h3 id="如何保证通知接收的线程在主线程"><a class="header" href="#如何保证通知接收的线程在主线程">如何保证通知接收的线程在主线程?</a></h3>
<p>由于通知是同步的，异步线程发送通知则响应函数也是在异步线程，如果执行UI刷新相关的话就会出问题，保证通知在主线程响应的方式有两种:</p>
<h4 id="方法1---指定在-main-queue-响应"><a class="header" href="#方法1---指定在-main-queue-响应">方法1 - 指定在 Main Queue 响应</a></h4>
<p>使用 <code>ddObserverForName: object: queue: usingBlock </code> 方法注册通知，指定在 Main Queue 上响应 Block。
缺点：如果在子线程发送多个通知，注册多个不同的观察者，需要在每一个通知处理的地方都去切主线程，太繁琐。</p>
<pre><code class="language-objc">    [[NSNotificationCenter defaultCenter] addObserverForName:@&quot;MyTestNotification&quot; object:nil queue:[NSOperationQueue mainQueue] usingBlock:^(NSNotification * _Nonnull note) {
        [self handleNotificationAction:note];
    }];
    
    
    // 子线程发送通知
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        [[NSNotificationCenter defaultCenter] postNotificationName:@&quot;MyTestNotification&quot; object:nil];
    });
</code></pre>
<h4 id="方法2"><a class="header" href="#方法2">方法2</a></h4>
<p>通知重定向，在Notification所在的默认线程中捕获这些分发的通知，然后将其重定向到指定的线程中。具体为： 在主线程注册一个machPort，它是用来做线程通信的，当在异步线程收到通知，然后给machPort发送消息，这样肯定是在主线程处理的 参考 Apple 提供的实现 <a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Notifications/Articles/Threading.html#//apple_ref/doc/uid/20001289-CEGJFDFG">Delivering Notifications To Particular Threads</a></p>
<p>缺点：</p>
<ul>
<li>所有线程的通知必须使用同一个方法处理</li>
<li>每个对象必须提供自己的实现和通信端口</li>
</ul>
<pre><code class="language-objc">@interface ViewController ()&lt;NSMachPortDelegate&gt;

@property (nonatomic, strong) NSMutableArray *notifications;
@property (nonatomic, strong) NSThread *notificationThread;
@property (nonatomic, strong) NSLock *notificationLock;
@property (nonatomic, strong) NSMachPort *notificationPort;

@end

@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];
  
    [self setUpThreadingSupport];
  
      [[NSNotificationCenter defaultCenter] addObserver:self
                                             selector:@selector(processNotification:)
                                                 name:@&quot;MyTestNotification&quot;
                                               object:nil];
    
    // 子线程发送通知
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        [[NSNotificationCenter defaultCenter] postNotificationName:@&quot;MyTestNotification&quot; object:nil];
    });
}

- (void)handleNotificationAction:(NSNotification *)notification {
    NSLog(@&quot;收到通知&quot;);
}

- (void)setUpThreadingSupport {
    if (self.notifications) return;
    
    self.notifications = [NSMutableArray array];
    self.notificationLock = [[NSLock alloc] init];
    self.notificationThread = [NSThread currentThread];
    self.notificationPort = [[NSMachPort alloc] init];
    [self.notificationPort setDelegate:self];
    
    // 往当前线程的run loop添加端口源
    // 当Mach消息到达而接收线程的run loop没有运行时，则内核会保存这条消息，直到下一次进入run loop
    [[NSRunLoop currentRunLoop] addPort:self.notificationPort forMode:(__bridge NSString *)kCFRunLoopCommonModes];
}

- (void)handleMachMessage:(void *)msg {
    [self.notificationLock lock];
    
    while ([self.notifications count]) {
        NSNotification *notification = [self.notifications objectAtIndex:0];
        [self.notifications removeObjectAtIndex:0];
        [self.notificationLock unlock];
        [self processNotification:notification];
        [self.notificationLock lock];
    }
    
    [self.notificationLock unlock];
}

- (void)processNotification:(NSNotification *)notification {
    if ([NSThread currentThread] != self.notificationThread) {
        // 转发通知到当前线程
        [self.notificationLock lock];
        [self.notifications addObject:notification];
        [self.notificationLock unlock];
        [self.notificationPort sendBeforeDate:[NSDate date] components:nil from:nil reserved:0];
    } else {
        // 执行通知
        [self handleNotificationAction:notification];
    }
}
</code></pre>
<h4 id="方法3---更好的方式"><a class="header" href="#方法3---更好的方式">方法3 - 更好的方式</a></h4>
<p>继承 NSNotificationCenter 的子类，为每个线程有一个通知队列，并能够向多个观察者对象和方法发送通知。</p>
<h2 id="通知相关题目"><a class="header" href="#通知相关题目">通知相关题目</a></h2>
<h3 id="1-页面销毁时不移除通知会崩溃吗"><a class="header" href="#1-页面销毁时不移除通知会崩溃吗">1. 页面销毁时不移除通知会崩溃吗?</a></h3>
<p>低于iOS 9.0 版本回 crash，需要手动移除通知，iOS 9.0 及以后版本则不会。</p>
<h3 id="2-多次添加同一个通知会是什么结果多次移除通知呢"><a class="header" href="#2-多次添加同一个通知会是什么结果多次移除通知呢">2. 多次添加同一个通知会是什么结果？多次移除通知呢</a></h3>
<ul>
<li>
<p>通知注册多次，则会收到多次</p>
</li>
<li>
<p>多次移除，不会有问题，发送通知的时候会先查找，找不到就不发送</p>
</li>
</ul>
<h3 id="3-下面的方式能接收到通知吗为什么"><a class="header" href="#3-下面的方式能接收到通知吗为什么">3. 下面的方式能接收到通知吗？为什么?</a></h3>
<pre><code class="language-objc">// 发送通知
[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(handleNotification:) name:@&quot;TestNotification&quot; object:@1];

// 接收通知
[NSNotificationCenter.defaultCenter postNotificationName:@&quot;TestNotification&quot; object:nil];
</code></pre>
<p>答案：不能。
原因：object 不同，通知是通过 name 和 object 两个维度维护的。</p>
<h1 id="参考-10"><a class="header" href="#参考-10">参考</a></h1>
<ul>
<li><a href="https://juejin.cn/post/6844904082516213768#heading-0">轻松过面：一文全解iOS通知机制(经典收藏)</a></li>
<li><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Notifications/Articles/Threading.html#//apple_ref/doc/uid/20001289-CEGJFDFG">Delivering Notifications To Particular Threads</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><ol>
<li>
<p>了解哪些数据持久化方式？</p>
</li>
<li>
<p>什么情况下用 keychain，系统重装 app 删除、更新，对keychain有影响吗？</p>
</li>
<li>
<p>了解LRU/LFU吗</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ios-持久化"><a class="header" href="#ios-持久化">iOS 持久化</a></h1>
<p>iOS 持久化的几种方式：</p>
<ul>
<li>NSUserDefaults</li>
<li>plist</li>
<li>Keychain（钥匙串）</li>
<li>NSKeyedArchiver 归档</li>
<li>Sandbox 沙盒 </li>
<li>数据库</li>
<li>Core Data</li>
</ul>
<h2 id="nsuserdefaults"><a class="header" href="#nsuserdefaults">NSUserDefaults</a></h2>
<ul>
<li>主要使用场景：用于存储用户的偏好设置和用户信息,如用户名,是否自动登录,字体大小等.数据自动保存在沙盒的Libarary/Preferences目录下.</li>
<li>是否支持自定义对象存储：不支持</li>
<li>存储格式：key-value 键值对</li>
<li>优点：
<ul>
<li>使用简单方便；</li>
<li>NSUserDefaults 是线程安全的。</li>
</ul>
</li>
<li>缺点：
<ul>
<li>不支持自定义对象的存储；</li>
<li>不安全，NSUserDefaults 是在沙盒下的 Libray/Preferences 目录下创建 .plist 文件, 然后将文件存储在其中。这种存储方式就决定了它的安全性几乎为0,所以不建议存储一些敏感信息如:用户密码,token,加密私钥等!</li>
<li>实效性差：由于 NSUserDefaults 不是即时写入，它会定时把缓存中的数据写入磁盘。一般需要调用 <code>synchronize</code> 强制立即将数据写入磁盘.</li>
<li>卸载程序时，数据会被清除。NSUserDefaults保存的数据不会通过iTunes传递到另外的设备也不会存储到iCloud上面。</li>
</ul>
</li>
</ul>
<h2 id="plist"><a class="header" href="#plist">plist</a></h2>
<p>全名是 Property List，即属性列表文件，这种文件的扩展名为.plist。</p>
<ul>
<li>主要使用场景：用来存储串行化后的对象的文件，用于存储程序中经常用到且数据量小而不经常改动的数据。</li>
<li>是否支持自定义对象存储：不支持</li>
<li>优点：易用性强</li>
<li>缺点：
<ul>
<li>不支持自定义对象的存储；如果需要存储自定义类型的数据需要先进行序列化!</li>
<li>不适合操作处理大量数据</li>
</ul>
</li>
</ul>
<h2 id="keychain钥匙串"><a class="header" href="#keychain钥匙串">Keychain（钥匙串）</a></h2>
<ul>
<li>主要使用场景：一种安全的存储敏感信息的工具,比如,网络密码:用户访问服务器或者网站,通用密码:用来保存应用程序或者数据库密码.与此同时,用于认证的证书,密钥,和身份信息,也可以存储在Keychain中,Keychain Services 的安全机制保证了存储这些敏感信息不会被窃取。简单说来，Keychain 就是一个安全容器。</li>
<li>优点：
<ul>
<li>数据并不存放在App的Sanbox中，即使删除了App，资料依然保存在keychain中。如果重新安装了app，还可以从keychain获取数据。</li>
<li>keychain的数据可以通过group方式，让程序可以在App间共享。不过得要相同TeamID</li>
<li>keychain的数据是经过加密的</li>
</ul>
</li>
<li>原理：对于每一个应用来说，KeyChain都有两个访问区，私有区和公共区。私有区是一个sandbox，本程序存储的任何数据都对其他程序不可见，其他应用程序无法访问该区数据。如果要想将存储的内容放在公共区，实现多个应用程序间可以共同访问一些数据，则可以先声明公共区的名称，官方文档管这个名称叫“keychain access group”</li>
</ul>
<p><a href="https://juejin.cn/post/6844903921765318669">iOS Keychain(钥匙串)原理及使用</a></p>
<h2 id="nskeyedarchiver-归档"><a class="header" href="#nskeyedarchiver-归档">NSKeyedArchiver 归档</a></h2>
<p>归档是iOS开发中数据存储常用的技巧，归档可以直接将对象储存成文件，把文件读取成对象。</p>
<ul>
<li>主要使用场景：一般用于存储少量数据</li>
<li>是否支持自定义对象存储：支持，需要遵循 NSCoding 协议，实现 <code>initWithCoder:</code> 和 <code>encodeWithCoder:</code> 方法</li>
<li>优点：可以将复杂的对象写入文件 可以归档集合类，所以无论添加多少对象，将对象写入磁盘的方式都是一样的，不会增加工作量；</li>
</ul>
<h2 id="sandbox-沙盒"><a class="header" href="#sandbox-沙盒">Sandbox 沙盒</a></h2>
<ul>
<li>主要使用场景：持久化在Document目录下，一般存储非机密数据。当App中涉及到电子书阅读、听音乐、看视频、刷图片列表等时，推荐使用沙盒存储。</li>
<li>沙盒里面一般有4个目录：
<ul>
<li>Documents: 保存应运行时生成的需要持久化的数据,iTunes同步设备时会备份该目录。例如,游戏应用可将游戏存档保存在该目录。</li>
<li>Library/Caches: 保存应用运行时成的需要持久化的数据,iTunes同步设备时不会备份 该目录。一般存储体积大、不需要备份的非重要数据，比如网络数据缓存存储到Caches下</li>
<li>Library/Preference: 保存应用的所有偏好设置，如iOS的Settings(设置) 应会在该目录中查找应的设置信息。iTunes同步设备时会备份该目录。</li>
<li>tmp: 保存应运行时所需的临时数据,使完毕后再将相应的文件从该目录删除。应用 没有运行时,系统也可能会清除该目录下的文件。iTunes同步设备时不会备份该目录。</li>
</ul>
</li>
</ul>
<h2 id="数据库"><a class="header" href="#数据库">数据库</a></h2>
<p>iOS 中可以使用 sqlite 轻量级数据库。</p>
<ul>
<li>主要使用场景：适合储存数据量较大的数据</li>
<li>缺点：易用性不强</li>
<li>优点：
<ul>
<li>可以存储大量数据，存储、检索大量数据非常高效；</li>
<li>能对数据进行复杂的聚合，比使用对象执行这些操作要高效得多。</li>
</ul>
</li>
</ul>
<h2 id="core-data"><a class="header" href="#core-data">Core Data</a></h2>
<p>Core Data是iOS5之后才出现的一个框架，它提供了对象-关系映射(ORM)的功能，即能够将OC对象转化成数据，保存在SQLite数据库文件中，也能够将保存在数据库中的数据还原成OC对象。在此数据操作期间，我们不需要编写任何SQL语句.</p>
<ul>
<li>缺点：CoreData 本质还是将数据存在了SQLite数据库文件 ,使用不是很方便.</li>
<li>优点：和 数据库一致，但是不需要写SQL语句。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="设计模式"><a class="header" href="#设计模式">设计模式</a></h1>
<ol>
<li>
<p>编程中的六大设计原则？</p>
</li>
<li>
<p>了解哪些设计模式？</p>
</li>
<li>
<p>单例会有什么弊端？</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="卡顿优化"><a class="header" href="#卡顿优化">卡顿优化</a></h1>
<ol>
<li>
<p>屏幕成像的原理？CPU 和 GPU 的作用？</p>
</li>
<li>
<p>解释一下什么是屏幕卡顿、掉帧？该如何避免？</p>
</li>
<li>
<p>如何提升 tableview 的流畅度？</p>
</li>
<li>
<p>tableview 加载大图如何优化？</p>
</li>
<li>
<p>如何使用 Instruments 进行性能调优？</p>
</li>
<li>
<p>FPS怎么检测？</p>
</li>
<li>
<p>如何进行卡顿监控？除了 Runloop 还有什么方案？</p>
</li>
<li>
<p>如何抓取卡顿堆栈？</p>
</li>
<li>
<p>什么是离屏渲染？什么情况下会触发？该如何应对？[</p>
</li>
<li>
<p>如何高性能的画一个圆角？</p>
</li>
</ol>
<h1 id="启动优化"><a class="header" href="#启动优化">启动优化</a></h1>
<ol>
<li>
<p>APP 的启动过程，main 文件说起，main 函数中有什么函数？有什么作用？</p>
</li>
<li>
<p>如何优化 APP 的启动时间？</p>
</li>
<li>
<p>静态库和动态库的区别？</p>
</li>
</ol>
<h1 id="编译优化"><a class="header" href="#编译优化">编译优化</a></h1>
<ol>
<li>
<p>Xcode 的编译过程？</p>
</li>
<li>
<p>Xcode 点击 run 之后发生了什么？</p>
</li>
<li>
<p>如何提升编译速度？</p>
</li>
</ol>
<h1 id="包瘦身"><a class="header" href="#包瘦身">包瘦身</a></h1>
<ol>
<li>
<p>如何有效降低 APP 包的大小？</p>
</li>
<li>
<p>如何检测名字不同，但内容相同的图片？</p>
</li>
<li>
<p>如何进行无用代码检测？</p>
</li>
</ol>
<h1 id="内存优化"><a class="header" href="#内存优化">内存优化</a></h1>
<ol>
<li>
<p>如何优化 APP 的内存？</p>
</li>
<li>
<p>是否了解 OOM？如何做 OOM 监控？如何优化？</p>
</li>
<li>
<p>日常如何检查内存泄露？</p>
</li>
</ol>
<h1 id="电量优化"><a class="header" href="#电量优化">电量优化</a></h1>
<ol>
<li>
<p>如何优化 APP 的电量？</p>
</li>
<li>
<p>APP 的哪些功能是比较耗电的？</p>
</li>
</ol>
<h1 id="网络优化"><a class="header" href="#网络优化">网络优化</a></h1>
<ol>
<li>如何优化 APP 的网络流量？</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="五层协议"><a class="header" href="#五层协议">五层协议</a></h1>
<ol>
<li>
<p>TCP/IP 五层模型和每层作用，每层的代表协议？</p>
</li>
<li>
<p>NDS 工作在哪一层？</p>
</li>
<li>
<p>DNS 使用的是 TCP 还是 UDP ？</p>
</li>
<li>
<p>DNS 的解析过程？ </p>
</li>
<li>
<p>DNS 劫持的解决方案？</p>
</li>
<li>
<p>DNS 如何优化 </p>
</li>
</ol>
<h1 id="tcp-vs-udp"><a class="header" href="#tcp-vs-udp">TCP vs UDP</a></h1>
<ol>
<li>
<p>TCP 和 UDP 的区别？</p>
</li>
<li>
<p>TCP 是如何保证可靠传输的？</p>
</li>
<li>
<p>TCP 的流量控制和拥塞控制？</p>
</li>
<li>
<p>TCP 三次握手，为什么需要三次？两次是否可以？</p>
</li>
<li>
<p>TCP 四次挥手，为什么需要四次？三次是否可以？</p>
</li>
<li>
<p>为什么数据要在传输层就分块，而不是等到网络层再分片传递给数据链路层？</p>
</li>
</ol>
<h1 id="httphttps"><a class="header" href="#httphttps">HTTP/HTTPS</a></h1>
<ol>
<li>
<p>HTTP 的请求报文和响应报文的结构？</p>
</li>
<li>
<p>HTTP 的请求方式有哪些？</p>
</li>
<li>
<p>GET 和 POST 请求的区别？</p>
</li>
<li>
<p>HTTP 常见的状态码有哪些？</p>
</li>
<li>
<p>HTTP 1.0、1.2 和 2.0 几个版本的区别？</p>
</li>
<li>
<p>HTTP 的常见头部字段和作用？</p>
</li>
<li>
<p>HTTP 和 HTTPS 的区别？为什么会更安全？加密过程如何处理的？</p>
</li>
<li>
<p>SSL 传输协议？说一下 SSL 验证过程？</p>
</li>
<li>
<p>证书验证具体做了什么工作？如何确保证书可靠？</p>
</li>
<li>
<p>对称加密和非对称加密的区别？</p>
</li>
</ol>
<h1 id="应用-3"><a class="header" href="#应用-3">应用</a></h1>
<ol>
<li>
<p>从输入URL到页面加载发生了什么？</p>
</li>
<li>
<p>抓包软件 Charles 的原理是什么? </p>
</li>
<li>
<p>谈一谈网络中的 session 和 cookie? </p>
</li>
<li>
<p>NSURLConnection 和 NSUURLSession 的区别？</p>
</li>
<li>
<p>NSUrlProtocol 用过吗？用在什么地方了？</p>
</li>
<li>
<p>断点续传功能该怎么实现？</p>
</li>
<li>
<p>大文件下载的功能有什么注意点？</p>
</li>
<li>
<p>发送网络请求的时候，如果带宽 1M，如何针对某些请求，限制其流量?</p>
</li>
<li>
<p>不用 Charles，在 app 内抓包的方法，抓取 app 内所有请求，打印输出，怎么实现？</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="书籍"><a class="header" href="#书籍">书籍</a></h1>
<h2 id="ios书籍"><a class="header" href="#ios书籍">iOS书籍</a></h2>
<ul>
<li>《Effective Objective-C 2.0》</li>
<li>《Objective-C 高级编程》</li>
<li>《高性能iOS应用开发》</li>
<li><a href="https://zsisme.gitbooks.io/ios-/content/index.html">《iOS核心动画高级技巧》</a></li>
</ul>
<h2 id="操作系统"><a class="header" href="#操作系统">操作系统</a></h2>
<ul>
<li>《程序员的自我修养》</li>
</ul>
<h2 id="计算机网络"><a class="header" href="#计算机网络">计算机网络</a></h2>
<ul>
<li>《图解HTTP》</li>
</ul>
<h2 id="数据结构和算法"><a class="header" href="#数据结构和算法">数据结构和算法</a></h2>
<ul>
<li>《剑指Offer》</li>
</ul>
<h1 id="博客"><a class="header" href="#博客">博客</a></h1>
<ul>
<li><a href="https://juejin.cn/user/782508012091645/posts">师大小海腾</a></li>
<li><a href="https://juejin.cn/user/3562073402387006/posts">J_Knight</a></li>
<li><a href="https://juejin.cn/user/1838039172387262/posts">字节跳动技术团队</a></li>
<li><a href="https://github.com/draveness/analyze">draveness</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
