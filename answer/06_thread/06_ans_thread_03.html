<!DOCTYPE HTML>
<html lang="zh-CN" class="sidebar-visible no-js rust">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>线程同步 - iOS 小站</title>


        <!-- Custom HTML head -->

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "rust";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../../questions/chapter_0_forward.html">前言</a></li><li class="chapter-item expanded "><a href="../../questions/chapter_1_foundation.html"><strong aria-hidden="true">1.</strong> Foundation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../answer/01_foundation/01_ans_foundation_01.html"><strong aria-hidden="true">1.1.</strong> Foundation</a></li><li class="chapter-item expanded "><a href="../../answer/01_foundation/01_ans_foundation_02.html"><strong aria-hidden="true">1.2.</strong> 集合</a></li><li class="chapter-item expanded "><a href="../../answer/01_foundation/01_ans_foundation_03.html"><strong aria-hidden="true">1.3.</strong> C/C++</a></li></ol></li><li class="chapter-item expanded "><a href="../../questions/chapter_2_uikit.html"><strong aria-hidden="true">2.</strong> UIKit</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../answer/02_uikit/02_ans_uikit_01.html"><strong aria-hidden="true">2.1.</strong> UIKit</a></li><li class="chapter-item expanded "><a href="../../answer/02_uikit/02_ans_uikit_02.html"><strong aria-hidden="true">2.2.</strong> 动画和渲染</a></li><li class="chapter-item expanded "><a href="../../answer/02_uikit/02_ans_uikit_03.html"><strong aria-hidden="true">2.3.</strong> 响应者链</a></li><li class="chapter-item expanded "><a href="../../answer/02_uikit/02_ans_uikit_04.html"><strong aria-hidden="true">2.4.</strong> APP</a></li><li class="chapter-item expanded "><a href="../../answer/02_uikit/02_ans_uikit_05.html"><strong aria-hidden="true">2.5.</strong> UIKit相关算法</a></li></ol></li><li class="chapter-item expanded "><a href="../../questions/chapter_3_memory.html"><strong aria-hidden="true">3.</strong> 内存管理</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../answer/03_memory/02_ans_memory_01.html"><strong aria-hidden="true">3.1.</strong> 内存基础</a></li><li class="chapter-item expanded "><a href="../../answer/03_memory/02_ans_memory_02.html"><strong aria-hidden="true">3.2.</strong> iOS内存管理</a></li><li class="chapter-item expanded "><a href="../../answer/03_memory/02_ans_memory_03.html"><strong aria-hidden="true">3.3.</strong> 循环引用</a></li><li class="chapter-item expanded "><a href="../../answer/03_memory/02_ans_memory_04.html"><strong aria-hidden="true">3.4.</strong> ARC</a></li><li class="chapter-item expanded "><a href="../../answer/03_memory/02_ans_memory_05.html"><strong aria-hidden="true">3.5.</strong> AutoreleasePool</a></li></ol></li><li class="chapter-item expanded "><a href="../../questions/chapter_4_runtime.html"><strong aria-hidden="true">4.</strong> Runtime</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../answer/04_runtime/03_ans_runtime_01.html"><strong aria-hidden="true">4.1.</strong> NSObject对象</a></li><li class="chapter-item expanded "><a href="../../answer/04_runtime/03_ans_runtime_02.html"><strong aria-hidden="true">4.2.</strong> Category</a></li><li class="chapter-item expanded "><a href="../../answer/04_runtime/03_ans_runtime_03.html"><strong aria-hidden="true">4.3.</strong> 关联对象</a></li><li class="chapter-item expanded "><a href="../../answer/04_runtime/03_ans_runtime_04.html"><strong aria-hidden="true">4.4.</strong> 消息发送</a></li></ol></li><li class="chapter-item expanded "><a href="../../questions/chapter_5_runloop.html"><strong aria-hidden="true">5.</strong> Runloop</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../answer/05_runloop/05_ans_runloop_01.html"><strong aria-hidden="true">5.1.</strong> Runloop</a></li><li class="chapter-item expanded "><a href="../../answer/05_runloop/05_ans_runloop_02.html"><strong aria-hidden="true">5.2.</strong> Runloop与Timer</a></li></ol></li><li class="chapter-item expanded "><a href="../../questions/chapter_6_thread.html"><strong aria-hidden="true">6.</strong> 多线程</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../answer/06_thread/06_ans_thread_01.html"><strong aria-hidden="true">6.1.</strong> 进程和线程</a></li><li class="chapter-item expanded "><a href="../../answer/06_thread/06_ans_thread_02.html"><strong aria-hidden="true">6.2.</strong> iOS多线程</a></li><li class="chapter-item expanded "><a href="../../answer/06_thread/06_ans_thread_03.html" class="active"><strong aria-hidden="true">6.3.</strong> 线程同步</a></li><li class="chapter-item expanded "><a href="../../answer/06_thread/06_ans_thread_04.html"><strong aria-hidden="true">6.4.</strong> GCD题目</a></li><li class="chapter-item expanded "><a href="../../answer/06_thread/06_ans_thread_05.html"><strong aria-hidden="true">6.5.</strong> GCD进阶</a></li></ol></li><li class="chapter-item expanded "><a href="../../questions/chapter_7_block.html"><strong aria-hidden="true">7.</strong> Block</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../answer/07_block/07_ans_block_01.html"><strong aria-hidden="true">7.1.</strong> Block</a></li><li class="chapter-item expanded "><a href="../../answer/07_block/07_ans_block_02.html"><strong aria-hidden="true">7.2.</strong> Block循环引用</a></li></ol></li><li class="chapter-item expanded "><a href="../../questions/chapter_8_notification_delegate_kvo.html"><strong aria-hidden="true">8.</strong> 通知代理KVO</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../answer/08_notify_delegate_kvo/08_ans_notify_01.html"><strong aria-hidden="true">8.1.</strong> KVO</a></li><li class="chapter-item expanded "><a href="../../answer/08_notify_delegate_kvo/08_ans_notify_03.html"><strong aria-hidden="true">8.2.</strong> Notification</a></li><li class="chapter-item expanded "><a href="../../answer/08_notify_delegate_kvo/08_ans_notify_02.html"><strong aria-hidden="true">8.3.</strong> 对比</a></li></ol></li><li class="chapter-item expanded "><a href="../../questions/chapter_9_data.html"><strong aria-hidden="true">9.</strong> 持久化</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../answer/09_data/09_ans_data_01.html"><strong aria-hidden="true">9.1.</strong> 持久化</a></li></ol></li><li class="chapter-item expanded "><a href="../../questions/chapter_10_design.html"><strong aria-hidden="true">10.</strong> 设计模式</a></li><li class="chapter-item expanded "><a href="../../questions/chapter_11_performance.html"><strong aria-hidden="true">11.</strong> 性能优化</a></li><li class="chapter-item expanded "><a href="../../questions/chapter_12_network.html"><strong aria-hidden="true">12.</strong> 计算机网络</a></li><li class="chapter-item expanded affix "><a href="../../chapter_books.html">推荐书目和博客</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">iOS 小站</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/liumenghua/station_ios" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="线程同步"><a class="header" href="#线程同步">线程同步</a></h1>
<h2 id="多线程使用过程中的注意事项"><a class="header" href="#多线程使用过程中的注意事项">多线程使用过程中的注意事项？</a></h2>
<ul>
<li>
<p>避免开辟过多的线程和太多线程间的来回切换，创建线程是需要花费资源的，线程的切换也是需要花费资源的。一条主线程占用1M，一条子线程占用 512Kb。</p>
</li>
<li>
<p>避免出现多线程抢占资源问题，出现死锁场景</p>
</li>
</ul>
<h2 id="如何确保线程安全"><a class="header" href="#如何确保线程安全">如何确保线程安全？</a></h2>
<ul>
<li>采用串行队列</li>
<li>使用信号量</li>
<li>使用加锁方案</li>
</ul>
<h2 id="如何实现线性编程"><a class="header" href="#如何实现线性编程">如何实现线性编程？</a></h2>
<ul>
<li>
<p>信号量 <code>dispatch_semaphore_t</code>:</p>
</li>
<li>
<p>栅栏 <code>dispatch_barrier</code></p>
</li>
<li>
<p>dispatch_group</p>
</li>
</ul>
<h2 id="ios-中有哪些锁性能如何"><a class="header" href="#ios-中有哪些锁性能如何">iOS 中有哪些锁？性能如何？</a></h2>
<h3 id="锁的分类"><a class="header" href="#锁的分类">锁的分类</a></h3>
<ul>
<li>
<p>自旋锁：<strong>线程反复检查锁变量是否可用</strong>。由于线程在这一过程中保持执行，因此是一种忙等待。一旦获取了自旋锁，线程会一直保持该锁，直至释放自旋锁。</p>
<ul>
<li>优点：自旋锁避免了进程上下文的调度开销，因此对于线程只会阻塞很短时间的场合是有效的。</li>
<li>缺点：单核CPU不适于使用自旋锁，这里的单核CPU指的是单核单线程的CPU，因为，在同一时间只有一个线程是处在运行状态，假设运行线程A发现无法获取锁，只能等待解锁，但因为A自身不挂起，所以那个持有锁的线程B没有办法进入运行状态，只能等到操作系统分给A的时间片用完，才能有机会被调度。这种情况下使用自旋锁的代价很高。</li>
<li>适用场景：适用于耗时短的操作。</li>
</ul>
</li>
<li>
<p>互斥锁：<strong>多线程编程中，防止两条线程同时对同一公共资源（比如全局变量）进行读写的机制。</strong></p>
<ul>
<li>原理：当需要加锁的资源已经被别的线程占据时，等待锁的线程会进行休眠，等待执行完成释放后再进行唤醒，线程唤醒会带来一定的开销。</li>
<li>缺点：性能差一些。</li>
<li>适用：适用于耗时长的操作。</li>
</ul>
</li>
<li>
<p>读写锁：<strong>多读单写</strong></p>
<ul>
<li>原理：读写锁通常用互斥锁、条件变量、信号量实现。</li>
</ul>
</li>
<li>
<p>信号量：进行线程调度。</p>
</li>
</ul>
<h3 id="ios中的各种锁和性能"><a class="header" href="#ios中的各种锁和性能">iOS中的各种锁和性能</a></h3>
<p>iOS 中有多达到13种锁，其性能 OSSpinLock 自旋锁和 dispatch_semaphore 信号量最高，<code>@synchronized</code> 最低：</p>
<ul>
<li>OSSpinLock 自旋锁</li>
<li>dispatch_semaphore信号量</li>
<li>os_unfair_lock 互斥锁</li>
<li>pthread_mutex 递归锁</li>
<li>pthread_mutex 条件锁</li>
<li>dispatch_queue(DISPATCH_QUEUE_SERIAL)</li>
<li>NSLock</li>
<li>NSRecursiveLock</li>
<li>NSCondition</li>
<li>NSConditionLock</li>
<li>@synchronized 对 mutex 递归锁的封装，然后进行加锁、解锁操作</li>
<li>dispatch_barrier_async 栅栏</li>
<li>dispatch_group 调度组</li>
</ul>
<h3 id="osspinlock自旋锁-存在的问题"><a class="header" href="#osspinlock自旋锁-存在的问题">OSSpinLock自旋锁 存在的问题</a></h3>
<p>OSSpinLock 不再安全，主要原因发生在低优先级线程拿到锁时，高优先级线程进入忙等(busy-wait)状态，消耗大量 CPU 时间，从而导致低优先级线程拿不到 CPU 时间，也就无法完成任务并释放锁。这种问题被称为<strong>优先级反转</strong>。</p>
<p>为什么忙等会导致低优先级线程拿不到时间片？这还得从操作系统的线程调度说起。</p>
<p>现代操作系统在管理普通线程时，通常采用时间片轮转算法(Round Robin，简称 RR)。每个线程会被分配一段时间片(quantum)，通常在 10-100 毫秒左右。当线程用完属于自己的时间片以后，就会被操作系统挂起，放入等待队列中，直到下一次被分配时间片。</p>
<h3 id="自旋锁和互斥锁分别的适用场景"><a class="header" href="#自旋锁和互斥锁分别的适用场景">自旋锁和互斥锁分别的适用场景？</a></h3>
<ul>
<li>
<p>自旋锁：</p>
<ul>
<li>预计线程等待锁的时间很短</li>
<li>加锁的代码（临界区）经常被调用，但竞争情况很少发生</li>
<li>CPU资源不紧张</li>
<li>多核处理器</li>
</ul>
</li>
<li>
<p>互斥锁：</p>
<ul>
<li>预计线程等待锁的时间较长</li>
<li>单核处理器</li>
<li>临界区有IO操作</li>
<li>临界区代码复杂或者循环量大</li>
<li>临界区竞争非常激烈</li>
</ul>
</li>
</ul>
<h3 id="synchronized-原理"><a class="header" href="#synchronized-原理">@synchronized 原理</a></h3>
<pre><code class="language-objc">@synchronized(self) {
    // task 
}
</code></pre>
<p>这其实是一个 OC 层面的锁， 主要是通过牺牲性能换来语法上的简洁与可读。</p>
<p><code>@synchronized</code> 后面需要紧跟一个 ObjC 对象，它实际上是把这个对象当做锁来使用。这是通过一个哈希表map来实现的，在底层使用了一个互斥锁的数组，通过对对象去哈希值（采用的是对象obj作为key）来得到对应的互斥锁。</p>
<p>优点就是使用方便，不关心成对出现。缺点就是性能开销大，查找线程锁太耗时。</p>
<h2 id="死锁"><a class="header" href="#死锁">死锁</a></h2>
<p>死锁是由于多个线程（进程）在执行过程中，因为争夺资源而造成的互相等待现象，你可以理解为卡主了。产生死锁的必要条件有四个：</p>
<ul>
<li>互斥条件 ： 指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。</li>
<li>请求和保持条件 ： 指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。</li>
<li>不可剥夺条件 ： 指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。</li>
<li>环路等待条件 ： 指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。</li>
</ul>
<p>总结来说就是 <strong>同步任务 + 串行队列</strong> 就会出现队列阻塞，产生死锁现象。常见的有：</p>
<ul>
<li>
<p>最常见的就是 同步函数 + 主队列 的组合，本质是队列阻塞，比如在主线程中使用 <code>dispatch_sync</code> ：</p>
<pre><code class="language-objc">- (void)viewDidLoad {
    [super viewDidLoad];
    NSLog(@&quot;1&quot;);
    dispatch_sync(dispatch_get_main_queue(), ^{
        NSLog(@&quot;2&quot;);
    });
    NSLog(@&quot;3&quot;);
}

</code></pre>
</li>
<li>
<p>另外，子线程在串行队列中进行同步操作,也会死锁：</p>
<pre><code class="language-objc">dispatch_queue_t queue = dispatch_queue_create(&quot;com.xxx.xxx&quot;, DISPATCH_QUEUE_SERIAL);
dispatch_async(queue, ^{
    dispatch_sync(queue, ^{
        NSLog(@&quot;sync: %@&quot;, [NSThread currentThread]); // 出现死锁：同步任务 + 串行队列
    });
});
</code></pre>
</li>
</ul>
<h2 id="atomic-和-nonatomic-的区别"><a class="header" href="#atomic-和-nonatomic-的区别"><code>atomic</code> 和 <code>nonatomic</code> 的区别?</a></h2>
<p><code>atomic</code> 与 <code>nonatomic</code> 的主要区别就是系统自动生成的 getter/setter 方法不一样:</p>
<ul>
<li>
<p><code>atomic</code> 系统自动生成的 getter/setter 方法会进行加锁操作</p>
</li>
<li>
<p><code>nonatomic</code> 系统自动生成的 getter/setter 方法不会进行加锁操作，但更快，推荐使用 <code>nonatomic</code></p>
</li>
</ul>
<h2 id="atomic-修饰的属性是绝对安全的吗"><a class="header" href="#atomic-修饰的属性是绝对安全的吗"><code>atomic</code> 修饰的属性是绝对安全的吗？</a></h2>
<p>atomic是原子的，表示属性的 setter、getter 方法是原子的，对其进行了加锁、解锁操作。但是对象的其它方法就没有，如果多线程调用其它方法进行读写，这个时候就容易崩溃了。</p>
<p>比如 NSMutableArray 采用 atomic，对其 setter/getter 进行了加解锁的操作，但是 addObject: 却没有，当多条线程进行 add 的时候就会crash：</p>
<pre><code class="language-objc">- (void)viewDidLoad {
    [super viewDidLoad];
    
    self.numbers = [NSMutableArray array];
    dispatch_queue_t gloabl_queue = dispatch_get_global_queue(0, 0);
    dispatch_async(gloabl_queue, ^{
        for (int i = 0; i &lt; 100; i ++) {
            [self.numbers addObject:[NSNumber numberWithInt:i]];
        }
        NSLog(@&quot;count: %d&quot;, [self.numbers count]);
    });
}
</code></pre>
<p>实际上应当对 addObject: 进行加锁：</p>
<pre><code class="language-objc">- (void)viewDidLoad {
    [super viewDidLoad];
    
    self.numbers = [NSMutableArray array];
    
    self.lock = [[NSLock alloc] init];
    
    dispatch_queue_t gloabl_queue = dispatch_get_global_queue(0, 0);
    dispatch_async(gloabl_queue, ^{
        for (int i = 0; i &lt; 100; i ++) {
            [self.lock lock];
            [self.numbers addObject:[NSNumber numberWithInt:i]];
            [self.lock unlock];
        }
        NSLog(@&quot;count: %d&quot;, [self.numbers count]); // count: 100
    });
}
</code></pre>
<h2 id="atomic-的进行加锁的时候使用的是什么锁"><a class="header" href="#atomic-的进行加锁的时候使用的是什么锁"><code>atomic</code> 的进行加锁的时候使用的是什么锁？</a></h2>
<p>从 runtime 的源码 objc4的objc-accessors.mm 来看，采用的是 spinlock_t 自旋锁：</p>
<pre><code class="language-objc">id objc_getProperty(id self, SEL _cmd, ptrdiff_t offset, BOOL atomic) {
    if (offset == 0) {
        return object_getClass(self);
    }

    // Retain release world
    id *slot = (id*) ((char*)self + offset);
    if (!atomic) return *slot;
        
    // Atomic retain release world
    spinlock_t&amp; slotlock = PropertyLocks[slot];
    slotlock.lock();
    id value = objc_retain(*slot);
    slotlock.unlock();
    
    // for performance, we (safely) issue the autorelease OUTSIDE of the spinlock.
    return objc_autoreleaseReturnValue(value);
}
</code></pre>
<pre><code class="language-objc">static inline void reallySetProperty(id self, SEL _cmd, id newValue, ptrdiff_t offset, bool atomic, bool copy, bool mutableCopy)
{
    if (offset == 0) {
        object_setClass(self, newValue);
        return;
    }

    id oldValue;
    id *slot = (id*) ((char*)self + offset);

    if (copy) {
        newValue = [newValue copyWithZone:nil];
    } else if (mutableCopy) {
        newValue = [newValue mutableCopyWithZone:nil];
    } else {
        if (*slot == newValue) return;
        newValue = objc_retain(newValue);
    }

    if (!atomic) {
        oldValue = *slot;
        *slot = newValue;
    } else {
        spinlock_t&amp; slotlock = PropertyLocks[slot];
        slotlock.lock();
        oldValue = *slot;
        *slot = newValue;        
        slotlock.unlock();
    }

    objc_release(oldValue);
}
</code></pre>
<h2 id="nsmutablearray和-nsmutabledictionary-是线程安全的吗nscache-呢"><a class="header" href="#nsmutablearray和-nsmutabledictionary-是线程安全的吗nscache-呢"><code>NSMutableArray</code>、和 <code>NSMutableDictionary</code> 是线程安全的吗？<code>NSCache</code> 呢？</a></h2>
<ul>
<li>
<p><code>NSCache</code> 是线程安全的</p>
</li>
<li>
<p><code>NSMutableArray</code>、和 <code>NSMutableDictionary</code> 不是线程安全的。</p>
</li>
</ul>
<p>1.如果多个线程同时操作同一个array会出现crash</p>
<pre><code class="language-objc">    NSMutableArray *testArray = [NSMutableArray array];
    for (int i = 0; i &lt; 100; i++) {
        dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
            NSString *str = [NSString stringWithFormat:@&quot;第%d个元素&quot;, i];
            [testArray addObject:str];
        });
    }
</code></pre>
<p>2.读操作不涉及array的修改，多个线程同时读数据没有问题</p>
<pre><code class="language-objc">    NSMutableArray *testArray = [NSMutableArray array];
    for (int i = 0; i &lt; 100; i++) {
        NSString *str = [NSString stringWithFormat:@&quot;第%d个元素&quot;, i];
        [testArray addObject:str];
    }
    
    for (int i = 0; i &lt; testArray.count; i++) {
        dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
            NSString *str = [testArray objectAtIndex:i];
            NSLog(@&quot;%@&quot;, str);
        });
    }
</code></pre>
<p>3.线程A对array进行读操作，线程B对array进行写操作，也会crash</p>
<h3 id="如何实现一个线程安全的-nsmutablearray"><a class="header" href="#如何实现一个线程安全的-nsmutablearray">如何实现一个线程安全的 NSMutableArray</a></h3>
<ul>
<li>方案1: 对读写操作都加锁，效率低，因为读操作数据是安全的，可以并行。</li>
<li>方案2: 读写锁实现多读单写。</li>
</ul>
<h4 id="并发队列gcd栅栏块barrier"><a class="header" href="#并发队列gcd栅栏块barrier">并发队列+GCD栅栏块（barrier）</a></h4>
<p>使用并发队列+GCD栅栏块（barrier）实现多读单写高效线程安全的NSMutableArray</p>
<p>要实现多读单写，即：</p>
<ul>
<li>
<p>读操作和读操作并发</p>
</li>
<li>
<p>读操作和写操作互斥</p>
</li>
<li>
<p>读操作和读操作互斥</p>
</li>
<li>
<p>读操作：使用<code>dispatch_sync</code>操作并发队列 </p>
</li>
<li>
<p>写操作：使用<code>dispatch_barrier_async</code>操作并发队列：在A进行读处理的时候，B也可以额进行读取，但是不能进行写</p>
</li>
</ul>
<pre><code class="language-objc">@interface SafetyMutableArray ()

@property (nonatomic, strong) dispatch_queue_t readWriteQueue;
@property (nonatomic, strong) NSMutableArray *array;

@end

@implementation SafetyMutableArray

- (instancetype)init {
    self = [super init];
    if (self) {
        _array = [NSMutableArray array];
        _readWriteQueue = dispatch_queue_create(&quot;SaftyMutableArray.queue&quot;, DISPATCH_QUEUE_CONCURRENT);
    }
    return self;
}

#pragma mark - 读操作

- (NSUInteger)count{
    __block NSUInteger count;
    dispatch_sync(self.readWriteQueue, ^{
        count = self.array.count;
    });
    return count;
}

- (id)objectAtIndex:(NSUInteger)index {
    __block id obj = nil;
    dispatch_sync(self.readWriteQueue, ^{
        obj = [self.array objectAtIndex:index];
    });
    return obj;
}

- (nullable id)firstObject {
    __block id obj = nil;
    dispatch_sync(self.readWriteQueue, ^{
        obj= [self.array firstObject];
    });
    return obj;
}

- (nullable id)lastObject {
    __block id obj = nil;
    dispatch_sync(self.readWriteQueue, ^{
        obj = [self.array lastObject];
    });
    return obj;
}

#pragma mark - 写操作

- (void)addObject:(id)anObject {
    dispatch_barrier_async(self.readWriteQueue, ^{
        [self.array addObject:anObject];
    });
}

- (void)insertObject:(id)anObject atIndex:(NSUInteger)index {
    dispatch_barrier_async(self.readWriteQueue, ^{
        [self.array insertObject:anObject atIndex:index];
    });
}

- (void)removeAllObjects {
    dispatch_barrier_async(self.readWriteQueue, ^{
        [self.array removeAllObjects];
    });
}
                           
- (void)removeLastObject {
    dispatch_barrier_async(self.readWriteQueue, ^{
        [self.array removeLastObject];
    });
}

- (void)removeObjectAtIndex:(NSUInteger)index {
    dispatch_barrier_async(self.readWriteQueue, ^{
        [self.array removeObjectAtIndex:index];
    });
}

- (void)replaceObjectAtIndex:(NSUInteger)index withObject:(id)anObject {
    dispatch_barrier_async(self.readWriteQueue, ^{
        [self.array replaceObjectAtIndex:index withObject:anObject];
    });
}
</code></pre>
<h4 id="pthread_rwlock-读写锁"><a class="header" href="#pthread_rwlock-读写锁">pthread_rwlock 读写锁</a></h4>
<p>Apple 提供了读写锁，可以直接使用：</p>
<pre><code class="language-objc">- (id)objectAtIndex:(NSUInteger)index {
    pthread_rwlock_rdlock(&amp;_lock);
    id obj = nil;
    obj = [self.array objectAtIndex:index];
    pthread_rwlock_unlock(&amp;_lock);
    return obj;
}

- (void)addObject:(id)obj {
    pthread_rwlock_wrlock(&amp;_lock);
    [self.array addObject:obj];
    pthread_rwlock_unlock(&amp;_lock);
}
</code></pre>
<h1 id="dispatch_once-原理"><a class="header" href="#dispatch_once-原理">dispatch_once 原理</a></h1>
<p>dispatch_once 能保证任务只会被执行一次，即使同时多线程调用也是线程安全的。常用于创建单例、swizzeld method等功能。</p>
<h2 id="为什么可以保证只执行一次"><a class="header" href="#为什么可以保证只执行一次">为什么可以保证只执行一次？</a></h2>
<p><code>dispatch_once</code> 封装并执行了 <code>dispatch_once_f</code> 函数，其内部使用原子性操作block执行完成标记位，同时用信号量确保只有一个线程执行block，等block执行完再唤醒所有等待中的线程。</p>
<h2 id="dispatch_once_f-实现原理"><a class="header" href="#dispatch_once_f-实现原理">dispatch_once_f 实现原理？</a></h2>
<p>dispatch_once_f 的源码:</p>
<pre><code class="language-c">// Block 数据结构
struct Block_layout {
    // 指向表明该block类型的类
    void *isa;
    // 按bit位表示一些 block 的附加信息，比如判断 block 类型、判断 block 引用计数、判断 block 是否需要执行辅助函数等
    int flags;
    // 保留变量
    int reserved;
    // 函数指针，指向具体的 block 实现的函数调用地址
    void (*invoke)(void *, ...);
    struct Block_descriptor *descriptor;
    /* Imported variables. */
};

// 宏定义
// 触发 block 的实现
#define _dispatch_Block_invoke(bb) \
        ((dispatch_function_t)((struct Block_layout *)bb)-&gt;invoke)

// 入口方法
void dispatch_once(dispatch_once_t *val, dispatch_block_t block) {
    dispatch_once_f(val, block, _dispatch_Block_invoke(block));
}

#define DISPATCH_ONCE_DONE ((struct _dispatch_once_waiter_s *)~0l)

struct _dispatch_once_waiter_s {
    //链表下一个节点
    volatile struct _dispatch_once_waiter_s *volatile dow_next;
    // 信号量
    _dispatch_thread_semaphore_t dow_sema;
};

void dispatch_once_f(dispatch_once_t *val, void *ctxt, dispatch_function_t func) {
  	// volatileg 关键字编辑的变量 vval
    // 告诉编译器此指针指向的值随时可能被其他线程改变
    // 从而使得编译器不对此指针进行代码编译优化
    struct _dispatch_once_waiter_s * volatile *vval =
            (struct _dispatch_once_waiter_s**)val;
    struct _dispatch_once_waiter_s dow = { NULL, 0 };
    struct _dispatch_once_waiter_s *tail, *tmp;
  	// 声明信号变量
    _dispatch_thread_semaphore_t sema;

    if (dispatch_atomic_cmpxchg(vval, NULL, &amp;dow, acquire)) {
        _dispatch_client_callout(ctxt, func);

        dispatch_atomic_maximally_synchronizing_barrier();
        // above assumed to contain release barrier
        tmp = dispatch_atomic_xchg(vval, DISPATCH_ONCE_DONE, relaxed);
        tail = &amp;dow;
        while (tail != tmp) {
            while (!tmp-&gt;dow_next) {
                dispatch_hardware_pause();
            }
            sema = tmp-&gt;dow_sema;
            tmp = (struct _dispatch_once_waiter_s*)tmp-&gt;dow_next;
            _dispatch_thread_semaphore_signal(sema);
        }
    } else {
        dow.dow_sema = _dispatch_get_thread_semaphore();
        tmp = *vval;
        for (;;) {
            if (tmp == DISPATCH_ONCE_DONE) {
                break;
            }
            if (dispatch_atomic_cmpxchgvw(vval, tmp, &amp;dow, &amp;tmp, release)) {
                dow.dow_next = tmp;
                _dispatch_thread_semaphore_wait(dow.dow_sema);
                break;
            }
        }
        _dispatch_put_thread_semaphore(dow.dow_sema);
    }
}
</code></pre>
<p>其内部定义了多个 _dispatch_once_waiter_s 结构体和一个 _dispatch_thread_semaphore_t 信号量，通过原子性操作 dispatch_atomic_cmpxchg 来判断标记值 vval 是否为 NULL (首次调用 dispatch_once 时，因为外部传入的 dispatch_once_t 变量值为 nil，所以 vval 会为NULL) ，如果为 NULL，则调用 _dispatch_client_callout 来执行回调，然后在回调执行完成之后，将 vval 的值更新成 DISPATCH_ONCE_DONE (表示任务已完成)，最后，对链表的节点进行遍历，并调用 _dispatch_thread_semaphore_signal 来唤醒等待中的信号量。</p>
<p>因为dispatch_atomic_cmpxchg是原子性操作，所以只有一个线程进入到该逻辑分支中，其他线程会进入另一个分支。</p>
<p>如果不为 NULL 或其他线程同时也调用 dispatch_once 时，会判断回调是否 已标记完成 ，如果已完成则跳出循环；否则就是更新链表并调用 _dispatch_thread_semaphore_wait 阻塞线程，等待回调被标记完成后，再唤醒当前等待的线程。</p>
<h2 id="dispatch_once-中的原子性操作是怎样的"><a class="header" href="#dispatch_once-中的原子性操作是怎样的">dispatch_once 中的原子性操作是怎样的？</a></h2>
<p>原子性操作是 dispatch_atomic_cmpxchg(vval, NULL, &amp;dow, acquire) ，会将 $dow 赋值给 vval ，如果 vval 的初始值为NULL，返回 YES ,否则返回 NO 。以及dispatch_atomic_xchg(vval, DISPATCH_ONCE_DONE) 将 vval 修改为指定状态 DISPATCH_ONCE_DONE。</p>
<h1 id="参考"><a class="header" href="#参考">参考</a></h1>
<ul>
<li><a href="http://shevakuilin.com/interview-dispatch-once/">dispatch_once</a></li>
<li><a href="https://xiaozhuanlan.com/topic/7916538240">深入浅出 GCD 之 dispatch_once</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../answer/06_thread/06_ans_thread_02.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../../answer/06_thread/06_ans_thread_04.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../answer/06_thread/06_ans_thread_02.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../../answer/06_thread/06_ans_thread_04.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="../../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
